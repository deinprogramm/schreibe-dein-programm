% Diese Datei ist Teil des Buchs "Schreibe Dein Programm!"
% Das Buch ist lizensiert unter der Creative-Commons-Lizenz
% "Namensnennung - Weitergabe unter gleichen Bedingungen 4.0 International (CC BY-SA 4.0)"
% https://creativecommons.org/licenses/by-sa/4.0/deed.de

\chapter*{Vorwort\\
\normalsize von Prof.\ Torsten Grust, Universität Tübingen}
\thispagestyle{empty}

\markboth{Vorwort}{Vorwort}

Schriftsteller fürchten die leere Seite.  Maler fürchten die weiße
Leinwand.  Für Architekten ist es die grüne Wiese.  Für Programmierer
ist es der Cursor, der fordernd im leeren Fenster des Editors
blinkt~\ldots{} Wie geht man eine Programmieraufgabe an, wenn zu Beginn
keine einzige Zeile Code existiert, wenn keine Funktion oder
Datenstruktur Orientierung bietet, und wenn zwar \emph{alles} möglich
aber gerade deshalb schwer greifbar erscheint?

Mike Sperber und Herbert Klaeren haben in \textit{Schreibe Dein
Programm!} hierzu gute Nachrichten.  Programme lassen sich nämlich sehr
systematisch konstruieren und~-- teilweise nahezu auto\-ma\-tisch~-- aus der
gegebenen Problemstellung ableiten.  Über das gesamte Buch verstreut
finden sich \textit{Konstruktionsanleitungen}, deren Programmskelette
konkrete Hinweise auf die Struktur der Lösung des Problems geben.  Steht
das Skelett erst einmal, lassen sich dessen Lücken oft unmittelbar
vervollständigen, teils durch die Nutzung weiterer derartiger
Konstruktionen, teils weil sich die Komplettierung direkt aus dem
Problem ergibt.  Programmierung mittels dieser Konstruktions\-anleitungen
kommt dem disziplinierten ingenieursmäßigen Bauen näher als alles
andere.

Aus meinen Vorlesungen \textit{Informatik~I} an der Universität Tübingen
kommen die Studierenden nicht heraus, ohne sich ordentlich "<die Finger
schmutzig gemacht zu haben">.  In der Vor\-lesung selbst, den
wöchentlichen Übungsblättern und zusätzlichen betreuten
Programmierstunden wird Code geschrieben, was das Zeug hält.  Dabei
konnte ich bereits Hunderte von Studierenden~-- typischerweise echte
Anfänger, die noch keine Programmiersprache kennen~-- beobachten, wie
mittels Konstruktionsanleitungen die Herausforderung des leeren Editors
angenommen und gemeistert wurde.  Die resultierenden Programme sind
(zumeist \texttt{;-)}) korrekt, kompakt und, vor allem, lesbar und
nachvollziehbar.  Wir können so in der \textit{Informatik~I} erstaunlich
anspruchsvolle Auf\-gaben angehen und sind am Ende des zweiten
Drittels der Vorlesung in der Lage, die Studierenden \textit{PacMan},
\textit{Tetris} oder \textit{Asteroids} nachbauen zu lassen.

\textit{Schreibe Dein Programm!} ist gleichzeitig eine Einführung in die
funktionale Programmierung mit Scheme.  Scheme selbst tritt mit seiner
einfachen Syntax in den Hintergrund\footnote{Wo wir üblicherweise einen
Zoo von Notationen $x+1$, $\sin(x)$, $x^2$, $\vert x\vert$, $\sqrt{x}$,
$x!$, \dots nutzen, begnügt sich Scheme uniform mit der
Notation~\texttt{(f~x)}.} und gibt den Blick frei auf die essentiellen
Ideen des Denkens und Programmierens mit (mathematischen) Funktionen.
Genau wie Mike Sperber und Herbert Klaeren bin ich überzeugt, dass
dieses elegante Programmierparadigma "<gekommen ist, um zu bleiben"> und
auf lange Sicht Programmierstil und -sprachen weitreichend beeinflussen
wird.  Zusammen mit den Konstruktionsanleitungen gibt dieses Buch
Programmieranfängern daher gleich zwei Superkräfte mit auf den Weg.  Das
nenne ich einen \emph{Deal}!
%
\begin{flushright}
  Torsten Grust

  Tübingen, Juli~2019
\end{flushright}

\section*{Danksagungen}

Peter Thiemann, Martin Gasbichler, Andreas Schilling, Torsten Grust und Michael Hanus hielten
Vorlesungen auf Basis dieses Buchs und lieferten wertvolle Rückmeldungen.
Besonderer Dank gebührt den Tutorinnen und Tutoren und Studierenden unserer Vorlesung
\textit{Informatik I}, die eine
Fülle hilfreicher Kritik und exzellenter Verbesserungsvorschläge
lieferten.

Seitdem die Entwicklung des Buches offen auf Github stattfindet, haben
außerdem viele Leserinnen und Leser Verbesserungsvorschläge und
Pull-Requests gemacht, darunter Nicolas Neuß, Joachim Breitner,
Raphael Borun Das Gupta, Tobias Huttner, Nicolai Mainiero, Johannes
Maier, Sibylle Hasse, Manuela Reinisch, Noah Haasis, mi-skam, uwffi, 
Aramís, TheKarcher, chessgarf, Beat Hagenlocher, Denis Maier, Philipp Kiersch, Simon Barth,
Kaan Sahin, Erika Bor und Christina Zeller.

Davor brachten Robert Giegerich, Ulrich Güntzer, Martin Plümicke,
Christoph Schmitz und Volker Klaeren, Eric Knauel, Marcus Crestani,
Sabine Sperber, Jan-Georg Smaus und Mayte Fleischer viele Korrekturen
und Verbesserungen ein, insbesondere zum Vorgängerbuch \textit{Vom
  Problem zum Programm}.
Katharina von Savigny hatte entscheidenden Anteil an der sprachlichen
Gestaltung des Buchs.

Wir danken Sandra Binder, Peter Rempis und Axel Braun von der Tübingen
University Press für die tolle Unterstützung und Geduld mit uns,
und besonders Susanne Schmid für das Umschlag-Motiv.

Unter unseren didaktischen Vorbildern waren Matthias
Felleisen, Robby Findler, Matthew Flatt und Shriram Krishnamurthi und
ihr Buch~\textit{How to Design Programs}
\cite{FelleisenFindlerFlattKrishnamurthi2001} besonders wichtig, aus
dem wir viele Ideen übernommen haben.  Das im Rahmen ihres
PLT"=Projekts entwickelte Racket-System ist eine entscheidende
Grundlage für die Arbeit mit diesem Buch.


\begin{flushright}
  Michael Sperber, Herbert Klaeren
  Tübingen, Juli 2023
\end{flushright}


\newpage

\thispagestyle{empty}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "i1"
%%% End:

