% Diese Datei ist Teil des Buchs "Schreibe Dein Programm!"
% Das Buch ist lizensiert unter der Creative-Commons-Lizenz
% "Namensnennung - Weitergabe unter gleichen Bedingungen 4.0 International (CC BY-SA 4.0)"
% https://creativecommons.org/licenses/by-sa/4.0/deed.de

\chapter{Elemente des Programmierens}
\label{cha:whats-programming}

Dieses Kapitel gibt einen Überblick über das wichtigste Handwerkszeug
des Programmierens: Welche Software Du dafür brauchst, wie Du diese
Software bedienst, wie kleine Programme aussehen und aus welchen
Elementen sie bestehen.

\section{DrRacket}

Zunächst einmal benötigst Du die Software \textit{Racket}\index{Racket}, die es zum
kostenlosen Download auf der Seite \url{https://racket-lang.org/} für
alle gängigen Plattformen gibt.  Auf der Seite ist ein
\texttt{Download}-Knopf~-- folge den dortigen Instruktionen für die
Installation.\footnote{Achte darauf, dass Du mindestens Version 7.7
bekommst~-- das ist besonders relevant, wenn Du einen anderen
Installationsweg wählst, wie zum Beispiel einen Package-Manager für
eine Linux-Distribution.}

\begin{figure}[tb]
  \centering
  \includegraphics[width=\textwidth]{i1prog/drracket-start}
  \caption{DrRacket nach dem ersten Start}
  \label{fig:drracket-start}
\end{figure}

Zu Racket gehört ein Programm namens
\textit{DrRacket}\index{DrRacket}: starte es.  Es erscheint ein
Fenster, das ungefähr so aussehen sollte wie in
Abbildung~\ref{fig:drracket-start}.  Die Benutzeroberfläche kannst
Du auf Deutsch umstellen, indem Du im Hilfe-Menü auf \texttt{Deutsche
  Benutzeroberfläche für DrRacket} drückst.  Wenn Du die Auswahl
bestätigst, wird DrRacket danach beendet und Du musst es noch einmal
starten; dann sollten die Menüs auf Deutsch sein.

DrRacket ist eine \textit{Entwicklungsumgebung}, mit der Du Programme
schreiben und ausführen kannst.  DrRacket unterstützt nicht nur eine
Programmiersprache, darum musst Du die richtige Programmiersprache für
dieses Buch noch auswählen.  Dazu wählst Du den Menüpunkt
\texttt{Sprache $\rightarrow$ Sprache auswählen} (bzw.\
\texttt{Language $\rightarrow$ Choose language} in der englischen
Fassung), worauf ein Dialog erscheint.  In dem Dialog gibt es eine
Abteilung \texttt{Lehrsprachen\index{Lehrsprachen}}, und darunter eine
Überschrift namens \texttt{DeinProgramm}, unterhalb dessen mehrere
Einträge erscheinen, die speziell auf die Kapitel dieses Buchs
zugeschnitten sind.

\begin{figure}[tb]
  \centering
  \includegraphics[width=\textwidth]{i1prog/drracket-deinprogramm}
  \caption{DrRacket mit ausgewählter Lehrsprache}
  \label{fig:drracket-deinprogramm}
\end{figure}

Für den ersten Teil des Buches ist die Ebene \texttt{Schreibe Dein
  Programm! - Anfänger} zuständig:\index{Sprachebene!Anfänger} Wähle
diese aus und drücke dann einmal oben rechts auf den Knopf
\texttt{Start} (bzw.\ \texttt{Run}), damit die Auswahl aktiv wird.
Das Ergebnis sollte dann so aussehen wie in
Abbildung~\ref{fig:drracket-deinprogramm}.

Das DrRacket-Fenster besteht aus zwei Teilen:
%
\begin{enumerate}
\item In der oberen Hälfte des Fensters (dem
  \textit{Editor\index{Editor}} oder
  \textit{Definitionsfenster\index{Definitionsfenster}}) steht der
  Programmtext.  Der Editor funktioniert ähnlich wie ein reguläres
  Textverarbeitungsprogramm.  Was dort steht, kannst Du abspeichern.
\item In der unteren Hälfte des Fensters~-- dem
  \textit{Interaktionsfenster\index{Interaktionsfenster}} oder der
  sogenannten \textit{REPL\index{REPL}}\footnote{"<REPL"> steht für
    "<Read-Eval-Print-Loop">~-- wir werden später zeigen, warum.}
  werden die Ausgaben des Programms angezeigt.  Außerdem kannst Du
  hier "<Fragen"> an das Programm stellen, um einzelne Programmteile
  gezielt auszuprobieren.
\end{enumerate}
%

\section{Ausdrücke und die REPL}

Fangen wir mit der REPL an: Wenn Du gerade \texttt{Start} gedrückt
hast, dann erscheint der Cursor rechts von dem \verb|>|-Zeichen: Du
kannst da etwas eingeben und Return drücken~-- DrRacket zeigt dann
das Ergebnis darunter an.

Wenn Du zum Beispiel \texttt{123} eintippst, zeigt DrRacket gleich
darunter 123 an.  DrRacket kann auch rechnen.  Dafür musst Du
allerdings die Rechenaufgaben etwas anders aufschreiben als sonst.
Zum Beispiel so:
%
\begin{verbatim}
(+ 123 42)
\end{verbatim}
%
Wenn Du das in die REPL tippst, zeigt DrRacket \texttt{165} an, die
\textit{Summe}\index{Summe} von 123 und 42.  Diese "<Rechenaufgabe">
ist ein sogenannter \textit{Ausdruck\index{Ausdruck}}.  Ausdrücke, die
etwas ausrechnen sollten, haben in den Lehrsprachen immer die gleiche
Form, und die sieht so aus:
%
\begin{alltt}
(\textnormal{\textit{Operator}} \textnormal{\textit{Operand}} \ldots)
\end{alltt}
%
Das heißt, da stehen \emph{immer} Klammern\index{Klammer} drumherum
(und die können auch nirgendwo sonst stehen).  Dann steht da der
\textit{Operator\index{Operator}}, der bestimmt, \emph{was} gemacht
wird, also die \textit{Operation}.  Danach kommen die
\textit{Operanden\index{Operand}}, welche die Eingaben\index{Eingabe}
für die Operation bestimmen.

Zum Merken ist es hilfreich, Ausdrücke entsprechend vorzulesen: Also
nicht mehr "<Hundertdreiundzwanzig plus zweiundvierzig">, sondern
"<die \emph{Summe} von Hundertdreiundzwanzig und zweiundvierzig">.

Wie schon gesagt, die Klammern sind wichtig.  Wenn Du sie vergisst,
können verwirrende Ergebnisse herauskommen.  Wenn Du zum Beispiel
\texttt{+ 123 42} in der REPL eintippst, sieht das so aus:
%
\begin{alltt}
> + {\color{green}123 42}
{\color{blue}#<function:+>
123
42}
\end{alltt}
%
Das liegt daran, dass ohne Klammern \texttt{+ 123 32} aus \emph{drei}
Ausdrücken besteht und die REPL darum auch drei Ergebnisse ausdruckt:
Die Funktion \texttt{+}, dann die \texttt{123}, dann \texttt{42}.
(Die Operation \texttt{+} ist eine sogenannte Funktion~-- das
erläutern wir später noch genauer.)  Ähnlich verhält es sich mit
\texttt{123 + 42}~-- probiere es aus!

Wenn Du versehentlich den Operator dazwischen schreibst, erscheint
in der REPL eine Fehlermeldung:
%
\begin{alltt}
> ({\color{green}123} + {\color{green}42})
{\color{red}Operator darf keine Zahl sein, ist aber 123}
\end{alltt}
%
Etwas ähnliches passiert, wenn Du kein Leerzeichen zwischen den
Operator und die Operanden oder zwischen die Operanden setzt.  Das
sieht zum Beispiel so aus:
%
\begin{alltt}
> ({\color{green}+123} {\color{green}42})
{\color{red}Operator darf keine Zahl sein, ist aber 123}
\end{alltt}
%
Das liegt daran, dass \texttt{+123} zusammen die Zahl "<plus
hundertdreiundzwanzig"> bildet und nicht etwa in das \texttt{+}-Zeichen und
\texttt{123} aufgeteilt wird.

Wenn ein Ausdruck wie \texttt{(+ 123 42)} ein Ergebnis wie 165 hat,
schreiben wir das im Buch zukünftig so, etwas anders als die
DrRacket-REPL:
%
\begin{alltt}
(+ 123 42)
\evalsto{} 165
\end{alltt}
%
Es gehen natürlich nicht nur Summen, sonderen auch Differenzen,
Produkte und Quotienten:
%
\begin{alltt}
(- 123 42)
\evalsto{} 81
(* 123 42)
\evalsto{} 5166
(/ 123 42)
\evalsto{} 2.9\(\overline{\mathtt{285714}}\)
\end{alltt}
%
Beim letzen Ausdruck ist zu sehen, dass Dezimalzahlen mit Punkt und
nicht mit Komma geschrieben werden.  Der Überstrich bei
\texttt{2.9\(\overline{\mathtt{285714}}\)} ist eine
\textit{Periode\index{Periode}}. Die Zahl ist also eigentlich
%
\begin{alltt}
2.9285714285714285714285714285714\ldots
\end{alltt}
%
Die REPL funktioniert also folgendermaßen: Sie \emph{liest} einen
Ausdruck ein ("<read">), berechnet dessen Wert oder \emph{wertet}
diesen \emph{aus} (auf Englisch "<eval">) und zeigt das Ergebnis an
oder \emph{druckt} dieses \emph{aus} ("<print">)~-- und dann geht es
von vorn los, wie in einer Schleife ("<loop">).  Die Abfolge
\emph{Read-Eval-Print-Loop} gibt der REPL ihren Namen.

Ausdrücke können auch kombiniert werden, zum Beispiel so:
%
\begin{alltt}
(* 123 (+ 20 22))
\evalsto{} 5166
(* 123 (+ (* 2 10) 22))
\evalsto{} 5166
\end{alltt}
%
Bei der Kombination ist wichtig, dass um jeden Teilausdruck wieder ein
Klammernpaar kommt.  Ist das nicht der Fall, erscheinen gelegentlich
auch mal Fehlermeldungen wie diese hier:
%
\begin{alltt}
(* 123 (+ * 2 10 22))
{\color{red}+: Zahl als erstes Argument erwartet, #<function:*> bekommen}
\end{alltt}
%
Das liegt daran, dass das \texttt{*} hier an der Stelle eines
Operanden für die Summe dient.  Das Wort \textit{Argument} steht für
den Wert des Operanden einer Funktion, darum steht da sinngemäß, dass
\texttt{+} eine Zahl als erstes Argument etwartet, aber
stattdessen die Funktion \texttt{+} bekommen hat.  (Das Wort
"<Argument"> definieren wir genauer in Abschnitt~\ref{sec:argument} auf
Seite~\pageref{sec:argument}.)

Abspeichern geht mit der REPL nicht, und der REPL-Inhalt verschwindet
auch jedesmal, wenn Du \texttt{Start} bzw.\ \texttt{Run} drückst.  Du
kannst aber frühere Eingaben zurückholen, indem Du
\texttt{Strg-$\uparrow$} beziehungsweise \texttt{Control-$\uparrow$}
(je nach Computertyp) drückst.  Das kannst Du auch benutzen, um einen
fehlerhaften Ausdruck zu korrigieren, bei dem Du schon Return gedrückt hast.

\begin{aufgabeinline}
  Schreibe folgende "<mathematischen"> Ausdrücke in der Notation der
  Lehrsprache in die REPL und lasse die REPL sie auswerten:
  %
  \begin{displaymath}
    \begin{array}{c}
      55 * 27\\
      23 * (44 + 27)\\
      \frac{23}{44} + \frac{44}{23}\\
      (23 + 42) * (12 + (14 * 2))
    \end{array}
  \end{displaymath}
\end{aufgabeinline}
%
\section{Das Definitionsfenster}

Kommen wir zum Definitionsfenster oben.  Dort schreibst Du Dein
Programm, die REPL kannst Du dann benutzen, um es auszuprobieren.
Schreib in das Definitionsfenster folgende
\textit{Definition\index{Definition}}:
%
\begin{verbatim}
(define alles (+ 20 22))
\end{verbatim}
%
Diese Definition besagt, dass der Name \texttt{alles} für das Ergebnis
von \texttt{(+ 20 22)} steht.  Um das auszuprobieren, drück auf den
Knopf \texttt{Start} bzw.\ \texttt{Run} rechts oben.  Der Cursor
landet dann wieder in der REPL, wo Du das Programm ausprobieren
kannst:
%
\begin{alltt}
alles
\evalsto{} 42
\end{alltt}
%
Ein Name, der in einem Programm so definiert ist, heißt
\textit{Variable\index{Variable}}.

Hier sind ein paar weitere Beispiele für Definitionen:
%
\begin{alltt}
(define one 1)
(define temperature 23)
(define birgit-prinz 9)
(define michael-ballack 13)
\end{alltt}
%
Bei der Gestaltung eines Namens gibt es weitgehende
Freiheiten.\footnote{Anders als in anderen Programmiersprachen sind
  auch Bindestriche in Namen möglich.}  Nur Leerzeichen sind nicht
erlaubt.

In einem Programm kannst Du Zeilenumbrüche und Einrückung benutzen, um
Dein Programm übersichtlicher zu gestalten.  Zum Beispiel kannst Du
nach \texttt{alles} die Return-Taste drücken, das Ergebnis sieht so
aus:
%
\begin{alltt}
(define alles
  (+ 20 22))
\end{alltt}
%
DrRacket rückt die zweite Zeile ein bisschen ein, um auszudrücken,
dass sie noch in die Klammern vom \texttt{define} gehört.  Bei
komplizierteren Ausdrücken ist das hilfreich:
%
\begin{verbatim}
(define alles
  (+ 20
     (* 11 2)))
\end{verbatim}
%
Hier stellt DrRacket die Operanden der Summe genau untereinander.
DrRacket zwingt Dich nicht, die Einrückung genau so zu machen, und
durch Änderungen im Programm gerät sie auch manchmal aus dem Lot.  In
dem Fall kannst Du die Tab-Taste drücken (auf den meisten Tastaturen
steht $\longrightarrow\mid$ auf der Tab-Taste) und in der Zeile, in
welcher der Cursor steht, wird die Einrückung korrigiert.
Wenn Du einen Abschnitt im Programm markierst und dann Tab drückst,
wird der ganze Abschnitt neu eingerückt.  
Es gibt
außerdem einen Menüpunkt \texttt{Racket $\rightarrow$ Alles einrücken} (bzw.\
\texttt{Racket $\rightarrow$ Reindent All}), der das für das gesamte
Programm macht.

Ein weiterer praktischer Trick ist, dass Du einen geklammerten
Ausdruck markieren (und dann ausschneiden) kannst, indem Du auf die
öffnende oder schließende Klammer doppelt klickst.  Insbesondere
kannst Du den markierten Ausdruck dann mit einem Druck auf die
Tab-Taste korrekt einrücken.

\begin{aufgabeinline}
  Bring bei einem mehrzeiligen Programm die Einrückung richtig
  durcheinander, zum Beispiel so:
\begin{verbatim}
(define nr
  (+ 12
 (- (* 42
  13)
    500)))
\end{verbatim}
  %
  Benutze dann die Tab-Taste, um die Einrückung wieder zu korrigieren.
\end{aufgabeinline}
%
Den Inhalt des Definitionsfenster kannst Du abspeichern, indem Du auf
den Knopf mit dem Diskettensymbol
\raisebox{-1ex}{\includegraphics[height=12pt]{i1prog/save}} drückst.

\section{Rechnen ohne Zahlen}

Computerprogramme können nicht nur mit Zahlen rechnen.  In diesem
Abschnitt geht es um das Rechnen mit Text und das Rechnen mit Bildern.

\subsection{Rechnen mit Zeichenketten}

Zum Beispiel gibt es auch Text, der in einem Programm immer von
doppelten Anführungszeichen umschlossen ist, zum Beispiel:
%
\begin{alltt}
"Mike Sperber"
"Herbert Klaeren"
"Schreibe Dein Programm!"
\end{alltt}
%
Diese Werte heißen \textit{Zeichenketten\index{Zeichenkette}}.

Die einfachste Art, eine Zeichenkette herzustellen, ist, die
Buchstaben hinzuschreiben, aus denen sie besteht.  Die
Anführungszeichen müssen drumherum, damit die Zeichenketten von anderen
Ausdrücken unterschieden werden können.  Die Anführungszeichen gehören aber nicht
zu den Buchstaben dazu, aus denen die Zeichenkette besteht~--
\verb|"abc"| besteht aus den drei Buchstaben \texttt{abc}.

\begin{feature}{Zeichenketten}{scheme:strings}
\textit{Zeichenketten\index{Zeichenkette}} (auf Englisch
\textit{Strings}\index{String}) repräsentieren Text.
Literale für Zeichenketten haben folgende Form:
%
\begin{alltt}
"\(z\sb{1}\)\(z\sb{2}\) \(\ldots\) \(z\sb{n}\)"
\end{alltt}
%
Dabei sind die \(z\sb{i}\) beliebige einzelne Zeichen, außer \verb|"| selbst.
Beispiel:
%
\begin{alltt}
"Herbert was here!"
\end{alltt}
%
Das Anführungszeichen (\verb|"|) kann nicht "<ungeschützt"> vorkommen, da es das Ende der
Zeichenkette markiert. Es wird als Zeichen innerhalb einer Zeichenkette
durch \verb|\"| dargestellt:
%
\begin{alltt}
"Herbert sagt, Mike wäre \backwhack{}"doof\backwhack{}"!"
\end{alltt}
\end{feature}

Abbildung~\ref{scheme:strings} beschreibt die genaue Schreibweise für
solche "<festen"> Zeichenketten.  Feste Schreibweisen für Werte heißen
allgemein \textit{Literale\index{Literal}}.  Das kennen wir schon von
den Zahlen: Die Zeichenfolge \texttt{123} steht für die Zahl
"<hundertdreiundzwanzig">.  Kästen wie Abbildung~\ref{scheme:strings}
werden in diesem Buch noch oft dazu dienen, neue Sprachelemente
einzuführen.

Mit Text kann ein Programm auch rechnen, und zwar mit der eingebauten
Funktion
\texttt{string"=append}\index{string-append@\texttt{string-append}},
die zwei Zeichenketten aneinanderhängt:
%
\begin{alltt}
(string-append "Herbert" "Mike")
\evalsto{} "HerbertMike"
(string-append "Mike" " " "ist doof")
\evalsto{} "Mike ist doof"
\end{alltt}
%
Die eingebaute Funktion
\texttt{string-length}\index{string-length@\texttt{string-length}}
liefert die Anzahl der Buchstaben in einer Zeichenkette:
%
\begin{alltt}
(string-length "Herbert")
\evalsto{} 7
(string-length "Mike")
\evalsto{} 4
\end{alltt}
%
Die Namen \texttt{string-append} und \texttt{string-length} sehen auf
den ersten Blick "<anders"> aus als \texttt{+} und \texttt{*} zum
Beispiel, dieser Eindruck täuscht jedoch: Sie sind allesamt Namen von
vordefinierten Operationen, die Programme benutzen können, ohne sie
selbst definieren zu müssen.

Die vordefinierten Funktionen
\texttt{string->number}\index{string->number@\texttt{string->number}}
und \texttt{number->string} konvertieren zwischen Zahlen und den
Zeichenketten, die diese darstellen:
%
\begin{alltt}
(string->number "23")
\evalsto{} 23
(number->string 23)
\evalsto{} "23"
\end{alltt}
%
\begin{aufgabeinline}
  Mache Dir den Unterschied zwischen der Zahl \texttt{23} und der
  Zeichenkette \verb|"23"| klar.  Probiere zum Beispiel aus:
\begin{alltt}
(+ "23" 42)
(string-append 23 "42")
(number->string "23")
\end{alltt}
\end{aufgabeinline}

\subsection{Rechnen mit Bildern}
\label{sec:rechnen-mit-bildern}

Programme können auch mit Bildern rechnen.  Dazu wird eine Erweiterung
zu DrRacket benötigt, ein sogenanntes
\textit{Teachpack}\index{Teachpack}: Wähle den Menüpunkt
\texttt{Sprache $\rightarrow$ Teachpack hinzufügen} beziehungsweise
\texttt{Language $\rightarrow$ Add Teachpack}.  In dem folgenden Dialog
wähle \texttt{image.rkt} aus und drücke 
\texttt{OK}.  Dann musst Du noch einmal auf \texttt{Start} drücken.

Das Teachpack \texttt{image.rkt} enthält zusätzliche vordefinierte
Funktionen, mit denen wir Bilder herstellen können.  Zum Beispiel
\texttt{square}, \texttt{circle} und \texttt{star-polygon}:
%
\begin{alltt}
(square 40 "solid" "red")
\evalsto{} \includegraphics[height=24pt]{i1prog/square}
(circle 20 "solid" "green")
\evalsto{} \includegraphics[height=24pt]{i1prog/circle}
(star-polygon 20 10 3 "solid" "blue")
\evalsto{} \includegraphics[height=24pt]{i1prog/starpolygon}
\end{alltt}
%
Schauen wir uns das eingebaute \texttt{star-polygon} etwas näher an:
Es akzeptiert fünf Eingaben, die ersten drei davon sind Zahlen~-- die
Seitenlänge, die Seitenanzahl und die Anzahl der Ecken, die für jede
Seite übersprungen wird.  Danach kommen zwei Zeichenketten~--
\verb|"solid"| heißt, dass das Innere des Sterns ausgefüllt ist und
\verb|"blue"| ist die Farbe.  Statt \verb|"solid"| kannst Du auch
\verb|"outline"| schreiben, dann wird auch etwas klarer, was
"<überspringen"> heißt:
%
% filename can't contain hyphen because of alltt
\begin{alltt}
(star-polygon 20 10 3 "outline" "blue")
\evalsto{} \includegraphics[height=24pt]{i1prog/starpolygon_outline}
\end{alltt}
%
\begin{aufgabeinline}
  Wofür stehen die Zahleneingaben bei \texttt{square} und
  \texttt{circle}?  Probiere unterschiedliche Zahlen aus!  Es gibt
  auch eine eingebaute Funktion \texttt{rectangle}.  Kannst Du ein
  funktionierendes Beispiel für den Einsatz von \texttt{rectangle}
  konstruieren?  Außerdem gibt es eine eingebaute Funktion
  \texttt{ellipse}, die genauso benutzt wird wie \texttt{rectangle}~--
  probiere sie aus!
\end{aufgabeinline}
%
Bilder sind Werte wie Zahlen und Zeichenketten auch.  Du kannst
mit Definitionen auch Namen dafür vergeben:
%
\begin{verbatim}
(define s1 (square 40 "solid" "red"))
(define c1 (circle 40 "solid" "green"))
(define p1 (star-polygon 20 10 3 "solid" "blue"))
\end{verbatim}
%
\begin{aufgabeinline}
  Du kannst auch Bilddateien oder Bilder in Webseiten in Dein Programm
  einfügen, wie in einem Textverarbeitsprogramm.  Probier es aus und
  gib dem Bild einen Namen!
\end{aufgabeinline}
%
Mit Bildern kann DrRacket auch rechnen:
%
\begin{alltt}
(beside s1 p1)
\evalsto{} \includegraphics[height=24pt]{i1prog/beside.png}
(above s1 c1)
\evalsto{} \includegraphics[width=24pt]{i1prog/above.png}
(above (beside s1 p1) (beside p1 c1))
\evalsto{} \includegraphics[width=48pt]{i1prog/abovebeside.png}
\end{alltt}
%
\begin{aufgabeinline}
  Probiere in der der REPL folgende Ausdrücke aus:
\begin{verbatim}
(triangle 50 "outline" "red")
(square 100 "solid" "blue")
\end{verbatim}
  %
  Schreibe mit Hilfe der Funktionen \texttt{triangle} und
  \texttt{square} einen Ausdruck, der ein ganz einfaches Haus
  berechnet.
\end{aufgabeinline}
%
Das heißt, \texttt{beside} akzeptiert als Eingabe zwei (oder mehr)
Bilder und macht daraus wieder ein Bild, in dem die Teilbilder
nebeneinander stehen.  Das gleiche gilt für \texttt{above}, nur dass
die Bilder übereinander angeordnet werden.  Selbstverständlich können
\texttt{above} und \texttt{beside} auch kombiniert werden.

\section{Abstraktion und Applikation}
\label{sec:abstraktion-und-applikation}

Hier sind zwei Ausdrücke, welche die Bilder aus dem vorigen Abschnitt
zu einem Muster kombinieren:
%
\begin{alltt}
(above
 (beside s1 p1)
 (beside p1 s1))
\evalsto{} \includegraphics[width=48pt]{i1prog/tile1}

(above
 (beside p1 c1)
 (beside c1 p1))
\evalsto{} \includegraphics[width=48pt]{i1prog/tile2}
\end{alltt}
%
Beide Ausdrücke folgen dem gleichen Muster, sie "<kacheln"> jeweils zwei
Bilder in einer quadratischen Anordnung.  Das Muster könnte man so
hinschreiben:
%
\begin{verbatim}
(above
 (beside a b)
 (beside b a))
\end{verbatim}
%
Das erste Beispiel entsteht dann, indem für \texttt{a} \texttt{s1}
eingesetzt wird und für \texttt{b} \texttt{p1}, im zweiten für \texttt{a}
\texttt{p1} und für \texttt{b} dann \texttt{c1}.

Dieses Muster kannst Du in ein Programm gießen.  Dann müssen wir nicht
jedesmal \texttt{above \ldots{} beside \ldots{} beside} eintippen.
Dazu schreibst Du es erst einmal genauso hin, also mit \texttt{a} und
\texttt{b}.  Wenn Du das Programm startet, erscheint folgende Meldung:
%
\begin{alltt}
\color{red}a: Ungebundene Variable
\end{alltt}
%
Na klar, es gibt ja auch keine Definition für \texttt{a}.  Du könntest
eine hinschreiben, zum Beispiel:
%
\begin{verbatim}
(define a s1)
\end{verbatim}
%
Aber dann wäre \texttt{a} auf \texttt{s1} festgelegt.  Wir wollen
stattdessen das Muster verallgemeinern, so dass Du es mehrmals mit
unterschiedlichen Werten für \texttt{a} und \texttt{b} verwenden
kannst.  Dieser Verallgemeinerungsprozess heißt beim Programmieren
\textit{Abstraktion\index{Abstraktion}}.  Dafür müssen wir dem Muster
noch etwas hinzufügen, um zu sagen, dass wir unterschiedliche Werte
für \texttt{a} und \texttt{b} einsetzen wollen:
%
\begin{verbatim}
(lambda (a b)
  (above
   (beside a b)
   (beside b a)))
\end{verbatim}
%
Das \texttt{lambda}\index{lambda@\texttt{lambda}} ist eine Art Zauberwort, es sagt soviel wie: "<Für
die Variablen \texttt{a} und \texttt{b} möchte ich später (und
vielleicht mehrmals) Werte einsetzen.">  Wenn Du das Programm jetzt
startest, geht die Fehlermeldung weg und in der REPL erscheint:
%
\begin{alltt}
#<function:\ldots>
\end{alltt}
%
(Der Text anstelle des \ldots{} variiert etwas von Fall zu Fall.)

Das deutet darauf hin, dass bei dem \texttt{lambda} eine Funktion
herauskommt.  Um etwas damit anfzufangen, gib ihr einen Namen mit
\texttt{define}:
%
\begin{verbatim}
(define tile
  (lambda (a b)
    (above
     (beside a b)
     (beside b a))))
\end{verbatim}
%
(Alles schön richtig einrücken! "<Tile"> heißt auf Deutsch
"<kacheln">.)

Dadurch ist eine neue Operation entstanden.  Die kannst Du direkt
verwenden:
%
\begin{alltt}
(tile s1 p1)
\evalsto{} \includegraphics[width=48pt]{i1prog/tile1}

(tile p1 c1)
\evalsto{} \includegraphics[width=48pt]{i1prog/tile2}
\end{alltt}
%
Was ist da passiert?  Am einfachsten kann man das in einem speziellen
Werkzeug sehen, dem \textit{Stepper\index{Stepper}}.  Um ihn zum
Einsatz zu bringen, sorge dafür, dass im Definitionsfenster folgendes
Programm steht, also das, was weiter oben schon steht:
%
\begin{verbatim}
(define s1 (square 40 "solid" "red"))
(define c1 (circle 40 "solid" "green"))
(define p1 (star-polygon 20 10 3 "solid" "blue"))

(define tile
  (lambda (a b)
    (above
     (beside a b)
     (beside b a))))

(tile s1 p1)
(tile p1 c1)
\end{verbatim}
%
Dann drück auf den \texttt{Stepper}-Knopf oben rechts im
DrRacket-Fenster.  Es erscheint ein neues Fenster, das so aussieht:

\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{i1prog/stepper-0}
  \caption{Der Stepper in Aktion}
  \label{fig:stepper-0}
\end{figure}
%
\noindent Du kannst jetzt mit den Knöpfen mit dem Vorwärts- beziehungsweise dem
Rückwärts-Pfeil zusehen, wie DrRacket Dein Programm ausführt.  Wenn Du
ein paar Schritte vorwärts gehst, sieht das so aus:
%
\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{i1prog/stepper-1}
  \caption{Stepper: Variable ersetzen}
  \label{fig:stepper-1}
\end{figure}
%
\noindent Du kannst sehen, wie DrRacket jeweils einen Ausdruck einen Schritt auf
einmal auswertet~-- der ist auf der linken Seite grün~-- und dann
rechts durch das Resultat ersetzt.  Oben kannst Du sehen, wie der
Stepper die Variable \texttt{tile} durch den \texttt{lambda}-Ausdruck
aus der Definition von \texttt{tile} ersetzt. Das macht der Stepper
auch mit den Definitionen von \texttt{s1} und \texttt{p1}:
%
\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{i1prog/stepper-2}
  \caption{Stepper: Variable}
  \label{fig:stepper-2}
\end{figure}
%
\noindent Interessant wird es danach. Die Variablen aus den Definitionen sind
alle ersetzt.  Hinter dem \texttt{lambda}-Ausdruck stehen jetzt das
Quadrat und der Stern, und die werden jetzt für die Variablen aus dem
\texttt{lambda}-Ausdruck eingesetzt, also das Quadrat für \texttt{a}
und der Stern für \texttt{b}:
%
\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{i1prog/stepper-3}
  \caption{Stepper: Applikation}
  \label{fig:stepper-3}
\end{figure}
%
\noindent Dabei verschwindet auch das \texttt{lambda}.
%
\begin{aufgabeinline}
  Probiere das Beispiel im Stepper aus und klicke Dich bis zum Ende
  durch. Mache Dir dabei klar, wie jeweils die linke mit der rechten
  Seite zusammenhängt.
\end{aufgabeinline}
%
\texttt{(tile s1 p1)} ist eine sogenannte
\textit{Applikation\index{Applikation}}: Das ist ein Ausdruck mit
(natürlich) Klammern drum.  Der Operator und die Operanden der
Applikation sind ebenfalls Ausdrücke.  Der Operator ergibt eine
Funktion~-- entweder eingebaut oder aus einem
\texttt{lambda}-Ausdruck.  Eine Applikation wird auch oft
\textit{Funktionsaufruf\index{Funktionsaufruf}} oder
\textit{Funktionsanwendung\index{Funktionsanwendung}} genannt.

Wenn die Funktion ein \texttt{lambda}-Ausdruck ist wie in
Abbildung~\ref{fig:stepper-3}, dann muss es genauso viele Operanden
geben wie der \texttt{lambda}-Ausdruck Variablen hat.
Dann wertet DrRacket den Ausdruck wie folgt aus:
%
\begin{enumerate}
\item Die Operanden werden ausgewertet und ergeben die sogenannten
  \textit{Argumente\index{Argument}}.\label{sec:argument}
\item Die Argumente werden für die
  Variablen des \texttt{lambda}-Ausdrucks~-- die sogenannten
  \textit{Parameter\index{Parameter}}~-- im Innenteil des
  \texttt{lambda}-Ausdrucks, dem \textit{Rumpf\index{Rumpf}}
  eingesetzt.
\end{enumerate}
%
\begin{feature}{Abstraktion und Applikation}{scheme:abstraction}
  Eine Abstraktion\index{Abstraktion} hat folgende Form:
\begin{alltt}
(lambda (\(p\sb{1} \ldots p\sb{n}\)) \(e\))
\end{alltt}
  %
  Die $p_i$ sind jeweils Namen, die \textit{Parameter}\index{Parameter}, und
  $e$ ist der \textit{Rumpf}\index{Rumpf}.  In $e$ dürfen die $p_i$
  vorkommen.  Der Wert einer Abstraktion ist eine \textit{Funktion}\index{Funktion},
  welche für jeden Parameter eine Eingabe erwartet.

  Eine \textit{Applikation} einer Funktion hat folgende Form:
  %
\begin{alltt}
(\(p\) \(a\sb{1}\) \ldots \(a\sb{n}\))
\end{alltt}
  %
  $p$ ist ein Ausdruck, der eine Funktion ergeben muß, die $a_i$ sind
  ebenfalls Ausdrücke, die \textit{Argumente}\index{Argument}.  Bei
  der Auswertung einer Applikation werden zunächst $p$ und die $a_i$
  ausgewertet; danach geht es mit der Auswertung des Rumpfes der
  Funktion weiter, wobei für die Parameter $p_i$ jeweils die Werte der
  Argumente $a_i$ eingesetzt werden.
\end{feature}
%
\texttt{Lambda}-Ausdrücke heißen auch
\textit{Abstraktionen\index{Abstraktion}}.
Abbildung~\ref{scheme:abstraction} fasst zusammen, wie Abstraktionen
und Applikationen aufgebaut sind und ausgewertet werden.

Verwirrend ist vielleicht der Unterschied zwischen Abstraktion und
Funktion: Die Abstraktion ist der \texttt{lambda}-Ausdruck im
Programm, die Funktion ist der Wert, der bei der Programmauswertung
dabei herauskommt.  Wir verwenden im Buch aber häufig den Begriff
"<Funktion"> für eine Abstraktion, weil uns interessiert, was bei der
Abstraktion herauskommt.

\begin{aufgabeinline}
  Kannst Du das Ergebnis von \texttt{tile} wieder als Eingabe für
  \texttt{tile} benutzen?  Probier es aus!
\end{aufgabeinline}

\section{Information und Daten}
\label{sec:information-daten}

Eine Definition wie
%
\begin{alltt}
(define mehrwertsteuer 19)
\end{alltt}
%
suggeriert, dass die Zahl 19 an dieser Stelle eine Bedeutung "<in der
realen Welt"> hat, zum Beispiel in einem Programm, das eine Registrierkasse
steuert oder das bei der Steuererklärung hilft.  Die Bedeutung könnte
folgende Aussage sein: "<Der Mehrwertsteuersatz beträgt 19\%.">
Dieser Satz repräsentiert \textit{Information}\index{Information},
also einen Fakt über die Welt oder zumindest den Ausschnitt der Welt, in
dem das Programm arbeiten soll.  In Computerprogrammen wird
Information in eine vereinfachte Form gebracht, mit der das Programm
rechnen kann~-- in diesem Fall die Zahl 19.  Diese vereinfachte Form
heißt \textit{Daten}\index{Daten}: Daten sind
\textit{Repräsentationen}\index{Repräsentation} für Information.

Eine der wichtigsten Aufgaben beim Programmieren ist, die richtige
Form für die Daten zu wählen, um die für das Programm relevanten
Informationen darzustellen und die Informationen dann in Daten zu
übersetzen.

Nicht immer ist offensichtlich, welche Information durch bestimmte
Daten repräsentiert werden.  Die Zahl 23 zum Beispiel könnte eine Reihe
von Informationen darstellen:
%
\begin{itemize}
\item die Anzahl der Haare von Bruce Willis
\item die aktuelle Außentemperatur in °C in Tübingen
\item die Außentemperatur vom 1.7.2000 in °C in Tübingen
\item die Größe in m$^2$ des Schlafzimmers
\item die Rückennummer von Alexandra Popp
\end{itemize}
%
Welche gemeint ist, hängt vom Kontext ab.  Damit andere unsere
Programme lesen können, werden wir also immer wieder klarstellen
müssen, was der Kontext ist und wie Information in Daten zu übersetzen
ist und umgekehrt.  An konkreten Beispielen können (und sollten) wir
dazu einen Kommentar anbringen:
%
\begin{verbatim}
(define bruce-willis 23) ; Anzahl der Haare
(define temperatur-tübingen 23) ; 23°C in Tübingen
(define temperatur-tübingen-2000-07-01 23)
  ; 23°C in Tübingen am 7.1.2000
(define schlafzimmer 23) ; Schlafzimmer ist 23m²
(define alexandra-popp 23) ; Rückennummer
\end{verbatim}

\section{Programme systematisch konstruieren}

In Abschnitt~\ref{sec:abstraktion-und-applikation} haben wir gezeigt,
wie Abstraktion und Applikation bei der Programmauswertung
funktionieren.  Das Verständnis dafür ist wichtig, aber Du musst beim
Schreiben Deines Programms nicht die ganze Zeit daran denken, wie
DrRacket Dein Programm auswertet.  Entsprechend kümmern wir uns in
diesem Buch hauptsächlich darum, wie Du Programme systematisch
konstruierst.
Schauen wir uns das anhand einer kleinen aber realistischen Aufgabe an:

\smallskip

\noindent Betrachte folgende Stromtarife.  Beide Tarife
  bestehen aus einer monatlichen Grundgebühr und einem Teil, der sich
  nach den verbrauchten Kilowattstunden (kWh) richtet.
  %
  \begin{center}
    \begin{tabular}{l|c|c|}
      & Grundgebühr pro Monat & Verbrauchspreis pro kWh \\
      \hline
      Tarif "<Billig-Strom"> & \EUR{4,90} & \EUR{0,19} \\
      \hline
      Tarif "<Watt für wenig"> & \EUR{8,20} & \EUR{0,16} \\
      \hline
    \end{tabular}
  \end{center}

  \begin{enumerate}
  \item Schreibe ein Programm, das den Monatsverbrauch in
    Kilowattstunden akzeptiert und den im Tarif "<Billig-Strom"> zu
    zahlenden monatlichen Rechnungsbetrag berechnet.

  \item Schreibe ein Programm, das den Monatsverbrauch in
    Kilowattstunden akzeptiert und den im Tarif "<Watt für wenig"> zu
    zahlenden monatlichen Rechnungsbetrag
    berechnet.
  \end{enumerate}
  %
Fangen wir mit dem ersten Aufgabenteil an!

\paragraph{Funktion}

Zunächst einmal: Da steht "<Schreibe ein Programm~\ldots">.  In den
Lehrsprachen dieses Buchs heißt das immer "<Schreibe eine
\emph{Funktion}~\ldots">.  Später werden wir Programme schreiben, die
neben der "<Hauptfunktion"> noch "<Hilfsfunktionen"> haben, aber das
Prinzip bleibt immer das gleiche.

Wenn dort steht, "<das den Monatsverbrauch in Kilowattstunden
akzeptiert">, dann bedeutet dies, dass die Funktion den
Monatsverbraucht als Eingabe akzeptieren soll~-- also als Argument.

Ebenso bedeutet "<und den \ldots{} zu zahlenden monatlichen
Rechnungsbetrag berechnet">, dass die Funktion diesen Rechungsbetrag
als Ergebnis liefern soll.

\paragraph{Gerüst}

Funktionen, die ein Problem aus einer Aufgabenstellung lösen, sollten
immer einen Namen haben~-- den sollten wir uns gleich am Anfang
ausdenken.  Der Name \texttt{billig-strom} bietet sich an.  Wir wissen
schon, dass sie den Verbrauch in Kilowattstunden akzeptiert.  Wenn wir
uns noch dafür einen Namen ausdenken, können wir direkt ein unfertiges
Programm hinschreiben, ohne groß nachzudenken:
%
\begin{verbatim}
(define billig-strom
  (lambda (kWh)
    ...))
\end{verbatim}
%
\emph{Wichtig:} Schreibe dieses \textit{Gerüst\index{Gerüst}}
unbedingt hin, auch wenn Du noch keine Vorstellung hast, wie es danach
weitergeht.  Immer.  Jedes Mal.

\paragraph{Rumpf}

Für das Berechnen des Rechnungsbetrags können wir eine Formel
aufschreiben, indem wir auf die Grundgebühr das Produkt aus dem
Verbrauchspreis addieren.  Entsprechend müssen wir den Rumpf\index{Rumpf} der
Funktion ergänzen:
%
\begin{verbatim}
(define billig-strom
  (lambda (kWh)
    (+ 4.90 (* 0.19 kWh))))
\end{verbatim}
%
Die Funktion \texttt{billig-strom} kannst Du jetzt aufrufen:
%
\begin{alltt}
(billig-strom 10)
\evalsto{} 6.8
(billig-strom 20)
\evalsto{} 8.7
(billig-strom 30)
\evalsto{} 10.6
\end{alltt}
%
Die Funktion \texttt{billig-strom} ist ein einigermaßen winziges
Programm.  Wenn Programme größer werden, ist häufig nicht mehr
unmittelbar ersichtlich, was die Programmteile tun oder ob sie
tatsächlich korrekt sind.  Es ist darum sinnvoll, die Funktion mit
einigen Programmelementen zu ergänzen, welche die Verständlichkeit
erhöhen und auch die Wahrscheinlichkeit, dass die Funktion korrekt
ist.  In den nächsten Abschnitten nehmen wir uns diese
Programmelemente einzeln vor.

\section{Kurzbeschreibung}

Als erste Unterstüzung der Lesbarkeit stellen wir einer Funktion eine
kurze Beschreibung auf Deutsch voran, die
sogenannte \textit{Kurzbeschreibung\index{Kurzbeschreibung}}, die
beschreibt, was die Funktion macht.  Eine prägnante Zeile ist dafür
genug.  Das könnte so aussehen:
%
\begin{verbatim}
; monatlichen Rechnungsbetrag für Tarif Billig-Strom berechnen

(define billig-strom ...)
\end{verbatim}
%
\begin{feature}{Kommentare}{scheme:comment}
  Ein Semikolon \texttt{;} kennzeichnet einen 
  \textit{Kommentar\index{Kommentar}}.  Der Kommentar erstreckt sich
  vom Semikolon bis zum Ende der Zeile und wird von DrRacket
  ignoriert.
\end{feature}
%
Das Semikolon am Anfang kennzeichnet die Zeile als
\textit{Kommentar\index{Kommentar}}. DrRacket ignoriert diese Zeile
beim Auswerten, aber für menschliche Leserinnen ist sie nützlich.
Abbildung~\ref{scheme:comment} fasst zusammen, wie das Semikolon
funktioniert.

\section{Signatur}

Die Lesbarkeit des Programms wird außerdem durch die
\textit{Signatur\index{Signatur}} unterstützt, die
beschreibt, welche Art von Daten die Funktion als Argumente erwartet und welche sie liefert.

Die Anzahl der Kilowattstunden auf dem Zählerableseblatt ist in der
Regel eine ganze Zahl, die nicht negativ sein kann.  Die Ausgabe kann
hingegen zwei Nachkommestellen enthalten, ist also ein Bruch.  Um die
Signatur zu schreiben, benutzen wir für diese Beschreibungen dieser
\textit{Sorten\index{Sorte}} mathematische Namen.  Eine ganze,
nicht-negative Zahl heißt auch \textit{natürliche
  Zahl\index{natürliche Zahl}}.  Ein Bruch heißt auch
\textit{rationale Zahl\index{rationale Zahl}}.  Die
Signatur-Deklaration für \texttt{billig-strom} sollte gleich nach der
Kurzbeschreibung kommen und sieht so aus:
%
\begin{verbatim}
(: billig-strom (natural -> rational))
\end{verbatim}
%
Die Elemente \texttt{natural} und \texttt{rational} sind die
Lehrsprachen-Namen für natürliche Zahlen respektive Brüche.

Diese Signatur-Deklaration besteht aus der Form \texttt{(: \ldots)},
dem Namen der Funktion und ihrer Signatur, \texttt{(natural ->
  rational)}.  Wir werden noch einer Vielzahl von Signaturen begegnen,
aber diese hier hat einen Pfeil \texttt{->} in der Mitte und ist
deshalb eine Signatur für eine Funktion: links vom Pfeil steht, was
die Funktion als Eingabe akzeptiert, rechts vom Pfeil die Ausgabe. Die
Signatur-Deklaration ist also so zu lesen: "<\texttt{Billig-strom} ist
eine Funktion, die eine natürliche Zahl als Eingabe akzeptiert und
eine rationale Zahl als Ausgabe produziert.">

\begin{feature}{Signaturen}{scheme:signature}
  Eine \textit{Signatur\index{Signatur}} beschreibt eine Menge oder
  Sorte von Werten.

  \smallskip
  Die Signatur \texttt{string}\index{string@\texttt{string}}
  beschreibt eine Zeichenkette.
  \smallskip
  
  Folgende Signaturen für Zahlen sind eingebaut:
  %
  \begin{flushleft}
    \begin{tabular}{ll}
      \texttt{natural\index{natural@\texttt{natural}}} & natürliche
                                                         Zahlen\index{natürliche
                                                         Zahlen} ($0, 1, 2\ldots$)\\
      \texttt{integer\index{integer@\texttt{integer}}} & ganze
                                                         Zahlen\index{ganze
                                                         Zahlen}($0, 1, -1, 2, -2, \ldots$)\\
      \texttt{rational\index{rational@\texttt{rational}}} &
                                                            Brüche\index{Bruch} / rationale Zahlen\index{rationale Zahlen} \\
      \texttt{real\index{real@\texttt{real}}} & reelle
                                                Zahlen\index{reelle Zahlen}\\
      \texttt{number\index{number@\texttt{number}}} & beliebige Zahlen
    \end{tabular}
  \end{flushleft}
  %
  Diese Liste bildet einen "<Turm">: Jede natürliche Zahl ist auch eine
  ganze Zahl (da kommen noch die negativen Zahlen hinzu), jede ganze
  Zahl ist auch eine rationale Zahl (Brüche mit Nenner ungleich 1
  kommen hinzu), jede rationale Zahl ist eine reelle Zahl
  (nicht-rationale Zahlen wie $\sqrt{2}$ kommen hinzu, und jede reelle
  Zahl ist auch eine Zahl (komplexe Zahlen\index{komplexe Zahlen} kommen hinzu).

\smallskip
  
  Signaturen für Funktionen haben die Form
%
\begin{alltt}
(\(s\sb{1}\) \ldots \(s\sb{n}\) -> \(s\))
\end{alltt}
%
Die Signaturen $s_1 \ldots s_n$ sind die Signaturen für die Argumente
der Funktion und $s$ die Signatur für das Ergebnis.
\end{feature}

\begin{feature}{Signatur-Deklarationen}{scheme:signatur-deklaration}
Eine \textit{Signatur-Deklaration\index{Signatur-Deklaration}} für
eine Funktion hat
folgende Form:
%
\begin{alltt}
(: \(f\) (\(s\sb{1}\) \ldots \(s\sb{n}\) -> \(s\)))
\end{alltt}
%
Sie sagt aus, dass das Verhalten der Funktion der Signatur entspricht:
Wenn die Eingaben der Funktion $f$ den Signaturen \(s\sb{1} \ldots
s\sb{n}\) entspricht, dann entspricht die Ausgabe der Signatur $s$.
\end{feature}
%
Abbildungen~\ref{scheme:signature} und
\ref{scheme:signatur-deklaration} beschreiben das Format von Signaturen
und Signatur-Deklarationen genauer.

\section{Tests}

Wir haben oben in der REPL die Funktion
\texttt{billig-strom} ausprobiert, indem wir DrRacket mehrere Aufrufe
mit unterschiedlichen Eingaben haben auswerten lassen.  Anhand dieser
Beispiele können wir auch (vielleicht mit einem Taschenrechner)
überprüfen, ob die Funktion dabei korrekte Ergebnisse produziert hat.

Diese Beispielaufrufe sind noch hilfreicher für Leserinnen und Leser,
wenn sie im Programm stehen.  Gepaart mit den erwünschten Ergebnissen
erleichtern sie das Verständnis.  Im Programm schreiben wir
das folgendermaßen, gleich nach der Signatur:
%
\begin{alltt}
(check-expect (billig-strom 10) 6.8)
(check-expect (billig-strom 20) 8.7)
(check-expect (billig-strom 30) 10.6)
\end{alltt}
%
Wenn wir jetzt das Programm laufen lassen, steht in der REPL:
%
\begin{verbatim}
Alle 3 Tests bestanden!
\end{verbatim}
%
Das neue Programmelement
\texttt{check-expect\index{check-expect@\texttt{check-expect}}} (siehe
Abbildung~\ref{scheme:test}) macht
nämlich einen sogenannten \textit{Testfall\index{Testfall}} oder \textit{Test\index{Test}}.  In diesem Falle
meldet DrRacket, dass mit den Tests alles geklappt hat.  Aber das
Programm könnte einen Fehler enthalten.  Wenn wir in der Definition
von \texttt{billig-strom} statt \texttt{4.90} "<versehentlich">
\texttt{5.90} schreiben, sieht die Ausgabe anders aus:
%
\begin{feature}{Tests}{scheme:test}
  Ein \textit{Test\index{Test}} hat die folgende Form:
  %
\begin{alltt}
(check-expect \(t\) \(e\))
\end{alltt}
%
Wenn das Programm läuft, wertet DrRacket den Test-Ausdruck $t$ aus und
überprüft, ob er mit dem Wert des Ausdrucks $e$ übereinstimmt.  Wenn
nicht, schlägt der Test fehl und wird von DrRacket protokolliert.
\end{feature}
%
\begin{verbatim}
Check-Fehler:
	Der tatsächliche Wert 7.8 ist nicht der erwartete Wert 6.8.
in stromtarif.rkt, Zeile 5, Spalte 0 
	Der tatsächliche Wert 9.7 ist nicht der erwartete Wert 8.7.
in stromtarif.rkt, Zeile 6, Spalte 0 
	Der tatsächliche Wert 11.6 ist nicht der erwartete Wert 10.6.
in stromtarif.rkt, Zeile 7, Spalte 0 
\end{verbatim}
%
Die Tests weisen uns also auf mögliche Fehler hin.  Das ist so
wertvoll, dass wir in Zukunft \emph{immer} Tests schreiben werden, und
zwar nach der Signatur.  Insbesondere werden wir die Tests schreiben,
\emph{bevor} wir die Definition angehen.  Das nervt manchmal, ist aber
psychologisch sinnvoll, damit wir uns vorher überlegen wie das
richtige Verhalten der Funktion aussehen soll.  Wenn wir die Tests
hinterher schreiben, ist die Versuchtung groß, die Funktion einfach in
der REPL aufzurufen und das tatsächliche Ergebnis in den Test zu
übernehmen, ohne es auf Korrektheit zu überprüfen.

Bei den drei Tests oben müssten wir vielleicht, wenn wir sie vorher
schrieben, einen Taschenrechner bemühen.  Es gibt aber fast immer
mindestens einen möglichen Test, der ganz einfach ist.  In diesem Fall
ist das:
%
\begin{verbatim}
(check-expect (billig-strom 0) 4.9)
\end{verbatim}
%
Hier können wir das Ergebnis direkt der Tabelle entnehmen.  Dieser
überprüft zwar nicht, ob der richtige pro-kWh-Preis berechnet wird,
ist aber so einfach zu schreiben, dass wir die Gelegenheit nicht
auslassen sollten, ihn zu schreiben.

Wieviele Tests sollte man schreiben?  Das hängt von der Komplexität
der Funktion ab.  Aber drei sollten es bei einfachen Funktionen
mindestens sein, bei komplizierteren mehr.  Ein einfaches weiteres
Kriterium ist, dass jeder Teil des Programms, das wir geschrieben
haben, im Laufe der Tests einmal ausgewertet werden sollte.  DrRacket
kann Dir dabei helfen.

\label{page:abdeckung0}
Wenn Du das Programm nur auf die Funktionsdefinition reduzierst (also
alle Tests und Beispiel\-aufrufe entfernst) und dann laufen lässt,
sollte Dir auffallen, dass der Rumpf von \texttt{billig-strom} blau
hinterlegt ist.  (Außerdem Teile der Signatur von
\texttt{billig-strom}.)  Diese Hinterlegung zeigt die sogenannte
\textit{Abdeckung\index{Abdeckung}} an: Die blau hinterlegten
Programmteile sind noch nie gelaufen und wurden ergo auch noch nicht
getestet.  Es fehlen also noch Tests.  In Zukunft achten wir also
darauf, dass, nachdem das Programm gelaufen ist, nichts blaues
übrigbleibt~-- andernfalls müssen wir mehr Tests schreiben.  Wir
kommen in Abschnitt~\ref{sec:testabdeckung} auf dieses Thema zurück.

Bei Programmen, die Bilder erzeugen, ist es in der Regel nicht
möglich, die Testfälle vorher zu schreiben.  Du kannst aber Beispiele
ausprobieren, die Du Dir vorher überlegt hast, und diese visuell überprüfen.
Wenn Dir ein Ergebnis richtig erscheint, kannst Du das Bild aus der
REPL kopieren in das Programm kopieren.  In der REPL könnte das so aussehen:
%
\begin{alltt}
(square 40 "solid" "red")
\evalsto{} \includegraphics[height=24pt]{i1prog/square}
\end{alltt}
%
Du kannst dann das Quadrat aus der REPL kopieren, also zum Beispiel
mit der Maus markieren und dann mit \texttt{Ctrl-C} beziehungsweise
\texttt{Command-C} kopieren und dann ins Programm mit \texttt{Ctrl-V}
beziehungsweise \texttt{Command-V} einfügen und dann daraus folgenden
Test machen:
%
\begin{alltt}
(check-expect (square 40 "solid" "red") \includegraphics[height=24pt]{i1prog/square})
\end{alltt}

\begin{aufgabeinline}
  Schreibe für \texttt{tile} zwei Tests!
\end{aufgabeinline}
%
Übrigens ist eine Signatur-Deklaration auch so eine Art Testfall.
Das sehen wir, wenn wir absichtlich einen Fehler wie diesen hier
machen:
%
\begin{verbatim}
(check-expect (billig-strom "30") 13.0)
\end{verbatim}
%
Probier es aus!  Es erscheint zusammen mit den Meldungen über die
Tests eine Meldung über eine
\textit{Signaturverletzung}\index{Signaturverletzung} wie folgt:
%
\begin{alltt}
Signaturverletzungen:
	bekam "30" in stromtarif.rkt \ldots, Signatur in stromtarif.rkt \ldots
\end{alltt}
%
In der Meldung stehen klickbare Links, die Dir zeigen, wo die
Signaturverletzung passiert ist und welche Signatur verletzt wurde.

Wenn Signaturverletzungen erscheinen, solltest Du diese genau lesen,
weil sie auf ein Problem in Deinem Programm hinweisen und wertvolle
Hinweise zu dessen Lösung geben.

\section{Konstruktionsanleitungen}
\label{sec:konstruktionsanleitungen}
%
Wir haben im vorigen Abschnitt folgende Arbeitsschritte kennengelernt,
die zu einer Funktion führen:
%
\begin{itemize}
\item Gerüst
\item Kurzbeschreibung
\item Signatur-Deklaration
\item Tests
\item Rumpf
\end{itemize}
%
Diese Reihenfolge ist der Reihenfolge ihrer Einführung in diesem
Kapitel geschuldet.  Zukünftig ist es sinnvoll, dass wir diese Schritte
immer in der gleichen und zwar in folgender Reihenfolge durchführen:
%
\begin{itemize}
\item Kurzbeschreibung
\item Signatur
\item Tests
\item Gerüst
\item Rumpf
\end{itemize}
%
Dies entspricht auch der Reihenfolge, in der die entsprechenden
Elemente im Programm stehen: Wenn Du diese Reihenfolge befolgst,
kannst Du Dein Programm einfach "<herunterschreiben">.

Eine solche Anleitung zur Konstruktion von Programmen nennen wir in
diesem Buch
\textit{Konstruktionsanleitung\index{Konstruktionsanleitung}}.  Da
noch viele weitere Konstruktionsanleitungen hinzukommen werden,
bekommen sie Nummern.  Die erste Konstruktionsanleitung legt den
Ablauf fest und bekommt darum die besondere Nummer 0.
Wir fügen gleich noch zwei weitere Elemente
hinzu~-- Datenanalyse und Schablonen~-- die wir in späteren Kapiteln
erläutern werden.

% set counter to zero
\setcounter{xkonstruktionsanleitung}{-1}

\begin{konstruktionsanleitung}{Ablauf}
  Gehe bei der Konstruktion einer Funktion in folgender Reihenfolge
  vor:
  \begin{enumerate}
    \item Kurzbeschreibung
    \item Datenanalyse
    \item Signatur-Deklaration
    \item Tests
    \item Gerüst
    \item Schablonen
    \item Rumpf
    \end{enumerate}
\end{konstruktionsanleitung}
%
Für jeden dieser Schritte gibt es jeweils eine Konstruktionsanleitung,
für manche mehrere je nach Situation.  Es mag Dir übermäßig
bürokratisch vorkommen, immer die gleiche Reihenfolge einzuhalten und
immer nach der jeweiligen Konstruktionsanleitung vorzugehen.
Bürokratisch ist das in jedem Fall, ist aber eine wertvolle
Hilfestellung, die verhindert, dass Du in unnötige Sackgassen
gerätst.  Wenn Du irgendwann beim Lösen einer Aufgabe in
eine Sackgasse gerätst, solltest Du als erstes überprüfen, ob Du auch
nach den Konstruktionsanleitungen vorgegangen bist.  Oft ist die
Ursache des Problems, dass einer der Schritte fehlt.

Zunächst einmal führen wir Konstruktionsanleitungen für die Schritte
des Ablaufs ein, die wir schon eingeführt haben:

\begin{konstruktionsanleitung}{Kurzbeschreibung}
  \index{Kurzbeschreibung}
  \label{ka:kurzbeschreibung}
  Schreibe für die Funktion zunächst einen Kommentar, der ihren Zweck
  kurz beschreibt.  Ein Satz, der auf eine Zeile passen sollte,
  reicht.  Beispiel:
  %
\begin{verbatim}
; monatlichen Rechnungsbetrag für Tarif Billig-Strom berechnen
\end{verbatim}
\end{konstruktionsanleitung}

\begin{konstruktionsanleitung}{Signatur-Deklaration}
  \index{Signatur-Deklaration}
  \label{ka:signatur-deklaration}
  Schreibe für die Funktion direkt unter die Kurzbeschreibung eine
  Signatur-Deklaration.  Dazu denke Dir zunächst einen möglichst
  aussagekräftigen Namen aus.  Überlege dann, welche Sorten die Ein-
  und Ausgaben haben und schreibe dann eine Signatur, welche die Ein-
  und Ausgaben der Funktion möglichst präzise beschreiben.  Beispiel:
  %
  \begin{verbatim}
(: billig-strom (natural -> rational))
\end{verbatim}
  %
  Achte bei den Zahlen-Signaturen besonders auf eine möglichst präzise
  Signatur.  Bei \texttt{billig"=strom} wäre auch die Signatur
  \texttt{(number -> number)} korrekt, aber nicht so genau.
\end{konstruktionsanleitung}

\begin{konstruktionsanleitung}{Tests}
  \index{Tests}
  \label{ka:tests}
  Schreibe unter die Signatur Tests für die Funktion.  Denke Dir dafür
  möglichst möglichst einfache, aber auch möglichst interessante
  Beispiele für Aufrufe der Funktion auf und lege fest, was dabei
  herauskommen soll.  Mache aus den Beispielen Tests mit
  \texttt{check-expect}.  Beispiel:
\begin{alltt}
(check-expect (billig-strom 0) 4.9)
(check-expect (billig-strom 10) 6.8)
(check-expect (billig-strom 20) 8.7)
(check-expect (billig-strom 30) 10.6)
\end{alltt}
  Achte darauf, dass die Tests dafür sorgen, dass der Code Deiner
  Funktion durch die Tests vollständig abgedeckt wird.
\end{konstruktionsanleitung}
%
Der letzte Satz der Konstruktionsanleitung ergibt, was das Beispiel
\texttt{billig-strom} betrifft, keinen Sinn, da jeder einzelne der
Tests bereits dafür
sorgt, dass die Addition und die Multiplikation in
\texttt{billig-strom} ausgewertet werden.  In
Abschnitt~\ref{sec:testabdeckung} werden wir aber Beispiele
programmieren, bei denen es nicht selbstverständlich ist, dass die
Tests alles auswerten.

\begin{konstruktionsanleitung}{Gerüst}
  \index{Gerüst}
  \label{ka:geruest}
  Schreibe unter die Tests ein Gerüst für die Funktion: Dazu
  übernimmst Du den Namen aus der Signatur-Deklaration in eine
  Funktionsdefinition wie zum Beispiel:
  %
\begin{verbatim}
(define billig-strom
  (lambda (...)
    ...))
\end{verbatim}
  %
  Denke Dir Namen für die Eingaben der Funktion aus.  Das müssen
  genauso viele sein, wie die Signatur Eingaben hat.  Schreibe dann
  diese Namen als Eingaben in die \texttt{lambda}-Abstraktion.
  Beispiel:
  \begin{verbatim}
(define billig-strom
  (lambda (kWh)
    ...))
\end{verbatim}
\end{konstruktionsanleitung}

\begin{konstruktionsanleitung}{Rumpf}
  \index{Rumpf}
  \label{ka:rumpf}
  Als letzten Schritt fülle mit Hilfe des Wissens über das Problem
  den Rumpf der Funktion aus.
\begin{alltt}
(define billig-strom
  (lambda (kWh)
    \textbf{(+ 4.90 (* 0.19 kWh))}))
\end{alltt}
\end{konstruktionsanleitung}

Diesen Ablauf demonstrieren wir anhand des zweiten Teils der
Stromtarif-Aufgabe.
Zur Erinnerung:  Es ging um den Tarif
"<Watt für Wenig"> mit einem Grundbetrag von \EUR{8,20} und einem
Verbrauchspreis pro kWh von \EUR{0,16}.

\paragraph{Kurzbeschreibung}

Fangen wir mit der Kurzbeschreibung an.  Die können wir entsprechend
zu "<Billig-Strom"> formulieren:
\begin{verbatim}
; monatlichen Rechnungsbetrag für Tarif Watt für wenig berechnen
\end{verbatim}

\paragraph{Signatur}

Auch die Signatur-Deklaration können wir analog zu "<Billig-Strom">
formulieren~-- wir müssen uns nur einen neuen Namen aussuchen:
%
\begin{verbatim}
(: watt-für-wenig (natural -> rational))
\end{verbatim}

\paragraph{Tests}

Die Tests müssen wir neu formulieren.  Es ist immer sinnvoll, mit dem
einfachsten Beispiel anzufangen:
\begin{verbatim}
(check-expect (watt-für-wenig 0) 8.2)
\end{verbatim}

Ansonsten nehmen wir wieder progressiv größere Verbrauchswerte und
rechnen den Rechnungsbetrag im Kopf aus:
%
\begin{verbatim}
(check-expect (watt-für-wenig 10) 9.8)
(check-expect (watt-für-wenig 20) 11.4)
(check-expect (watt-für-wenig 30) 13.0)
\end{verbatim}

\paragraph{Gerüst}

Das Gerüst ergibt sich direkt aus der Signatur:
%
\begin{verbatim}
(define watt-für-wenig
  (lambda (kWh)
    ...))
\end{verbatim}

\paragraph{Rumpf}

Schließlich müssen wir noch den Rumpf vervollständigen, indem wir die
entsprechende Formel hineinschreiben:
%
\begin{verbatim}
(define watt-für-wenig
  (lambda (kWh)
    (+ 8.20 (* 0.16 kWh))))
\end{verbatim}
%
Fertig!

\section{Die Macht der Abstraktion}
\label{sec:abstraktion}

Wir haben bei den Stromtarifen für die beiden
Aufgabenteile völlig voneinander unabhängige Lösungen geschrieben.
Diese unterscheiden sich allerdings nur in Details~-- in beiden Fällen
wird der Stromtarif aus einer Grundgebühr und einem Verbrauchspreis
pro kWh mit der gleichen Formel berechnet.  Die Definitionen ähneln
sich dementsprechend:
%
\begin{verbatim}
(define billig-strom
  (lambda (kWh)
    (+ 4.90 (* 0.19 kWh))))

(define watt-für-wenig
  (lambda (kWh)
    (+ 8.20 (* 0.16 kWh))))
\end{verbatim}
%
Diese "<Verdoppelung"> ist unbefriedigend und kann auch später
Probleme machen: Wenn ein Fehler bekannt wird, müssen möglicherweise
zwei Funktionen korrigiert werden.

Es wäre also gut, wenn wir die Gemeinsamkeiten der beiden Funktionen
irgendwie zusammenfassen könnten, mithin über \texttt{billig-strom}
und \texttt{watt-für-wenig} \textit{abstrahieren\index{Abstraktion}}
könnten.  Dazu kopieren wir die Funktion ein letztes Mal und benennen
sie um.  Außerdem ersetzen wir alle Stellen, bei denen sich die beiden
Funktionen unterscheiden, jeweils durch eine Variable, zum Beispiel
\texttt{grundgebuehr} und \texttt{pro-kWh}:
%
\begin{verbatim}
(define stromtarif-rechnungsbetrag
  (lambda (kWh)
    (+ grundgebuehr (* pro-kWh kWh))))
\end{verbatim}
%
Die beiden neuen Variablen sind noch nicht gebunden, wir müssen sie zu
den Parametern des \texttt{lambda} hinzufügen:
%
\begin{verbatim}
(define stromtarif-rechnungsbetrag
  (lambda (grundgebuehr pro-kWh kWh)
    (+ grundgebuehr (* pro-kWh kWh))))
\end{verbatim}
%
Wir ergänzen noch Kurzbeschreibung und Signatur.  Die neuen Parameter
sind auch beides rationale Zahlen, das sieht also so aus:
%
\begin{verbatim}
; monatlichen Rechnungsbetrag für Stromtarif berechnen
(: stromtarif-rechnungsbetrag (rational rational rational -> rational))
\end{verbatim}
%
Außerdem sollten wir Tests formulieren.  Diese können wir aus den
Tests für \texttt{billig-strom} und \texttt{watt-für-wenig} gewinnen.
Wir müssen nur jeweils zu den Argumenten noch die Grundgebühr
beziehungsweise den Preis pro kWh hinzufügen:
%
\begin{verbatim}
(check-expect (stromtarif-rechnungsbetrag 4.90 0.19 10) 6.8)  ; Billig-Strom
(check-expect (stromtarif-rechnungsbetrag 4.90 0.19 20) 8.7)  ; Billig-Strom
(check-expect (stromtarif-rechnungsbetrag 4.90 0.19 30) 10.6) ; Billig-Strom
(check-expect (stromtarif-rechnungsbetrag 4.90 0.19 0) 4.9)   ; Billig-Strom

(check-expect (stromtarif-rechnungsbetrag 8.20 0.16 0) 8.2)   ; Watt für wenig

(check-expect (stromtarif-rechnungsbetrag 8.20 0.16 10) 9.8)  ; Watt für wenig
(check-expect (stromtarif-rechnungsbetrag 8.20 0.16 20) 11.4) ; Watt für wenig
(check-expect (stromtarif-rechnungsbetrag 8.20 0.16 30) 13.0) ; Watt für wenig
\end{verbatim}
%
Schließlich können wir auch die Definitionen von \texttt{billig-strom}
und \texttt{watt-für-wenig} so ändern, dass sie nicht mehr "<selbst">
den Rechnungsbetrag ausrechnen, sondern dafür
\texttt{stromtarif"=rechnungsbetrag} benutzen:
%
\begin{verbatim}
(define billig-strom
  (lambda (kWh)
    (stromtarif-rechnungsbetrag 4.90 0.19 kWh)))

(define watt-für-wenig
  (lambda (kWh)
    (stromtarif-rechnungsbetrag 8.20 0.16 kWh)))
\end{verbatim}
%
Zu dieser Technik werden wir in diesem Buch noch oft greifen.  Sie
erspart nicht nur oft Arbeit und macht unsere Programme leichter zu
handhaben, sondern führt manchmal zu ganz neuen Erkenntnissen~--
zu sehen zum Beispiel in Kapitel~\ref{cha:higher-order}.

\section{Mantras für die Programmierung}

\index{Mantra}
Nach den einfachen Programmen bisher werden wir in den
folgenden Kapiteln immer interessante Funktionen schreiben und dabei
weitere Konstruktionsanleitungen für spezifische Situationen
einführen.

Es gibt aber einige übergreifende Prinzipien des Programmierens, die
wir immer wieder aufgreifen werden.  Nicht alle sind jetzt schon
relevant, aber wir listen sie hier einmal auf, damit sie an einer
Stelle gesammelt sind und wir darauf in den folgenden Kapiteln bezug
nehmen können.

Das erste Mantra soll einem Phänomen entgegenwirken, dass wir oft bei
unseren Studierenden beobachtet haben, die manchmal bei einer Aufgabe
aufgeben, bevor sie alles hingeschrieben haben, was sie wissen.
%
\begin{restatable}{mantra}{mantraschreib}
  \label{mantra:schreib}
  Achte darauf, dass für alles, was Du weißt, tatsächlich auch etwas
  im Programm steht.
\end{restatable}
% 
\noindent Das nächste Mantra klingt eigentlich wie Kinderkram:
%
\begin{restatable}{mantra}{mantralies}
  \label{mantra:lies}
  Lies, was dort steht.
\end{restatable}
% 
\noindent Das genaue Lesen fällt uns aber erstaunlich schwer.  Für dieses Buch
sind zwei Aspekte des Lesens besonders wichtig.  Am wichtigsten ist
das Lesen der jeweiligen Aufgabenstellung, und zwar Schritt für
Schritt~-- gerade so, dass wir genug für den jeweils nächsten Schritt
verstehen~-- anstatt alles auf einmal. Außerdem gibt DrRacket (oder
andere Programmierumgebungen) oft nützliche Rückmeldungen, die es sch
zu lesen lohnt, auch wenn das manchmal mühsam ist.

Die Konstruktionsanleitungen geben Hilfestellung dafür, \emph{wie} Du
die Aufgabenstellung strukturiert lesen und in Deinem Programm
schreiben kannst, was Du weißt.  Daraus folgt das nächste Mantra:
%
\begin{restatable}{mantra}{mantraka}
  \label{mantra:ka}
  Gehe nach den Konstruktionsanleitungen vor.  Wenn Du Dich in einer
  Sackgasse wiederfindest, überprüfe, ob Du alle relevanten
  Konstruktionsanleitungen angewendet hast.
\end{restatable}
%
\noindent Die Konstruktionsanleitungen helfen uns, Fortschritte zu machen, auch
wenn wir noch nicht alles verstehen~-- zu lesen, was dort steht und
aufzuschreiben, was wir wissen.

Das folgende Mantra haben wir schon in Abschnitt~\ref{sec:abstraktion}
auf Seite~\pageref{sec:abstraktion} kennengelernt:
%
\begin{restatable}{mantra}{mantraabstraktion}
  \label{mantra:abstraktion}
  Wenn Du zwei Programmteile siehst, die sich nur an wenigen Stellen
  unterscheiden und die inhaltlich verwandt sind, abstrahiere!
\end{restatable}
%
\noindent Bisher haben wir nur kleine Programme mit ein, zwei oder drei
Funktionen geschrieben: Größere Programme bestehen aus vielen
Funktionen, und dieses Mantra benennt das Prinzip, nachdem wir es in
Funktionen aufteilen:
%
\begin{restatable}{mantra}{mantraseparatefunktionen}
  \label{mantra:separate-funktionen}
  Wenn in Deinem Programm verschiedene Größen berechnet werden,
  schreibe für die Berechnung jeder Größe eine separate Funktion.
\end{restatable}
%
\noindent Wir werden oft mathematische Einsichten in Form von Gleichungen
benutzen, um unsere Programme zu verbessern:
%
\begin{restatable}{mantra}{mantragleichungen}
  \label{mantra:gleichungen}
  Nutze Gleichungen aus, um Dein Programm zu vereinfachen.
\end{restatable}
%
\noindent Manchmal macht es Spaß, ein kompliziertes Programm zusammenzubasteln
wie ein Puzzle.  Leider führt dies oft zu unerwünschter Komplexität:
Komplexe Programme sind fehleranfällig, schwierig zu verstehen und
schwierig weiterzuentwickeln.  Wir sollten uns dafür hüten:
%
\begin{restatable}{mantra}{mantrakomplexitaet}
  \label{mantra:komplexitaet}
  Wenn Deine Funktion Dir kompliziert scheint, ist es wahrscheinlich,
  dass sie Fehler enthält: Entweder, weil sie eigentlich einfacher
  sein sollte, oder weil die Aufgabe kompliziert und damit ihre Lösung
  fehleranfällig ist.
\end{restatable}
%
Das nächste Mantra beschreibt, wie Du besonders gute Repräsentationen
entwickeln kannst.  Worum es genau geht, steht in
Kapitel~\ref{cha:selbstbezug} auf Seite~\pageref{cha:selbstbezug}.
%
\begin{restatable}{mantra}{mantrakombinator}
  \label{mantra:kombinator}
  Suche nach Kombinatoren\index{Kombinator} für Deine Daten, die aus
  kleinen Dingen größere Dinge machen~-- und daraus wieder größere
  Dinge machen.
\end{restatable}

\section*{Aufgaben}

\begin{aufgabe}
 Vervielfachung von Strings:
 \begin{itemize}
  \item Schreibe eine Funktion \texttt{double-string}, die eine Zeichenkette akzeptiert und
    diese "<verdoppelt">, das heißt, für eine Eingabe \verb|"Sperber"| den
    Rückgabewert \verb|"SperberSperber"| liefert.
    
  \item Schreibe eine Funktion \texttt{quadruple-string}, die eine
    Zeichenkette akzeptiert und "<vervierfacht">.

  \item Schreibe eine Funktion \texttt{octuple-string}, die eine
    Zeichenkette akzeptiert und "<verachtfacht">.

  \item Schreibe eine Funktion \texttt{sixteentuple-string}, die
    eine Zeichenkette akzeptiert und "<versechzehnfacht">.
  \end{itemize}
  % Schreibe für jede Funktion Kurzbeschreibung, Signatur, Testfälle, Gerüst und Rumpf.

%Vermeide bei all diesen Aufgaben, Code mehrfach zu schreiben.

\end{aufgabe}

\begin{aufgabe}

 Ein Boot überquert einen Fluss mit Strömung und
  kommt durch die Strömung vom geplanten Kurs ab.  Dadurch wird die
  Strecke, die das Boot tatsächlich zurücklegt, länger.

  \begin{center}
    \includegraphics{riverboat}
  \end{center}

  Gegeben ist die Breite des Flusses $a$, die Strömungsgeschwindigkeit
  des Flusses $v_{\text{Fluss}}$ und die Geschwindigkeit des Bootes
  $v_{\text{Boot}}$.  Berechne die Länge der Strecke, die das
  Boot tatsächlich zurücklegt.  Programmiere dazu Funktionen, die
  folgende Teilprobleme lösen:

  \begin{enumerate}
  \item Schreibe eine Funktion \lstinline{crossing-time}, welche die
    Zeit berechnet, die für das Überqueren des Flusses benötigt wird:
    %
    \[t = \frac{a}{v_{\text{Boot}}}\]
  \item Schreibe dann eine Funktion \texttt{other-shore-offset},
    die die Länge der Strecke berechnet, die das Boot abgetrieben wird
    (also den Versatz am anderen Ufer, im Schaubild die Strecke $b$).
    % Dazu musst Du die Breite des Flusses $a$ mit dem Verhältnis von
    % $v_{\text{Fluss}}$ zu $v_{\text{Boot}}$ multiplizieren.

  \item Um $c$ zu berechnen, brauchst Du den \textit{Satz des
      Pythagoras}:
    \begin{displaymath}
      a^2 + b^2 = c^2
    \end{displaymath}
    Schreibe eine Funktion \texttt{pythagoras}, die $c$ der
    obigen Gleichung berechnet.  Erkenne und abstrahiere weitere
    Teilprobleme!

  \item Schreibe schließlich eine Funktion
    \texttt{boat-travel-distance}, die die tatsächliche Strecke
    berechnet, die das Boot zurücklegt.  Benutze dafür die bisher
    geschriebenen Funktionen.
  \end{enumerate}
\end{aufgabe}

\begin{aufgabe}

  In den USA und in Europa gibt es unterschiedliche
  Maße für die Energieeffizienz von Kraftfahrzeugen:
  \begin{itemize}
  \item In Europa ist das gängige Maß der \emph{Verbrauch} in Liter
    pro 100 km (l/100km);
  \item in den USA ist das gängige Maß die \emph{Reichweite} in Meilen
    pro Gallone (mi/gal).
  \end{itemize}
  Schreibe Funktionen, die zwischen beiden Maßeinheiten
  umrechnen.  Gehe dazu wie folgt vor:

  Halte Dich bei jeder Funktion, die Du schreibst, an den
  Ablauf: Schreibe zuerst die Kurzbeschreibung
  und die Signatur.  Schreibe als Nächstes einige Testfälle.
  Leite danach das Gerüst von der Signatur her und vervollständige
  den Rumpf der Funktion.

  \begin{enumerate}

  \item Schreibe eine Funktion
    \texttt{liters-per-hundred-kilometers}, die eine Menge Benzin in
    Liter und die Reichweite dieses Benzins in Kilometer akzeptiert
    und daraus den Verbrauch in Liter pro 100 km berechnet.

  \item Schreibe eine Funktion
    \texttt{miles-per-gallon}, die eine Entfernung in Meilen und den
    Benzinverbrauch auf diese Entfernung in Gallonen akzeptiert und
    daraus die Reichweite in Meilen pro Gallone berechnet.

  \item Definiere eine Konstante
    \texttt{kilometers-per-mile} (eine US-Meile entspricht etwa $1,61$
    Kilometer) und schreibe zwei Funktionen
    \texttt{kilometers->miles} und \texttt{miles->kilometers}, die
    jeweils eine Entfernung in einer Maßeinheit akzeptieren und die
    Entfernung in die jeweils andere Maßeinheit umrechnen.

  \item Definiere eine Konstante
    \texttt{liters-per-gallon} (eine Gallone entspricht etwa $3,79$
    Liter) und schreibe zwei Funktionen \texttt{liters->gallons}
    und \texttt{gallons->liters}, die jeweils eine Menge in einer
    Maßeinheit akzeptieren und die Menge in die jeweils andere
    Maßeinheit umrechnen.

  \item Schreibe die Funktion
    \texttt{l/100km->mi/gal}, die einen Verbrauch in Liter pro 100 km
    akzeptiert und in die Reichweite in Meilen pro Gallone umrechnet.
    Benutze dafür die Funktionen, die Du in den anderen
    Teilaufgaben erstellt hast.  Solltest Du auf weitere Teilprobleme
    stoßen, abstrahiere diese Teilprobleme in eigene Funktionen.

  \item Schreibe die Funktion
    \texttt{mi/gal->l/100km}, die eine Reichweite in Meilen pro
    Gallone akzeptiert und in den Verbrauch in Liter pro 100 km
    umrechnet.  Benutze dafür die Funktionen, die Du in den
    anderen Teilaufgaben erstellt hast.  Solltest Du auf weitere
    Teilprobleme stoßen, abstrahiere diese Teilprobleme in eigene
    Funktionen.

  \item Finde heraus, wie hoch der Benzinverbrauch
    verschiedener Kraftfahrzeuge ist, die Du täglich im
    Straßenverkehr in Deutschland siehst.  Vergleiche diesen
    Verbrauch mit den Reichweitenangaben typischer Kraftfahrzeuge für
    den US-amerikanischen Markt.
  \end{enumerate}

\end{aufgabe}

% In vielen Ländern sind die Benzinpreise ein Grund zur allgemeinen
% Aufregung. In Deutschland wird immer die magische Marke von 1,50
% Euro pro Liter genannt, die USA haben große Angst vor der 4 Dollar
% pro Gallone. Auch sind Spritsparende Autos immer beliebter, in
% Deutschland wird auf das 3 Liter auf 100km Auto gehofft, die USA
% wünschen sich mehr 55 Meilen pro Gallone Autos.  Diese verschiedenen
% Maßstäbe sind verwirrend.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "i1"
%%% End: 
