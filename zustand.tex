\chapter{Zuweisungen und Zustand}

\section{Der $\lambda$-Kalkül mit Zustand}

Der bisher vorgestellte $\lambda$-Kalkül liefert keinerlei Erklärung
für das Verhalten von Zuweisungen.  Tatsächlich hat sich schon in
Abschnitt~\ref{sec:assignment-problems} angedeutet, dass Zuweisungen
die Formalisierung deutlich erschweren.  Möglich ist es trotzdem, und
dieser Abschnitt zeigt, wie es geht.

Als erstes muss wieder einmal die Sprache des $\lambda$-Kalküls
erweitert werden, diesmal um \texttt{set!}-Ausdrücke:
%
\begin{definition}[Sprache des angewandten $\lambda$-Kalküls mit Zustand
  $\mathcal{L}_{\lambda{}S}$]\index{angewandter $\lambda$-Kalkül}\index{Zustand}
  Sei $V$ eine abzählbare Menge von Variablen.  Sei $B$ eine Menge von
  \textit{Basiswerten\index{Basiswert}} mit $\mathtt{void} \in B$.
  Sei für eine natürliche Zahl $n$ und $i \in \{1, \ldots, n\}$
  jeweils $\Sigma^i$ eine Menge von \textit{$i$-stelligen
    Primitiva\index{Primitivum}}.  Jedem $F^i\in\Sigma^i$ ist eine
  $i$-stellige Funktion $F_B^i: B\times\ldots\times B \rightarrow
  B$~-- ihre \textit{Operation}~-- zugordnet.
  Seit $A$ eine abzählbare Menge von Adressen mit $V\cap A =
  \varnothing$.\index{Adresse}. 

  Die Sprache des angewandten $\lambda$"=Kalküls mit Zustand, die
  Menge der \textit{angewandten $\lambda$-Terme mit Zustand},
  $\mathcal{L}_{\lambda{}S}$\index{L@$\mathcal{L}_{\lambda{}S}$}, ist
  durch folgende Grammatik definiert:
  \begin{grammar}
    \meta{$\mathcal{L}_{\lambda{}S}$} \: \meta{$V$}
    \> \| (\meta{$\mathcal{L}_{\lambda{}S}$} \meta{$\mathcal{L}_{\lambda{}S}$})
    \> \| ($\lambda$\meta{$V$}.\meta{$\mathcal{L}_{\lambda{}S}$})
    \> \| \meta{$B$}
    \> \| (\meta{$\Sigma^1$}~\meta{$\mathcal{L}_{\lambda{}S}$})
    \> \| (\meta{$\Sigma^2$}~\meta{$\mathcal{L}_{\lambda{}S}$}~\meta{$\mathcal{L}_{\lambda{}S}$})
    \> \ldots
    \> \| (\meta{$\Sigma^n$}~\meta{$\mathcal{L}_{\lambda{}S}$}~\ldots~\meta{$\mathcal{L}_{\lambda{}S}$})  \quad \textrm{($n$-mal)}
    \> \| (set! \meta{V} \meta{$\mathcal{L}_{\lambda{}S}$})
  \end{grammar}
  %
\end{definition}
%
Der \texttt{void}-Wert wird als Rückgabewert von
\texttt{set!}-Ausdrücken dienen.

Um Reduktionsregeln für Zuweisungen zu bilden, ist es notwendig, den
Begriff des \textit{Speichers\index{Speicher}} in den $\lambda$-Kalkül
einzuführen: Im $\lambda$-Kalkül mit Zustand stehen Variablen nicht
mehr für Werte, die für sie eingesetzt werden können, sondern für
\textit{Speicherzellen\index{Speicherzelle}}.  Eine Speicherzelle ist
ein Ort im Speicher, der einen Wert aufnimmt, der auch wieder
verändert werden kann.  Dabei wird jede Speicherzelle durch eine
\textit{Adresse\index{Adresse}} identifiziert.  Eine Adresse ist eine
abstrakte Größe, es kommt also gar nicht darauf an, um was für
eine Art Wert es sich handelt~-- im realen Computer ist eine Adresse
in der Regel einfach eine Zahl.  In diesem Abschnitt steht $A$ für die
Menge der Adressen, die abzählbar sein sollte.

Ein Speicher aus der Menge $M$ ist eine Zuordnung zwischen Adressen aus $A$
und Werten\index{Wert}.  Die Werte sind wie schon im normalen
$\lambda$-Kalkül die Basiswerte und die Abstraktionen~-- hier bekommen
sie, weil sie eine Rolle in den Reduktionsregeln spielen, den Namen
$X$:
%
\begin{eqnarray*}
  M &=& \mathcal{P}(A\times X)\\
  X &=& B \cup \{ \lambda v.e | \lambda v.e \in \mathcal{L}_{\lambda{}S} \}
\end{eqnarray*}

Um Reduktionsregeln für den $\lambda$-Kalkül mit Zustand zu
formulieren, muss $\mathcal{L}_{\lambda{}S}$ noch erweitert werden,
damit die Adressen ins Spiel kommen: Adressen werden Terme und sind
auf der linken Seite von Zuweisungen zulässig:
%
\begin{grammar}
  \meta{$\mathcal{L}_{\lambda{}S}$} \: \ldots
  \> \| \meta{A}
  \> \| (set! \meta{A} \meta{$\mathcal{L}_{\lambda{}S}$})
\end{grammar}
%
Adressen tauchen dabei nur als Zwischenschritte bei der Reduktion auf;
sie sind nicht dafür gedacht, dass sie der Programmierer in ein
Programm schreibt.

Da das bisherige Substitutionsprinzip bei Zuweisungen nicht mehr funktioniert, reicht es
nicht, die Reduktionsregeln für den $\lambda$-Kalkül mit Zustand
einfach nur auf Termen auszudrücken: Ein Term, der ja Adressen
enthalten kann, ergibt nur Sinn, wenn er mit einem Speicher kombiniert
wird.  Die Reduktionsregeln überführen somit immer ein Paar, bestehend aus
einem Term und einem Speicher in ein ebensolches Paar.  Hierbei wird der
Einfachheit halber kein Unterschied mehr zwischen den verschiedenen
Arten der Reduktion gemacht:
%
\begin{eqnarray*}
  b, m &\rightarrow& a, m[a\mapsto b] \textrm{ wobei $a$ frisch}
  \\
  \lambda v.e, m &\rightarrow&
  a, m[a\mapsto \lambda v.e]  \textrm{ wobei $a$ frisch}
  \\
  (a_0~a_1), m &\rightarrow& e[v\mapsto a], m[a\mapsto m(a_1)]
  \textrm{ wobei $m(a_0) = \lambda v.e$ und $a$ frisch} 
  \\
  (\mathtt{set!}~a_0~a_1), m &\rightarrow& \mathtt{void}, m[a_0\mapsto m(a_1)]
  \\
  (F^k a_1 \ldots a_k), m &\rightarrow& a, m[a\mapsto F_B(b_1, \ldots, b_k)] \textrm{
    wobei $b_i = m(a_i) \in B$, $a$ frisch}
\end{eqnarray*}
%
Die Formulierung "<$a$ frisch"> bedeutet dabei, dass $a$ eine Adresse
sein sollte, die in $m$ bisher noch nicht benutzt wurde.  Die Operation
$m[a\mapsto x]$ ist ähnlich wie bei Umgebungen definiert: der alte
Speicherinhalt bei $a$ wird zunächst entfernt, und dann eine neue
Zuordnung für $a$ nach $x$ hinzugefügt:
%
\begin{displaymath}
  m[a\mapsto x] \deq (e \setminus \{ (a, x') | (a, x') \in m) \cup \{
    (a, x) \}
\end{displaymath}
%
Die Regeln sind immer noch über Substitution definiert, allerdings
werden für Variablen jetzt nicht mehr Werte sondern Adressen
eingesetzt.  Sie werden, wie beim normalen Call-by-Value-Kalkül auch,
auf Subterme fortgesetzt, die möglichst weit links innen stehen.

Im folgenden Beispiel stehen fettgedruckte Zahlen ${\bf
0}$, ${\bf 1}$ für Adressen. Die Redexe sind jeweils
unterstrichen:
%
{\small
\begin{displaymath}
  \begin{array}{l}
    ((\lambda x.((\lambda y.x) (\mathtt{set!}~x~(+~x~1))))~12), \varnothing
    \\
    \rightarrow({\bf 0}~\underline{12}), \{ ({\bf 0}, \lambda x.((\lambda
    y.x) (\mathtt{set!}~x~(+~x~1)))) \}
    \\
    \rightarrow\underline{({\bf 0}~{\bf 1})}, \{ ({\bf 0}, \lambda x.((\lambda
    y.x) (\mathtt{set!}~x~(+~x~1)))), ({\bf 1}, 12) \}
    \\
    \rightarrow 
    (\underline{(\lambda y.{\bf 2})} (\mathtt{set!}~{\bf
    2}~(+~{\bf 2}~1))),
    \{ ({\bf 0}, \lambda x.((\lambda
    y.x) (\mathtt{set!}~x~(+~x~1)))), ({\bf 1}, 12), ({\bf
    2}, 12)\}\\
    \rightarrow 
    ({\bf 3}~(\mathtt{set!}~{\bf
    2}~(+~{\bf 2}~\underline{1}))),
    \\
    \quad
    \{ ({\bf 0}, \lambda x.((\lambda
    y.x) (\mathtt{set!}~x~(+~x~1)))), ({\bf 1}, 12), ({\bf
    2}, 12), ({\bf 3}, (\lambda y.{\bf 2}) \}
    \\
    \rightarrow 
    ({\bf 3}~(\mathtt{set!}~{\bf
    2}~\underline{(+~{\bf 2}~{\bf 4})})),
    \\
    \quad
    \{ ({\bf 0}, \lambda x.((\lambda
    y.x) (\mathtt{set!}~x~(+~x~1)))), ({\bf 1}, 12), ({\bf
    2}, 12), ({\bf 3}, (\lambda y.{\bf 2}),
    ({\bf 4}, 1) \}\\
    \rightarrow 
    ({\bf 3} \underline{(\mathtt{set!}~{\bf
      2}~{\bf 5})}),
    \\
    \quad
    \{ ({\bf 0}, \lambda x.((\lambda
    y.x) (\mathtt{set!}~x~(+~x~1)))), ({\bf 1}, 12), ({\bf
    2}, 12), ({\bf 3}, (\lambda y.{\bf 2}),
    ({\bf 4}, 1), ({\bf 5}, 13) \}
    \\
    \rightarrow 
    ({\bf 3}~\mathtt{void}),
    \\
    \quad
    \{ ({\bf 0}, \lambda x.((\lambda
    y.x) (\mathtt{set!}~x~(+~x~1)))), ({\bf 1}, 12), ({\bf
    2}, 13), ({\bf 3}, (\lambda y.{\bf 2}),
    ({\bf 4}, 1), ({\bf 5}, 13) \}
    \\
    \rightarrow 
    \underline{({\bf 3}~{\bf 6})},
    \\
    \quad
    \{ ({\bf 0}, \lambda x.((\lambda
    y.x) (\mathtt{set!}~x~(+~x~1)))), ({\bf 1}, 12), ({\bf
    2}, 13), ({\bf 3}, (\lambda y.{\bf 2}),
    ({\bf 4}, 1), ({\bf 5}, 13), ({\bf 6}, \mathtt{void}) \}
    \\
    \rightarrow 
    {\bf 2},
    \\
    \quad    \{ ({\bf 0}, \lambda x.((\lambda
    y.x) (\mathtt{set!}~x~(+~x~1)))), ({\bf 1}, 12), ({\bf
    2}, 13), ({\bf 3}, (\lambda y.{\bf 2}),
    ({\bf 4}, 1), ({\bf 5}, 13), ({\bf 6}, \mathtt{void}) \}
  \end{array}
\end{displaymath}
}
%
Der Endausdruck steht für die Speicherzelle an Adresse ${\bf
2}$, wo der Wert $13$ steht.  Es ist sichtbar, dass die
Auswertungsmaschinerie durch die Einführung von Zustand deutlich
komplizierter wird.

\section{Die SECDH-Maschine}
\index{sec:SECDH-Maschine}

Die SECD-Maschine ist nicht mächtig genug, um den $\lambda$-Kalkül mit
Zustand zu modellieren: Es fehlt ein Speicher.  Darum muss das
Maschinen-Pendant zum $\lambda$-Kalkül mit Zustand um eine
Speicher-Komponente erweitert werden: Heraus kommt die
\textit{SECDH-Maschine}, um die es in diesem Abschnitt geht.

Der Maschinencode für die SECDH-Maschine ist dabei genau wie bei der
SECD-Maschine, nur dass eine spezielle Zuweisungsoperation hinzukommt:
%
\begin{grammar}
  \meta{I} \: \ldots
  \> \| :=
\end{grammar}
%
Die Übersetzungsfunktion produziert diese neue Instruktion bei
\texttt{set!}-Ausdrücken:
%
\begin{eqnarray*}
  \llbracket e \rrbracket &\deq&
  \begin{cases}
    \ldots\\
    v~\llbracket e'\rrbracket~\mathtt{:=}
    & \textrm{falls $e = (\mathtt{set!}~v~e')$}
  \end{cases}
\end{eqnarray*}  
%
Der Begriff der Adresse aus der Menge $A$ wird direkt aus dem Kalkül
übernommen.  Ähnlich wie im Kalkül landen Zwischenergebnisse nicht
mehr direkt auf dem Stack, sondern stattdessen landen ihre Adressen im
Speicher.  Dementsprechend bilden nun Umgebungen Variablen auf
Adressen ab.  Die neue Komponente $H$ ist gerade der Speicher, auch
genannt \textit{Heap\index{Heap}}, der die Adressen auf Werte
abbildet:
%
\begin{eqnarray*}
  S &=& A^{\ast}\\
  E &=& \mathcal{P}(V\times A)\\
  D &=& (S\times E\times C)^{\ast}\\
  H &=& \mathcal{P}(A\times W)\\
  W &=& B \cup (V\times C\times E)
\end{eqnarray*}
%
Die Regeln für die SECDH-Maschine sind analog zu den Regeln für die
SECD-Maschine.  Zwei Hauptunterschiede gibt es dabei:
%
\begin{itemize}
\item Der Heap aus $H$ gehört nun zum Zustand dazu.  Anders als die
  Umgebung wird er nicht bei der Bildung von Closures "<eingepackt">:
  Stattdessen wird der Heap stets linear von links nach rechts durch
  Regeln durchgefädelt.
\item Zwischenergebnisse nehmen stets den Umweg über den Heap: Immer,
  wenn ein neues Zwischenergebnis entsteht, wird es bei einer neuen
  Adresse im Heap abgelegt. Auf dem Stack landen die
  Adressen der Zwischenergebnisse.
\end{itemize}

\begin{eqnarray*}
  \hookrightarrow &\in& \mathcal{P}((S\times E\times C\times D\times H) \times (S\times E\times C\times D\times H))\\
  (\underline{s}, e, b\underline{c}, \underline{d}, h)
  &\hookrightarrow& 
  (a\underline{s}, e, \underline{c}, \underline{d}, h[a \mapsto b] )
  \\ && \textrm{wobei $a$ frisch}
  \\
  (\underline{s}, e, v\underline{c}, \underline{d}, h)
  &\hookrightarrow&
  (e(v)\underline{s}, e, \underline{c}, \underline{d}, h)
  \\
  (a_k\ldots a_1\underline{s}, e, \mathtt{prim}_{F^k}\underline{c},
  \underline{d}, h)
  &\hookrightarrow&
  (a\underline{s}, e, \underline{c}, \underline{d}, h[a\mapsto b] )
  \\ && \textrm{wobei $a$ frisch, $b_i = h(a_i)$ und $F^k\in\Sigma^k$ und $F^k_B(b_1,\ldots,b_k) = b$}
  \\
  (a_1a_0\underline{s}, e, \mathtt{:=} \underline{c}, \underline{d}, h)
  &\hookrightarrow&
  (a\underline{s}, e, \underline{c}, \underline{d}, h[a_0 \mapsto
  h(a_1)][a\mapsto \mathtt{void}] )
  \\ && \textrm{wobei $a$ frisch}
  \\
  (\underline{s}, e, (v, \underline{c'})\underline{c}, \underline{d},
  h)
  &\hookrightarrow&
  (a\underline{s}, e, \underline{c}, \underline{d}, h[a \mapsto (v,
  \underline{c'}, e)] )
  \\ && \textrm{wobei $a$ frisch}
  \\
  (a_1a_0\underline{s}, e, \mathtt{ap}\underline{c}, \underline{d}, h)
  &\hookrightarrow&
  (\epsilon, e'[v\mapsto a], \underline{c'}, (\underline{s}, e,
  \underline{c}) \underline{d}, h[a\mapsto h(a_1)])
  \\ && \textrm{wobei $a$ frisch und $h(a_0) = (v, \underline{c'}, e')$}
  \\
  (a, e, \epsilon, (\underline{s'}, e', \underline{c'}) \underline{d}, h)
  &\hookrightarrow&
  (a\underline{s'}, e', \underline{c'}, \underline{d}, h)
\end{eqnarray*}

Entsprechend muss die Auswertungsfunktion das Endergebnis im Heap nachschauen:

\begin{eqnarray*}
  \mathit{eval}_\mathit{SECD} & \in & \mathcal{L}_{\lambda{}S} \times Z\\
  \mathit{eval}_\mathit{SECD}(e) & = &
  \begin{cases}
    h(a) & \textrm{falls } (\epsilon, \varnothing, \llbracket
    e\rrbracket, \epsilon, \varnothing)
    \hookrightarrow^* (a, e, \epsilon, \epsilon, h), h(a) \in B\\
    \texttt{proc} & \textrm{falls } (\epsilon, \varnothing, \llbracket e\rrbracket, \epsilon,\varnothing)
    \hookrightarrow^* (a, e, \epsilon, \epsilon, h), h(a) = (v, \underline{c}, e')\\
  \end{cases}
\end{eqnarray*}


\section{Implementierung der SECDH-Maschine}


Für die Implementierung der SECDH-Maschine werden einige der
Funktionen wiederverwendet, die für die SECD-Maschine programmiert
wurden.  Zunächst einmal muss~-- genau wie bei der SECD-Maschine~--
erst einmal die Übersetzung von Termen in Maschinencode realisiert
werden.  Zuweisungsterme haben wie in den Lehrsprachen die folgende Form:
%
\begin{alltt}
(set! \(v\) \(e\))
\end{alltt}
%
Das dazu passende Prädikat ist das folgende:
%
\begin{verbatim}
; Prädikat für Zuweisungen
(: assignment? (%a -> boolean))
(define assignment?
  (lambda (t)
    (and (cons? t)
         (equal? 'set! (first t)))))

(define assignment (signature (predicate assignment?)))
\end{verbatim}
%
Mit Hilfe dieser Definition kann die Signatur-Definition von
\texttt{term} erweitert werden:
%
\begin{verbatim}
(define term
  (signature
    (mixed symbol
           application
           abstraction
           base
           primitive-application
           assignment)))
\end{verbatim}
%
Um zu vermeiden, dass Zuweisungen mit regulären Applikationen
verwechselt werden, muss das Prädikat \texttt{application?} erweitert
werden:
%
\begin{verbatim}
(define application?
  (lambda (t)
    (and (cons? t)
         (not (equal? 'set! (first t)))
         (not (equal? 'lambda (first t)))
         (not (primitive? (first t))))))
\end{verbatim}
%
Als Nächstes wird die zusätzliche $\mathtt{:=}$-Instruktion
repräsentiert.  Hier sind Daten- und Record-Definition:
%
\begin{verbatim}
; Eine Zuweisungs-Instruktion ist ein Wert
;  (make-:=)
(define-record-procedures :=
  make-:= :=?
  ())
(: make-:= (-> :=))
\end{verbatim}
%
Die Signatur-Definition für Maschinen-Instruktionen kann um \texttt{:=}
erweitert werden:
%
\begin{verbatim}
(define instruction
  (signature
    (mixed base
           symbol
           ap
           tailap
           prim
           abs
           :=)))
\end{verbatim}

Bei der Übersetzung in Maschinencode kommt in
\texttt{term->machine-code} ein weiterer Zweig hinzu:
%
\begin{verbatim}
; Term in Maschinencode übersetzen
(: term->machine-code (term -> machine-code))
(define term->machine-code
  (lambda (e)
    (cond
      ...
      ((assignment? e)
       (cons (first (rest e))
                  (append (term->machine-code (first (rest (rest e))))
                          (list (make-:=))))))))
\end{verbatim}
%
Wie bei der SECD-Maschine werden die verschiedenen Mengendefinitionen
erst einmal in Daten- und Record-Definitionen übersetzt.  Das ist für
Stacks, Umgebungen und Speicheradressen ganz einfach:
%
\begin{verbatim}
; Ein Stack ist eine Liste aus Adressen.
(define stackh (signature (list-of address)))

; Eine Umgebung bildet Variablen auf Adressen ab.

; Eine Adresse ist eine ganze Zahl.
(define address (signature natural))
\end{verbatim}
%
Die Änderung in der Definition von Umgebungen bedingt eine Änderung
der Signatur von \texttt{make-binding}:
%
\begin{verbatim}
(: make-binding (symbol address -> binding))
\end{verbatim}

%
Bei der Repräsentation des Heaps ist wichtig, dass eine Operation zur
Beschaffung frischer Adressen eingebaut wird.  Aus diesem Grund
enthält der Heap zusätzlich zu den Zellen auch noch einen Zähler mit
der nächsten frischen Adresse:
%
\begin{verbatim}
; Ein Heap ist ein Wert
;   (make-heap s n)
; wobei n die nächste freie Adresse ist und s eine Liste
; von Zellen.
(define-record-procedures heap
  make-heap heap?
  (heap-cells heap-next))
(: make-heap ((list-of cell) natural -> heap))
\end{verbatim}
%
Der leere Heap wird schon einmal vorfabriziert:
%
\begin{verbatim}
(define the-empty-heap (make-heap empty 0))
\end{verbatim}
%
Jede Zelle ordnet einer Adresse einen Wert zu:
%
\begin{verbatim}
; Eine Zelle ist ein Wert
;   (make-cell a w)
; wobei a eine Adresse und w ein Wert ist
(define-record-procedures cell
  make-cell cell?
  (cell-address cell-value))
(: make-cell (address value -> cell))
\end{verbatim}
%
Die Funktion \texttt{heap-store}, erweitert den Heap um eine Zelle
entsprechend der mathematischen Definition:
%
\begin{verbatim}
; Wert im Speicher ablegen
(: heap-store (heap address value -> heap))
(define heap-store
  (lambda (h a w)
    (make-heap (cons (make-cell a w)
                          (remove-cell a (heap-cells h)))
               ...)))
\end{verbatim}
%
Die Ellipse steht für die nächste frische Adresse: Wenn die bisherige
frische Adresse in \texttt{heap-store} belegt wird, so muss eine neue
frische Adresse gewählt werden:
%
\begin{verbatim}
(define heap-store
  (lambda (h a w)
    (make-heap (cons (make-cell a w)
                          (remove-cell a (heap-cells h)))
               (let ((next (heap-next h)))
                 (if (= a next)
                     (+ next 1)
                     next)))))
\end{verbatim}
%
Es fehlt noch die Hilfsfunktion \texttt{remove-cell}:
%
\begin{verbatim}
; Zelle zu einer Adresse entfernen
(: remove-cell (address (list-of cell) -> (list-of cell)))
(define remove-cell
  (lambda (a c)
    (cond
      ((empty? c) empty)
      ((cons? c)
       (if (= a (cell-address (first c)))
           (rest c)
           (cons (first c)
                      (remove-cell a (rest c))))))))
\end{verbatim}
%
Als Nächstes ist die Operation an der Reihe, die den Wert, der an einer
Adresse im Heap gespeichert ist.  Die Funktion \texttt{heap-lookup} benutzt
eine Hilfsfunktion \texttt{cells-lookup}, um in der Liste von Zellen
nach der richtigen zu suchen:
%
\begin{verbatim}
; den Wert an einer Adresse im Heap nachschauen
(: heap-lookup (heap address -> value))
(define heap-lookup
  (lambda (h a)
    (cells-lookup (heap-cells h) a)))

; den Wert an einer Adresse in einer Liste von Zellen nachschauen
(: cells-lookup ((list-of cell) address -> value))
(define cells-lookup
  (lambda (c a)
    (cond
      ((empty? c) (violation "unassigned address"))
      ((cons? c)
       (if (= a (cell-address (first c)))
           (cell-value (first c))
           (cells-lookup (rest c) a))))))
\end{verbatim}
%
Schließlich fehlt noch eine Repräsentation für den $\mathtt{void}$-Wert:
%
\begin{verbatim}
; Ein void-Wert ist ein Wert
;  (make-void)
(define-record-procedures void
  make-void void?
  ())
(: make-void (-> void))
\end{verbatim}
%
Auch hier wird nur ein $\mathtt{void}$-Wert benötigt, der 
vorfabriziert wird:
%
\begin{verbatim}
(define the-void (make-void))
\end{verbatim}
%
Der Zustand für die SECDH-Maschine wird genau wie bei der
SECD-Maschine repräsentiert, ergänzt um die Komponente für den Heap:
%
\begin{verbatim}
; Ein SECDH-Zustand ist ein Wert
;   (make-secd s e c d h)
; wobei s ein Stack, e eine Umgebung, c Maschinencode,
; d ein Dump und h ein Speicher ist.
(define-record-procedures secdh
  make-secdh secdh?
  (secdh-stack secdh-environment secdh-code secdh-dump secdh-heap))
(: make-secdh (stackh environment machine-code dump heap -> secdh))
\end{verbatim}
%
Die Implementierung der Zustandsübergangsfunktion hat exakt die
gleiche Struktur wie die Implementierung der SECD-Maschine und hält
sich eng an die mathematische Definition der Regeln:
%
\begin{verbatim}
; eine Zustandstransition berechnen
(: secdh-step (secdh -> secdh))
(define secdh-step
  (lambda (state)
    (let ((stack (secdh-stack state))
          (environment (secdh-environment state))
          (code (secdh-code state))
          (dump (secdh-dump state))
          (heap (secdh-heap state)))
      (cond
        ((cons? code)
         (cond
           ((base? (first code))
            (let ((a (heap-next heap)))
              (make-secdh
               (cons a stack)
               environment
               (rest code)
               dump
               (heap-store heap a (first code)))))
           ((symbol? (first code))
            (make-secdh
             (cons (lookup-environment environment (first code))
                        stack)
             environment
             (rest code)
             dump
             heap))
           ((prim? (first code))
            (let ((a (heap-next heap)))
              (make-secdh
               (cons a
                          (drop (prim-arity (first code)) stack))
               environment
               (rest code)
               dump
               (heap-store heap a
                           (apply-primitive
                            (prim-operator (first code))
                            (map (lambda (address)
                                   (heap-lookup heap address))
                                 (take-reverse (prim-arity (first code)) stack)))))))
           ((:=? (first code))
            (let ((a (heap-next heap)))
              (make-secdh
               (cons a (rest (rest stack)))
               environment
               (rest code)
               dump
               (heap-store
                (heap-store heap
                            (first (rest stack)) 
                            (heap-lookup heap (first stack)))
                a the-void))))
           ((abs? (first code))
            (let ((a (heap-next heap)))
              (make-secdh
               (cons a stack)
               environment
               (rest code)
               dump
               (heap-store heap a
                           (make-closure (abs-variable (first code))
                                         (abs-code (first code))
                                         environment)))))
           ((ap? (first code))
            (let ((closure (heap-lookup heap (first (rest stack))))
                  (a (heap-next heap)))
              (make-secdh empty
                          (extend-environment
                           (closure-environment closure)
                           (closure-variable closure)
                           a)
                          (closure-code closure)
                          (cons
                           (make-frame (rest (rest stack)) environment (rest code))
                           dump)
                          (heap-store heap a (heap-lookup heap (first stack))))))
           ((tailap? (first code))
            (let ((closure (heap-lookup heap (first (rest stack))))
                  (a (heap-next heap)))
              (make-secdh (rest (rest stack))
                          (extend-environment
                           (closure-environment closure)
                           (closure-variable closure)
                           a)
                          (closure-code closure)
                          dump
                          (heap-store heap a
                                      (heap-lookup heap (first stack))))))))
        ((empty? code)
         (let ((f (first dump)))
           (make-secdh
            (cons (first stack)
                       (frame-stack f))
            (frame-environment f)
            (frame-code f)
            (rest dump)
            heap)))))))
\end{verbatim}    
%
Es bleibt die Auswertungsfunktion, die ebenfalls genau wie bei der
SECD-Maschine realisiert wird:
%
\begin{verbatim}
; aus Term SECDH-Anfangszustand machen
(: inject-secdh (term -> secdh))
(define inject-secdh
  (lambda (e)
    (make-secdh empty
                the-empty-environment
                (term->machine-code e)
                empty
               the-empty-heap)))

; bis zum Ende Zustandsübergänge berechnen
(: secdh-step* (secdh -> secdh))
(define secdh-step*
  (lambda (state)
    (if (and (empty? (secdh-code state))
             (empty? (secdh-dump state)))
        state
        (secdh-step* (secdh-step state)))))


; Evaluationsfunktion zur SECD-Maschine berechnen
(: eval-secdh (term -> (mixed value (enum 'function))))
(define eval-secdh
  (lambda (e)
    (let ((final (secdh-step* (inject-secdh e))))
      (let ((val (heap-lookup (secdh-heap final)
                              (first (secdh-stack final)))))
        (if (base? val)
            val
            'proc)))))
\end{verbatim}

