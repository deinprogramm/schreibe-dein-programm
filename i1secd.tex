% Diese Datei ist Teil des Buchs "Schreibe Dein Programm!"
% Das Buch ist lizensiert unter der Creative-Commons-Lizenz
% "Namensnennung - Weitergabe unter gleichen Bedingungen 4.0 International (CC BY-SA 4.0)"
% https://creativecommons.org/licenses/by-sa/4.0/deed.de

% FIXME: Mehr Inline-Aufgaben

\chapter{Exkurs: Die SECD-Maschine}\label{cha:secd}

Dieses Kapitel baut auf dem $\lambda$-Kalkül aus dem vorigen Kapitel auf.
Der $\lambda$-Kalkül ist als theoretisches Modell für berechenbare
Funktionen lange vor der Erfindung des Computers entwickelt worden.
Er bildet zwar die Grundlage für unsere Lehrsprachen, erklärt aber
nicht, wie diese eigentlich auf einem "<echten"> Computer ablaufen.
Moderne Mikroprozessoren werden in einer \textit{Maschinensprache}
programmiert, die sich erheblich vom $\lambda$-Kalkül unterscheidet.
Damit unsere Programme auf so einem Prozessor laufen können, müssen
sie in die Maschinensprache\index{Maschinensprache} übersetzt werden,
mit einem sogenannten \textit{Compiler}.

In diesem Kapitel beschreiben wir eine idealisierte Maschine, die zwar
so nie gebaut wurde, dessen Maschinensprache aber auf den gleichen
Prinzipien basiert~-- die \textit{SECD-Maschine}.  Das machen wir
zunächst auf der Ebene des $\lambda$-Kalküls.  Dann aber schreiben wir
tatsächlich einen echten Compiler und außerdem eine sogenannte
\textit{virtuelle Maschine}, die es uns erlaubt, die compilierten
Programme auch laufenzulassen.

\section{Der angewandte $\lambda$-Kalkül}

Abschnitt~\ref{sec:lambdaprog} auf Seite~\pageref{sec:lambdaprog}
zeigte bereits, dass sich auch boolesche Werte und Zahlen im
$\lambda$-Kalkül durch $\lambda$-Terme darstellen lassen.  Das ist
zwar aus theoretischer Sicht gut zu wissen.  Für die Praxis ist es
aber zu mühsam, immer mit Church-Numeralen zu arbeiten. Darum
erweitern wir den $\lambda$-Kalkül um einige Extras, so dass er mit
Zahlen und Booleans direkt umgehen kann.
Abschnitt~\ref{sec:lambdaprog} hat Dich hoffentlich überzeugt, dass
wir jederzeit auf die neuen Elemente verzichten könnten.

Der resultierende erweiterte $\lambda$-Kalkül heißt 
\textit{angewandter $\lambda$-Kalkül}:

\begin{definition}[Sprache des angewandten $\lambda$-Kalküls
  $\mathcal{L}_{\lambda{}A}$]\index{angewandter $\lambda$-Kalkül}\label{def:lambda-angewandt}
  
  Sei $V$ eine abzählbare Menge von Variablen, wie im
  $\lambda$-Kalkül.

  Sei $B$ eine Menge von \textit{Basiswerten\index{Basiswert}}.  Zu
  den Basiswerten gehören mindestens die booleschen Werte und die
  natürlichen Zahlen, also:
  %
  \begin{displaymath}
    B \deq{} \{ \texttt{\#f}, \texttt{\#t}, 0, 1, 2, \ldots \}
  \end{displaymath}
  %
  Sei für eine natürliche Zahl $i$ jeweils $\Sigma^i$ eine Menge von
  \textit{$i$-stelligen Primitiva\index{Primitivum}}~-- die Namen von
  "<eingebauten Operationen">.  Jedem $F\in\Sigma^i$ ist eine
  $i$-stellige Funktion $F^{\textrm{op}}$~-- ihre \textit{Operation}~--
  zugordnet.

  Zum Beispiel könnte die Addition eine primitive Operation
  $+\in \Sigma^2$ sein.  Die Operation dazu wäre:
  %
  \begin{displaymath}
    +^{\textrm{op}}(a, b) \deq a + b
  \end{displaymath}
  %
  Die Sprache des angewandten
  $\lambda$"=Kalküls, die Menge der \textit{angewandten
    $\lambda$-Terme},
  $\mathcal{L}_{\lambda{}A}$\index{L@$\mathcal{L}_{\lambda{}A}$}, ist
  durch folgende Grammatik definiert:
  \begin{grammar}
    \meta{$\mathcal{L}_{\lambda{}A}$} \: \meta{$V$}
    \> \| (\meta{$\mathcal{L}_{\lambda{}A}$} \meta{$\mathcal{L}_{\lambda{}A}$})
    \> \| ($\lambda$\meta{$V$}.\meta{$\mathcal{L}_{\lambda{}A}$})
    \> \| \meta{$B$}
    \> \| (\meta{$\Sigma^1$}~\meta{$\mathcal{L}_{\lambda{}A}$})
    \> \| (\meta{$\Sigma^2$}~\meta{$\mathcal{L}_{\lambda{}A}$}~\meta{$\mathcal{L}_{\lambda{}A}$})
    \> \ldots
    \> \| (\meta{$\Sigma^n$}~\meta{$\mathcal{L}_{\lambda{}A}$}~\ldots~\meta{$\mathcal{L}_{\lambda{}A}$}) \quad \textrm{($n$-mal)}
  \end{grammar}
  Die Grammatik ist abgekürzt notiert: Die letzen Klauseln besagen,
  dass es für jede Stelligkeit $i$ eine Klausel mit \meta{$\Sigma^i$} gibt,
  bei der jeweils $i$ Wiederholungen von
  \meta{$\mathcal{L}_{\lambda{}A}$}~-- entsprechend der Stelligkeit
  der Primitiva in $\Sigma^i$.

  Terme der Form $(F^i~e_1~\ldots~e_i)$ heißen
  \textit{primitive Applikationen\index{primitive Applikation}}.
\end{definition}
%
Im angewandten $\lambda$-Kalkül sind also
Terme wie zum Beispiel $(+~(-~5~3)~17)$ möglich, wenn $+$ und $-$ in
$\Sigma^2$ enthalten sind.
%
\begin{definition}[Werte im angewandten $\lambda$-Kalkül]\label{def:wert-angewandt}
  Die Vereinigung aus Abstraktionen und
  Basiswerten heißt \textit{Werte}.
\end{definition}
%
Damit die primitiven Operationen auch tatsächlich eine Bedeutung
bekommen, muss eine spezielle Reduktionsregel für sie eingeführt
werden:
%
\begin{definition}[$\delta$-Reduktion]\index{delta-Reduktion@$\delta$-Reduktion}
\begin{displaymath}
  (F^i~e_1~\ldots~e_i) \rightarrow_{\delta} F^{\textrm{op}}(e_1, \ldots, e_k)
  \quad e_1, \ldots, e_i \in B
\end{displaymath}
\end{definition}
%
Diese Regel besagt, dass eine primitive Applikation, wenn alle
Operanden Werte sind, durch Anwendung der entsprechenden Operation 
reduziert werden kann.  Damit wird zum Beispiel der
obige Beispielterm folgendermaßen reduziert:
%
\begin{displaymath}
  (+~\underline{(-~5~3)}~17) \rightarrow_{\delta} \underline{(+~2~17)} \rightarrow_{\delta} 19
\end{displaymath}
%
\begin{aufgabeinline}
  Kannst Du auch $\mathbf{if}$ durch eine $\delta$-Regel beschreiben?

  Zur Beantwortung dieser Frage Schreibe zunächst eine Definition der
  dazugehörigen Funktion $F^\mathbf{if}$ hin.  Bedenke nun, dass die
  $\delta$-Reduktion erst dann greift, wenn alle Argumente von
  $\mathbf{if}$ Werte sind.  Könntest Du mit diesem $\mathbf{if}$ zum
  Beispiel die Fakultät aus Abschnitt~\ref{sec:fixpunktsatz} auf
  Seite~\pageref{sec:fixpunktsatz} definieren?
\end{aufgabeinline}

% FIXME: Aufgabe zur Definition von $\mathbf{if}$

\section{Die SECD-Maschine}

Leider läuft auf handelsüblichen Prozessoren der $\lambda$-Kalkül
nicht direkt.\footnote{Es gibt allerdings durchaus Spezialprozessoren
  für den $\lambda$-Kalkül.} Stattdessen führen diese Prozessoren
sogenannte \textit{Maschinensprache}\index{Maschinensprache} aus.  
Maschinensprache besteht aus einzelnen Anweisungen, die hintereinander
im Speicher abgelegt und auch hintereinander ausgeführt werden.  Das
unterscheidet die Maschinensprache von unseren Lehrsprachen, die auf
dem  all-by-Value-$\lambda$-Kalkül\index{Call-by-Value-Reduktion}
aufbauen: Dort läuft die Auswertung von innen nach außen.

Um die Brücke zwischen beiden Ideen zu schlagen, erfand Peter Landin
die SECD-Maschine~\cite{Landin1964}.  Die SECD-Maschine ist zwar über
50~Jahre alt, aber auch auf modernen Maschinen immer noch die
Grundlage für das Zusammenspiel zwischen Programmiersprache und
Maschinensprache.  Die Sprache der SECD-Maschine ist eine idealisierte
Maschinensprache, die auch aus Anweisungen besteht, die
hintereinander ausgeführt werden.  Viele Details echter
Maschinensprachen lässt die SECD-Maschine aber weg.

\begin{definition}[Sprache der SECD-Machine]\label{def:secd-code}
  Die Anweisungen der SECD-Maschine heißen
  \textit{Instruktionen}\index{Instruktion} und sind durch folgende Grammatik definiert:
  \begin{grammar}
    \meta{I} \: \meta{B}
    \> \| \meta{V}
    \> \| ap
    \> \| prim$_{F^i}$ \textrm{für alle $F^i \in \Sigma^i$}
    \> \| (\meta{V}, \meta{C})
  \end{grammar}
  %
  Ein Maschinensprachen-Programm ist eine Folge von Instruktionen:
  %
  \begin{displaymath}
    C = I^\ast
  \end{displaymath}
\end{definition}
%
Diie SECD-Maschine operiert aber auf sogenannten
\textit{Maschinenzuständen}.  Ein Maschinenzustand ist ein 4-Tupel aus der
Menge $S\times E\times C\times D$ (daher der Name der Maschine).  Die
Buchstaben sind deshalb so gewählt, weil $S$ der sogenannte
\textit{Stack\index{Stack}}, $E$ die sogenannte
\textit{Umgebung\index{Umgebung}} beziehungsweise auf englisch das
\textit{Environment\index{Environment}}, $C$ der schon bekannte
Maschinencode beziehungsweise \textit{Code\index{Code}} und $D$ der
sogenannte \textit{Dump\index{Dump}} ist.  Die formalen Definitionen
dieser Mengen sind wie folgt; dabei ist $W$ die Menge der Werte:
%
\begin{eqnarray*}
  S &=& W^\ast\\
  E &\subseteq& V\times W\\
  D &=& (S\times E \times C)^\ast\\
  W &=& B \cup (V\times C\times E)
\end{eqnarray*}
%
Der Stack ist eine Folge von Werten.  In der Maschine sind dies
die Werte der zuletzt ausgewerteten Terme, wobei der zuletzt
ausgewertete Term vorn beziehungsweise "<oben"> steht.  Die Umgebung ist eine
partielle Abbildung von Variablen auf Werte: sie ersetzt die
Substitution in der Reduktionsrelation des $\lambda$-Kalküls.  Anstatt
dass Werte für Variablen eingesetzt werden, merkt sich die Umgebung
einfach, an welche Werte die Variablen gebunden sind.  Erst wenn der
Wert einer Variablen benötigt wird, holt ihn die Maschine aus der
Umgebung.  Der Dump schließlich ist eine Liste früherer Zustände der
Maschine: er entspricht dem Kontext\index{Kontext} im
Substitutionsmodell.

Die Menge $W$ schließlich entspricht dem Wertebegriff aus
Definition~\ref{def:wert-angewandt}: Die Basiswerte gehören dazu,
außerdem Tripel aus $(V\times C\times E)$.  Ein solches Tripel,
genannt \textit{Closure}\index{Closure}, repräsentiert den Wert
einer Abstraktion.  Eine Closure besteht aus der Variable einer Abstraktion,
dem Maschinencode ihres Rumpfs und der Umgebung, die notwendig ist, um
die Abstraktion anzuwenden: Die Umgebung wird benötigt, damit die
freien Variablen der Abstraktion entsprechend der lexikalischen
Bindung\index{lexikalische Bindung} ausgewertet werden können.  Dies
ist anders als im Stepper, wo Variablen bei der
Applikation direkt ersetzt werden und damit verschwinden.

Die SECD-Maschine überführt einen Maschinenzustand durch einen
Auswertungsschritt in einen neuen Maschinenzustand.

Im Verlauf der Auswertung werden Umgebungen häufig um neue Bindungen
von einer Variable an einen Wert erweitert.  Dazu ist die Notation
$e[v\mapsto w]$ nützlich.  $e[v\mapsto w]$ konstruiert aus einer
Umgebung $e$ eine neue Umgebung, in der die Variable $v$ an den Wert
$w$ gebunden ist.  Hier ist die Definition:
%
\begin{displaymath}
  e[v\mapsto w] \deq (e \setminus \{ (v, w') | (v, w') \in e \}) \cup \{
    (v, w) \}
\end{displaymath}
%
Es wird also zunächst eine eventuell vorhandene alte Bindung entfernt
und dann eine neue hinzugefügt.

\emph{Achtung:} Die Notation $e[v\mapsto w]$ haben wir schonmal im
letzten Kapitel benutzt, nämlich für die Substitution beim
$\lambda$-Kalkül in Definition~\ref{def:substitution} auf
Seite~\pageref{def:substitution}.  In diesem Kontext~-- bei der
SECD-Maschine~-- bedeutet die Notation etwas anderes.  Lass Dich nicht
verwirren!

Um einen $\lambda$-Term $e$ in die SECD-Maschine zu "<injizieren">,
wird der Term in eine Folge von Instruktionen $c$ übersetzt~-- die
$C$-Komponente der SECD-Maschine.  Daraus wird ein Anfangszustand
$(\epsilon, \varnothing, c, \epsilon)$ gemacht.  Dann wird dieser
Zustand wiederholt in einen neuen Zustand überführt, und zwar indem
die erste Instruktion in $c$ "<abgearbeitet"> wird.  Diese Überführung
schreiben wir mit dem Symbol $\hookrightarrow$, also $(s, e, c, d)
\hookrightarrow (s', e', c', d')$, wenn die SECD-Maschine den Zustand
$(s, e, c, d)$ in den Zustand $(s', e', c', d')$ überführt.

Um die Maschine zu verstehen, ist es sinnvoll, erst einmal zu
verstehen, wie $\lambda$-Terme in SECD-Code umgewandelt werden.  
Ein Term $e$ aus dem angewandten $\lambda$-Kalkül wird mit Hilfe der
Funktion $\llbracket \cdot\rrbracket$ in ein Maschinensprache-Programm
$\llbracket e\rrbracket$ übersetzt.
%
\begin{eqnarray*}
  \llbracket e \rrbracket &\deq&
  \begin{cases}
    b & \textrm{falls $e = b \in B$}\\
    v & \textrm{falls $e = v \in V$}\\
    \llbracket e_0\rrbracket~\llbracket e_1\rrbracket~\mathtt{ap}
    & \textrm{falls $e = (e_0~e_1)$}\\
    \llbracket e_1\rrbracket~\ldots~\llbracket e_k\rrbracket~\mathtt{prim}_{F^i}
    & \textrm{falls $e = (F~e_1~\ldots~e_i)$}\\
    (v, \llbracket e_0\rrbracket) & \textrm{falls $e = \lambda v.e_0$}
  \end{cases}
\end{eqnarray*}
%
Zum Beispiel bedeutet die Übersetzung
$\llbracket e_0\rrbracket~\llbracket e_1\rrbracket~\mathtt{ap}$ für
einen Term $(e_0~e_1)$, dass $e_0$ und $e_1$ separat übersetzt werden.
Die Instruktionen der beiden Übersetzungen werden aneinandergehängt,
so dass die SECD-Maschine sie später auch hintereinander ausführt,
also erst $e_0$ auswertet, dann $e_1$.  Wie wir sehen werden, wird die
SECD-Maschine die Ergebnisse der Auswertung von $e_0$ und $e_1$ auf
dem Stack plazieren.  Die Instruktion $\mathtt{ap}$, die noch hinten
dazukommt, sorgt dann dafür, dass die SECD-Maschine die Ergebnisse von
$e_0$ (das muss die Funktion sein) und das Ergebnis von $e_1$ vom
Stack holt und das eine auf das andere anwendet.  Entsprechend steht
$\mathtt{ap}$ für "<Applikation ausführen">.  Außerdem steht
$\mathtt{prim}_{F^k}$ für "<Primitiv $F$ ausführen">.

Basiswerte und Variablen werden direkt in Maschinencode übersetzt.
Eine Abstraktion wird übersetzt in ein Tupel aus seiner Variable und
dem Maschinencode für seinen Rumpf.  Alle diese Anweisungen
hinterlassen ihr Ergebnis jeweils auf dem Stack.

Hier ist ein Beispiel für die Übersetzung:
%
\begin{eqnarray*}
  \llbracket \lambda f.\lambda x.\lambda y.f~(+~x~(*~y~2))\rrbracket
  &=&
  (f, \llbracket \lambda x.\lambda y.f~(+~x~(*~y~2))\rrbracket)\\
  &=&
  (f, (x, \llbracket \lambda y.f~(+~x~(*~y 2))\rrbracket))\\
  &=&
  (f, (x, (y, \llbracket f~(+~x~(*~y 2))\rrbracket)))\\
  &=&
  (f, (x, (y, \llbracket f\rrbracket \llbracket (+~x~(*~y
  2))\rrbracket \mathtt{ap})))\\
  &=&
  (f, (x, (y, f \llbracket (+~x~(*~y 2))\rrbracket\mathtt{ap})))\\
  &=&
  (f, (x, (y, f \llbracket x\rrbracket \llbracket (*~y~2)\rrbracket \mathtt{prim}_+~\mathtt{ap})))\\
  &=&
  (f, (x, (y, f~x \llbracket (*~y~2)\rrbracket \mathtt{prim}_+~\mathtt{ap})))\\
  &=&
  (f, (x, (y, f~x \llbracket y\rrbracket \llbracket 2\rrbracket \mathtt{prim}_*~\mathtt{prim}_+~\mathtt{ap})))\\
  &=&
  (f, (x, (y, f~x~y \llbracket 2\rrbracket \mathtt{prim}_*~\mathtt{prim}_+~\mathtt{ap})))\\
  &=&
  (f, (x, (y, f~x~y~2~\mathtt{prim}_*~\mathtt{prim}_+~\mathtt{ap})))\\
\end{eqnarray*}
%
Das Beispiel zeigt deutlich, wie der Rumpf der innersten Abstraktion
in eine Folge von Instruktionen übersetzt wird, die der Reihenfolge
nach der Call-by-Value-Reduktionsstrategie entspricht: erst $f$
auswerten, dann $x$, dann $y$, dann das Primitiv $*$ anwenden, dann
$+$, und schließlich die Applikation durchführen.

Wir definieren nun die SECD-Maschine selbst. In der folgenden
Definition von $\hookrightarrow$ sind Bezeichner mit einem Unterstrich
versehen, wenn es sich um Folgen handelt, also zum Beispiel \underline{s} für
einen Stack:
%
\begin{eqnarray}
  \hookrightarrow &\in& \mathcal{P}((S\times E\times C\times D) \times (S\times E\times C\times D))\notag\\
  (\underline{s}, e, b\underline{c}, \underline{d})
  &\hookrightarrow& 
  (b\underline{s}, e, \underline{c}, \underline{d})
  \label{secd:base}
  \\
  (\underline{s}, e, v\underline{c}, \underline{d})
  &\hookrightarrow&
  (e(v)\underline{s}, e, \underline{c}, \underline{d})
  \label{secd:variable}
  \\
  (b_k\ldots b_1 \underline{s}, e, \mathtt{prim}_{F^k}\underline{c}, \underline{d})
  &\hookrightarrow&
  (b\underline{s}, e, \underline{c}, \underline{d})
  \label{secd:prim}
  \\ && \textrm{wobei $F^k\in\Sigma^k$ und $F^k_B(b_1,\ldots,b_k) = b$}\notag
  \\
  (\underline{s}, e, (v, \underline{c'}) \underline{c}, \underline{d})
  &\hookrightarrow&
  ((v, \underline{c'}, e) \underline{s}, e, \underline{c}, \underline{d})
  \label{secd:abstraction}
  \\
  (w (v,\underline{c'}, e') \underline{s}, e, \mathtt{ap}~\underline{c}, \underline{d})
  &\hookrightarrow&
  (\epsilon, e'[v\mapsto w], \underline{c'}, (\underline{s}, e, \underline{c}) \underline{d})
  \label{secd:app}
  \\
  (w, e, \epsilon, (\underline{s'}, e', \underline{c'}) \underline{d})
  &\hookrightarrow&
  (w\underline{s'}, e', \underline{c'}, \underline{d})
  \label{secd:return}
\end{eqnarray}
%
Die Regeln definieren eine Fallunterscheidung nach der ersten
Instruktion der Code"=Komponente des Zustands, beziehungsweise greift die letzte
Regel, wenn der Code leer ist.  Der Reihe nach arbeiten die Regeln wie
folgt:
%
\begin{itemize}
\item Regel~\ref{secd:base} (die
  \textit{Literalregel\index{Literalregel}}) schiebt einen Basiswert
  direkt auf den Stack.
\item Regel~\ref{secd:variable} (die
  \textit{Variablenregel\index{Variablenregel}}) ermittelt den Wert
  einer Variable aus der Umgebung und schiebt diesen auf den Stack.
\item Regel~\ref{secd:prim} ist die
  \textit{Primitivregel\index{Primitivregel}}.  Bei einer primitiven
  Applikation müssen soviele Basiswerte oben auf dem Stack liegen wie
  die Stelligkeit des Primitivs.  Dann ermittelt die Primitivregel das Ergebnis der
  primitiven Applikation und schiebt es oben auf den Stack.
\item Regel~\ref{secd:abstraction} ist die
  \textit{Abstraktionsregel\index{Abstraktionsregel}}: Das Tupel
  $(v,\underline{c'})$ ist bei der Übersetzung aus einer Abstraktion
  entstanden.  Die Regel ergänzt $v$ und $\underline{c'}$ mit
  $e$ zu einer Closure, die auf den Stack geschoben wird.
\item Regel~\ref{secd:app} ist die
  \textit{Applikationsregel\index{Applikationsregel}}: Bei einer
  Applikation müssen oben auf dem Stack ein Wert sowie eine Closure
  liegen.  (Zur Erinnerung: Eine Applikation kann nur ausgewertet
  werden, wenn eine Abstraktion vorliegt.  Abstraktionen werden zu
  Closures ausgewertet.)  In einem solchen Fall "<sichert"> die
  Applikation den aktuellen Zustand auf den Dump, und die Auswertung fährt mit
  einem leeren Stack, der Umgebung aus der Closure~-- erweitert um
  eine Bindung für die Variable~-- und dem Code aus der Closure fort.
\item Regel~\ref{secd:return} ist die
  \textit{Rückkehrregel\index{Rückkehrregel}}: Sie ist anwendbar,
  wenn das Ende des Codes erreicht ist.  Das heißt, dass gerade
  die Auswertung einer Applikation fertig ist.  Auf dem Dump liegt
  aber noch ein gesicherter Zustand, der jetzt "<zurückgeholt"> wird.
\end{itemize}
%
Hier ein Beispiel für den Ablauf der SECD-Maschine für den Term
$(((\lambda x.\lambda y.(+~x~y))~1)~2)$:
% (secd-step*/tex (inject-secd '(((lambda (x) (lambda (y) (+ x y))) 1) 2)))
%
\begin{displaymath}
  \begin{array}{l@{}llll}
&(\epsilon, &\varnothing, &(x, (y, x~y~\mathtt{prim}_+))~1~\mathtt{ap}~2~\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&((x, (y, x~y~\mathtt{prim}_+), \varnothing), &\varnothing, &1~\mathtt{ap}~2~\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&(1~(x, (y, x~y~\mathtt{prim}_+), \varnothing), &\varnothing, &\mathtt{ap}~2~\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&(\epsilon, &\{(x, 1)\}, &(y, x~y~\mathtt{prim}_+), &(\epsilon, \varnothing, 2~\mathtt{ap}))\\
\hookrightarrow{}&((y, x~y~\mathtt{prim}_+, \{(x, 1)\}), &\{(x, 1)\}, &\epsilon, &(\epsilon, \varnothing, 2~\mathtt{ap}))\\
\hookrightarrow{}&((y, x~y~\mathtt{prim}_+, \{(x, 1)\}), &\varnothing, &2~\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&(2~(y, x~y~\mathtt{prim}_+, \{(x, 1)\}), &\varnothing, &\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&(\epsilon, &\{(x, 1), (y, 2)\}, &x~y~\mathtt{prim}_+, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&(1, &\{(x, 1), (y, 2)\}, &y~\mathtt{prim}_+, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&(2~1, &\{(x, 1), (y, 2)\}, &\mathtt{prim}_+, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&(3, &\{(x, 1), (y, 2)\}, &\epsilon, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&(3, &\varnothing, &\epsilon, &\epsilon)
  \end{array}
\end{displaymath}
%
Die Zustandsübergangsrelation $\hookrightarrow$ ist die Grundlage
für die \textit{Auswertungsfunktion\index{Auswertungsfunktion}} der
SECD-Maschine, die für einen $\lambda$-Term dessen Bedeutung
ausrechnet.  Dies ist scheinbar ganz einfach:
%
\begin{eqnarray*}
  \mathit{eval}_\mathit{SECD} & : & \mathcal{L}_{\lambda{}A} \rightarrow B\\
  \mathit{eval}_\mathit{SECD}(e) &= & x \textrm{ wenn } (\epsilon, \varnothing, \llbracket e\rrbracket, \epsilon)
    \hookrightarrow^* (x, e, \epsilon, \epsilon)
\end{eqnarray*}
%
Diese Definition hat jedoch zwei Haken:
%
\begin{itemize}
\item Die Auswertung von $\lambda$-Termen terminiert nicht immer (wie
  zum Beispiel für den "<Endlos"=Term"> $(\lambda x.(x~x))~(\lambda x.(x~x))$), es kommt
  also nicht immer dazu, dass die Zustandsübergangsrelation bei einem
  Zustand der Form $(\epsilon, \varnothing, \llbracket e\rrbracket,
  \epsilon)$ terminiert.
\item Das $x$ aus dieser Definition ist nicht immer ein Basiswert~--
  es kann auch eine Closure sein.
\end{itemize}
%
Der erste Haken sorgt dafür, dass die Auswertungsfunktion nur eine
Relation im Sinne einer "<partiellen Funktion"> ist.  Meist wird
trotzdem von einer Auswertungsfunktion gesprochen.  Beim zweiten
Haken, wenn $x$ eine Closure ist, lässt sich mit dem Resultat nicht
viel anfangen: Um die genaue Bedeutung der Closure herauszubekommen,
müsste sie angewendet werden~-- das Programm ist aber schon fertig
gelaufen.  Es ist also gar nicht sinnvoll, zwischen verschiedenen
Closures zu unterscheiden.  Darum wird für die Zwecke der
Auswertungsfunktion eine Menge $Z$ der \textit{Antworten\index{Antwort}}
definiert, die einen designierten Spezialwert für Closures enthält:
%
\begin{displaymath}
  Z = B \cup \{ \texttt{function} \}
\end{displaymath}
%
Damit können wir die Evaluationsfunktion wie folgt definieren:
%
\begin{eqnarray*}
  \mathit{eval}_\mathit{SECD} & \in & \mathcal{L}_{\lambda{}A} \times Z\\
  \mathit{eval}_\mathit{SECD}(e) & = &
  \begin{cases}
    b & \textrm{falls } (\epsilon, \varnothing, \llbracket e\rrbracket, \epsilon)
    \hookrightarrow^* (b, e, \epsilon, \epsilon)\\
    \texttt{function} & \textrm{falls } (\epsilon, \varnothing, \llbracket e\rrbracket, \epsilon)
    \hookrightarrow^* ((v, \underline{c}, e'), e, \epsilon, \epsilon)\\
  \end{cases}
\end{eqnarray*}

\section{\texttt{Quote} und Symbole}
\label{sec:quote}

Dieses Kapitel wird ab hier Gebrauch von einer weiteren
Sprachebene\index{Sprachebene!fortgeschritten} in
\drscheme{} machen, nämlich \texttt{Schreibe Dein Programm! -
  fortgeschritten}.  Diese Ebene muss mit dem \drscheme{}-Menü \texttt{Sprache}
unter \texttt{Sprache auswählen} aktiviert sein, damit die
Programme dieses Kapitels funktionieren.

Die entscheidende Änderung gegenüber den früheren Sprachebenen ist
die Art, mit der die REPL Werte ausdruckt.  Bei Zahlen, Zeichenketten
und booleschen Werten bleibt alles beim alten:
%
\begin{lstlisting}
5
|\evalsto| 5
"Mike ist doof"
|\evalsto| "Mike ist doof"
#t
|\evalsto| #t
\end{lstlisting}
%
Bei Listen sieht es allerdings anders aus:
%
\begin{lstlisting}
(list 1 2 3 4 5 6)
|\evalsto| (1 2 3 4 5 6)
\end{lstlisting}
%
Die REPL druckt also eine Liste aus, indem sie zuerst eine öffnende
Klammer ausdruckt, dann die Listenelemente (durch Leerzeichen
getrennt) und dann eine schließende Klammer.
Das funktioniert auch für die leere Liste:
%
\begin{lstlisting}
empty
|\evalsto| ()
\end{lstlisting}
%
Mit der neuen Sprachebene bekommt außerdem der Apostroph, der dem
Literal\index{Literal} für die leere Liste voransteht, eine erweiterte Bedeutung.
Unter anderem kann der Apostroph benutzt werden, um Literale für
Listen zu formulieren:
%
\begin{lstlisting}
'(1 2 3 4 5 6)
|\evalsto| (1 2 3 4 5 6)
'(1 #t "Mike" (2 3) "doof" 4 #f 17)
|\evalsto| (1 #t "Mike" (2 3) "doof" 4 #f 17)
'()
|\evalsto| ()
\end{lstlisting}
%
In der neuen Sprachebene benutzen die Literale und die ausgedruckten
externen Repräsentationen für Listen also die gleiche
Notation\index{Repräsentation}.  Sie unterscheiden sich nur dadurch,
dass beim Literal der Apostroph voransteht.  Der Apostroph funktioniert
auch bei Zahlen, Zeichenketten und booleschen Werten:
%
\begin{lstlisting}
'5
|\evalsto| 5
'"Mike ist doof"
|\evalsto| "Mike ist doof"
'#t
|\evalsto| #t
\end{lstlisting}
%
Der Apostroph am Anfang eines Ausdrucks
kennzeichnet diesen also als Literal.  Der Wert des Literals wird 
genauso ausgedruckt, wie es im Programm steht.  (Abgesehen von
Leerzeichen und Zeilenumbrüchen.)  Der Apostroph heißt auf englisch
"<quote">\index{quote@\lstinline{quote}}, und deshalb ist diese
Literalschreibweise auch unter diesem Namen bekannt.  Bei Zahlen,
Zeichenketten und booleschen Literalen ist auch ohne Quote klar, dass
es sich um Literale handelt.  Das Quote ist darum bei ihnen rein
optional; sie heißen 
\textit{selbstquotierend}\index{selbstquotierend}.
Bei Listen hingegen sind Missverständnisse mit anderen
zusammengesetzten Formen möglich, die ja auch mit einer öffnenden Klammer
beginnen: \footnote{Tatsächlich ist die neue Schreibweise für externe
  Repräsentationen die Standard-Repräsentation in Racket.  Die
  früheren Sprachebenen benutzten die alternative Schreibweise, um die
  Verwirrung zwischen Listenliteralen und zusammengesetzten Formen zu
  vermeiden.}
\begin{lstlisting}
(1 2 3 4 5 6)
|\evalsto| function application: expected function, given: 1;
     arguments were: 2 3 4 5 6
\end{lstlisting}
%
Mit der Einführung von Quote kommt noch eine völlig neue Sorte Werte
hinzu: die \textit{Symbole\index{Symbol}}.  Symbole sind Werte ähnlich wie Zeichenketten und
bestehen aus Text.  Sie unterscheiden sich allerdings dadurch, dass sie
als Literal mit Quote geschrieben und in der REPL ohne
Anführungszeichen ausgedruckt werden:
%
\begin{lstlisting}
'mike
|\evalsto| mike
'doof
|\evalsto| doof
\end{lstlisting}
%
Symbole können wir mit dem Prädikat
\lstinline{symbol?}\index{symbol@\texttt{symbol?}} von anderen Werten
unterscheiden:
%
\begin{lstlisting}
(symbol? 'mike)
|\evalsto| #t
(symbol? 5)
|\evalsto| #f
(symbol? "Mike")
|\evalsto| #f
\end{lstlisting}
%
Vergleichen können wir Symbole mit der eingebauten Funktion \lstinline{equal?} (siehe
Abbildung~\ref{scheme:equalp}):
\begin{feature}{\texttt{equal?}}{scheme:equalp}
  Die Funktion \texttt{equal?\index{equal?@\texttt{equal?}}} vergleicht beliebige Werte:
  \texttt{Equal?} vergleicht Booleans, Zeichen und Zeichenketten.
  Bei Listen werden die Elemente verglichen und bei Records die Komponenten. 
%
\begin{lstlisting}
(equal? 23 23)
|\evalsto| #t
(equal? #t #f)
|\evalsto| #f
(equal? "Axl" "Slash")
|\evalsto| #f
(equal? "Axl" "Axl")
|\evalsto| #t
(equal? (list "Axl" "Slash") (list "Axl "Slash"))
|\evalsto| #t
(equal? (list "Axl" "Slash") (list "Axl "Slash" "Duff"))
|\evalsto| #f
(equal? (make-wallclock-time 12 24) (make-wallclock-time 12 24)
|\evalsto| #t
(equal? (make-wallclock-time 12 24) (make-wallclock-time 12 25)
|\evalsto| #f
(equal? (make-wallclock-time 12 24) (list "Axl" "Slash")
|\evalsto| #f
\end{lstlisting}
\end{feature}

\begin{lstlisting}
(equal? 'mike 'herb)
|\evalsto| #f
(equal? 'mike 'mike)
|\evalsto| #t
\end{lstlisting}
%
Symbole können nicht aus beliebigem Text bestehen.  
Leerzeichen sind zum Beispiel verboten.  Tatsächlich entsprechen die
Namen der zulässigen Symbole genau den Namen von Variablen:
%
\begin{lstlisting}
'karl-otto
|\evalsto| karl-otto
'mehrwertsteuer
|\evalsto| mehrwertsteuer
'duftmarke
|\evalsto| duftmarke
'lambda
|\evalsto| lambda
'+
|\evalsto| +
'*
|\evalsto| *
\end{lstlisting}
%
Diese Entsprechung wird in diesem Kapitel noch eine entscheidene Rolle
spielen.  Symbole können natürlich auch in Listen und damit auch in
Listenliteralen vorkommen:
%
\begin{lstlisting}
'(karl-otto mehrwertsteuer duftmarke)
|\evalsto| (karl-otto mehrwertsteuer duftmarke)
\end{lstlisting}
%
Mit Hilfe von Symbolen können Werte konstruiert werden, die in der REPL
ausgedruckt wie Ausdrücke aussehen:
%
\begin{lstlisting}
'(+ 1 2)
|\evalsto| (+ 1 2)
'(lambda (n) (+ n 1))
|\evalsto| (lambda (n) (+ n 1))
\end{lstlisting}
%
Auch wenn diese Werte wie Ausdrücke so aussehen, sind sie doch ganz
normale Listen: der Wert von \verb|'(+ 1 2)| ist eine Liste mit drei
Elementen: das Symbol \verb|+|, die Zahl \lstinline{1} und die Zahl
\lstinline{2}.  Der Wert von \verb|'(lambda (n) (+ n 1))| ist ebenfalls
eine Liste mit drei Elementen: das Symbol \verb|lambda|, eine Liste
mit einem einzelnen Element, nämlich dem Symbol \lstinline{n}, und einer
weiteren Liste mit drei Elementen: dem Symbol \lstinline{+}, dem Symbol
\lstinline{n} und der Zahl \lstinline{1}.

Quote hat noch eine weitere verwirrende Eigenheit:
%
\begin{lstlisting}
''()
|\evalsto| '()
\end{lstlisting}
%
Dieses Literal bezeichnet nicht die leere Liste (dann würde nur
\lstinline{()} ausgedruckt, ohne Quote), sondern etwas anderes:
%
\begin{lstlisting}
(cons? ''())
|\evalsto| #t
(first ''())
|\evalsto| quote
(rest ''())
|\evalsto| (())
\end{lstlisting}
%
Der Wert des Ausdrucks \verb|''()| ist also eine Liste mit zwei
Elementen: das erste Element ist das Symbol \lstinline{quote} und das
zweite Element ist die leere Liste.  \lstinline{'$t$}
ist selbst also nur syntaktischer Zucker, und zwar für
\lstinline{(quote $t$)}:
%
\begin{lstlisting}
(equal? (quote ()) '())
|\evalsto| #t
(equal? (quote (quote ())) ''())
|\evalsto| #t
\end{lstlisting}
%
Quote erlaubt die Konstruktion von Literalen für viele Werte, aber
nicht für alle.  Ein Wert, für den Quote ein Literal konstruieren kann,
heißt \textit{repräsentierbarer
  Wert\index{repräsentierbarer Wert}}.  Ein repräsentierbarer Wert ist
eins der folgenden:
%
\begin{itemize}
\item Zahlen, boolesche Werte, Zeichenketten und Symbole sind
  repräsentierbare Werte.
\item Eine Liste aus repräsentierbaren Werten ist ihrerseits ein
  repräsentierbarer Wert. 
\end{itemize}

\section{Ein Compiler für die SECD-Maschine}

FIXME: "<Compiler"> erklären

Die SECD-Maschine ist ein Modell für die Implementierung des
$\lambda$-Kalküls.  Eine solche Implementierung lässt sich in
einfach bauen~-- dieser Abschnitt zeigt, wie.  Der grobe
Fahrplan ergibt sich dabei aus der Struktur der SECD-Maschine selbst:
Nach den obligatorischen Datendefinitionen müssen zunächst Terme in
Maschinencode übersetzt werden.  Dann kommt die
Zustandsübergangsfunktion und schließlich die Auswertungsfunktion an
die Reihe.




\subsection{Datenanalyse}
\label{sec:secd-datenanalyse}

Die erste Aufgabe ist dabei zunächst, wie immer, die Datenanalyse: Am
Anfang stehen die Terme des angewandten $\lambda$-Kalküls.  Eine
geeignete Repräsentation mit Listen und Symbolen lässt dabei die Terme
in der "<fortgeschrittenen"> Sprachebene genau wie entsprechenden
Programm-Terme aussehen:

\noindent\begin{tabular}{lll}
  \texttt{(+ 1 2)} & steht für & $(+~1~2)$\\
  \texttt{(lambda (x) x)} & steht für & $\lambda \lrm x.\lrm x$\\
  \texttt{((lambda (x) (x x)) (lambda (x) (x x)))} & steht für &
  $(\lambda \lrm x.(\lrm x~\lrm x))~(\lambda \lrm x.(\lrm x~\lrm x))$\\
  etc.
\end{tabular}

Die Datendefinition dafür orientiert sich direkt an
Definition~\ref{def:lambda-angewandt}:
%
\begin{lstlisting}
; Ein Lambda-Term ist eins der folgenden:
; - ein Symbol (für eine Variable)
; - eine zweielementige Liste (für eine reguläre Applikation)
; - eine Liste der Form (lambda (x) e) (für eine Abstraktion)
; - ein Basiswert
; - eine Liste mit einem Primitiv als erstem Element
;      (für eine primitive Applikation)
\end{lstlisting}
%
Hier die dazu passende Signatur-Definition:
%
\begin{lstlisting}
(define term
  (signature
    (mixed symbol
           application
           abstraction
           base
           primitive-application)))
\end{lstlisting}
%
Die Signaturen für \lstinline{application} etc.\ müssen noch definiert
werden.

Um Verzweigungen über die Sorte \lstinline{term} zu ermöglichen, müssen
Prädikate für die einzelnen Teilsorten geschrieben werden.  Diese
können dann für die Definition der entsprechenden Signaturen benutzt
werden.
%
\begin{lstlisting}
; Prädikat für reguläre Applikationen
(: application? (any -> boolean))
(define application?
  (lambda (term)
    (and (cons? term)
         (not (equal? 'lambda (first term)))
         (not (primitive? (first term))))))

(define application (signature (predicate application?)))

; Prädikat für Abstraktionen
(: abstraction? (any -> boolean))
(define abstraction?
  (lambda (term)
    (and (cons? term)
         (equal? 'lambda (first term)))))

(define abstraction (signature (predicate abstraction?)))

; Prädikat für primitive Applikationen
(: primitive-application? (any -> boolean))
(define primitive-application?
  (lambda (term)
    (and (cons? term)
         (primitive? (first term)))))

(define primitive-application (signature (predicate primitive-application?)))
\end{lstlisting}
%
Die Definition lässt noch offen, was genau ein "<Basiswert"> und was ein
"<Primitiv"> ist.  Auch hierfür werden noch Datendefinitionen
benötigt, zuerst für Basiswerte.  Der Einfachheit halber beschränkt
sich die Implementierung erst einmal auf boolesche Werte und Zahlen:
%
\begin{lstlisting}
; Ein Basiswert ist ein boolescher Wert oder eine Zahl
\end{lstlisting}
%
Damit Basiswerte in Fallunterscheidungen von den anderen Arten von
Termen unterschieden werden können, wird ein Prädikat benötigt:
%
\begin{lstlisting}
; Prädikat für Basiswerte
(: base? (any -> boolean))
(define base?
  (lambda (term)
    (or (boolean? term) (number? term))))

(define base (signature (predicate base?)))
\end{lstlisting}
%
Als Nächstes sind Primitive gefragt: Am obigen Beispiel ist zu
erkennen, dass zum Beispiel \lstinline{+} ein Primitiv sein sollte.  Die
Datendefinition für eine kleine beispielhafte Menge von Primitiven ist
wie folgt:
%
\begin{lstlisting}
; Ein Primitiv ist eins der Symbole +, -, *, /, =
\end{lstlisting}
%
Da die Primitive genau wie die Variablen Symbole sind, stehen die
Primitive als Variablen nicht mehr zur Verfügung:  Alle Symbole, die
keine Primitive sind, sind also Variablen.  Das dazugehörige Prädikat
ist das folgende:
%
\begin{lstlisting}
; Prädikat für Primitive
(: primitive? (any -> boolean))
(define primitive?
  (lambda (term)
    (or (equal? '+ term)
        (equal? '- term)
        (equal? '* term)
        (equal? '/ term)
        (equal? '= term))))

(define primitive (signature (predicate primitive?)))
\end{lstlisting}
%
Bevor nun ein die SECD-Maschine einen Term verarbeiten kann, muss
dieser erst in Maschinencode übersetzt werden.  Dabei entsteht aus
Definition~\ref{def:secd-code} direkt Daten- und Signatur-Definitionen
für Instruktionen und Maschinencode:
%
\begin{lstlisting}
; Eine Instruktion ist eins der folgenden:
; - ein Basiswert
; - eine Variable
; - eine Applikations-Instruktion
; - eine Instruktion für eine primitive Applikation
; - eine Abstraktion
(define instruction
  (signature
    (mixed base
           symbol
           ap
           tailap
           prim
           abs))

; Eine Maschinencode-Programm ist eine Liste von Instruktionen.
(define machine-code (signature (list-of instruction)))
\end{lstlisting}
%
Bei der Definition von Instruktionen ist wieder einiges Wunschdenken
im Spiel.  Basiswerte und Variablen sind wie bei den Termen.  Die
restlichen Fälle werden durch eigene Datendefinitionen abgebildet.
Wie schon bei den leeren Bäumen sind Record-Definitionen ohne Felder
im Spiel, die Fallunterscheidungen möglich machen:
%
\begin{lstlisting}
; Eine Applikations-Instruktion ist ein Wert
;   (make-ap)
(define-record ap
  make-ap ap?)
(: make-ap (-> ap))

; Die Instruktion für eine primitive Applikation
; ist ein Wert
;   (real-make-prim op arity)
; wobei op ein Symbol und arity die Stelligkeit
; ist
(define-record prim
  real-make-prim prim?
  (prim-operator symbol)
  (prim-arity natural))

; Eine Abstraktions-Instruktion ist ein Wert
;  (make-abs v c)
; wobei v ein Symbol (für eine Variable) und c
; Maschinencode ist
(define-record abst
  make-abs abs?
  (abs-variable symbol)
  (abs-code machine-code))
\end{lstlisting}
%
Da die Stelligkeit eines Primitivs dem Primitiv fest zugeordnet
ist, ist eine Hilfsfunktion nützlich, die bei der Erzeugung eines
Werts der Sorte \lstinline{prim} die Stelligkeit ergänzt.
Glücklicherweise haben alle oben eingeführten Primitive die gleiche
Stelligkeit:  FIXME
%
\begin{lstlisting}
; Primitiv erzeugen
(: make-prim (symbol -> prim))
(define make-prim
  (lambda (operator)
    (real-make-prim operator 2))) ; alle haben derzeit Stelligkeit 2
\end{lstlisting}
%
Die Einführung von Primitive mit anderen Stelligkeiten ist Gegenstand
von Aufgabe~\ref{aufgabe:prim-arity}.

\subsection{Übersetzung in Maschinencode}

Nun, da sowohl Terme als auch der Maschinencode Datendefinitionen
haben, ist es möglich, die Übersetzung zu programmieren.  Hier sind
Kurzbeschreibung, Signatur und Gerüst:
%
\begin{lstlisting}
; Term in Maschinencode übersetzen
(: term->machine-code (term -> machine-code))
(define term->machine-code
  (lambda (term)
    ...))
\end{lstlisting}
%
Da es sich bei \lstinline{term} um gemischte Daten handelt, muss~-- wie
immer~-- eine Verzweigung den Rumpf der Funktion bilden:
%
\begin{lstlisting}
(define term->machine-code
  (lambda (term)
    (cond
      ((symbol? term) ...)
      ((application? term) ...)
      ((abstraction? term) ...)
      ((base? term) ...)
      ((primitive-application? term) ...))))
\end{lstlisting}
%
Die Implementierung entspricht in den einzelnen Fällen genau der
Übersetzungsfunktion $\llbracket\underline{~}\rrbracket$. Die Fälle
für Variablen und Basiswerte sind, genau wie dort, trivial:
%
\begin{lstlisting}
(define term->machine-code
  (lambda (term)
    (cond
      ((symbol? term) (list term))
      ((base? term) (list term))
      ...)))
\end{lstlisting}
%
Bei regulären Applikationen werden
Operator und Operand übersetzt, und das ganze zusammen mit einer
\lstinline{ap}-Instruktion zu einer Liste zusammengesetzt:
%
\begin{lstlisting}
(define term->machine-code
  (lambda (term)
    (cond
      ...
      ((application? term)
       (append (term->machine-code (first term))
               (append (term->machine-code (first (rest term)))
                       (list (make-ap)))))
      ...)))
\end{lstlisting}
%
Bei den primitiven Applikationen werden erst einmal die Operanden in
Maschinencode übersetzt, die Resultate aneinandergehängt, und
schließlich kommt noch eine \lstinline{prim}-Instruktion ans Ende:
%
\begin{lstlisting}
(define term->machine-code
  (lambda (term)
    (cond
      ...
      ((primitive-application? term)
       (append
        (append-lists
         (map term->machine-code (rest term)))
        (list (make-prim (first term)))))
      ...)))
\end{lstlisting}
%
Dieses Stück Code benutzt die Hilfsfunktion \lstinline{append-lists}, die
aus einer Liste von Listen eine einzelne Liste macht, indem die
Elemente aneinandergehängt werden:
%
\begin{lstlisting}
; die Elemente einer Liste von Listen aneinanderhängen
(: append-lists ((list-of (list-of %a)) -> (list-of %a)))
(define append-lists
  (lambda (list)
    (fold '() append list)))
\end{lstlisting}
%
Zurück zur Übersetzung: Eine Abstraktionen wird direkt in eine
\lstinline{abs}-Instruktion übersetzt, wobei der Rumpf selbst
noch in Maschinencode übersetzt wird:
%
\begin{lstlisting}
(define term->machine-code
  (lambda (term)
    (cond
      ...
      ((abstraction? term)
       (list
        (make-abs (first (first (rest term)))
                  (term->machine-code
                   (first (rest (rest term))))))))))
\end{lstlisting}
%

\subsection{Die virtuelle SECD-Maschine}
\label{sec:secd-transition}

FIXME: "<virtuelle Maschine"> erklären

Da nun alle $\lambda$-Terme in Maschinencode-Programme übersetzt
werden können, ist jetzt die eigentliche SECD-Maschine an der Reihe.
Hier sind erst einmal einige neue Datendefinitionen fällig.  Zunächst
einmal die Menge $S$ der Stacks:
%
\begin{lstlisting}
; Ein Stack ist eine Liste von Werten
(define stack (signature (list-of value)))
\end{lstlisting}
%
Die Definition von Werten $W$ kommt etwas später an die Reihe.

Umgebungen aus der Menge $E$ sind mathematisch gesehen Mengen aus
Tupeln.  In der Implementierung werden sie dargestellt aus Listen von
\textit{Bindungen\index{Bindung}}, wobei jede Bindung einem Tupel aus
der mathematischen Definition entspricht:

\begin{lstlisting}
; Eine Umgebung ist eine Liste von Bindungen.
; Dabei gibt es für jede Variable nur eine Bindung.
(define environment (signature (list-of binding)))

; Eine Bindung (Name: binding) ist ein Wert
;  (make-binding v x)
; wobei v der Name einer Variablen und x der dazugehörige Wert ist.

(define-record binding
  make-binding binding?
  (binding-variable symbol)
  (binding-value value))
\end{lstlisting}
% 
Die leere Umgebung wird öfter benötigt und wird darum schon
vordefiniert:
%
\begin{lstlisting}
; die leere Umgebung
(define the-empty-environment empty)
\end{lstlisting}
%
Zwei Operationen gibt es für eine Umgebung $e$: die Erweiterung um
eine Bindung $e[v\mapsto w]$ und das Nachschauen einer Bindung
$e(v)$.  Zunächst die Erweiterung: die Implementierung entspricht
genau der mathematischen Definition: zunächst wird eine eventuell
vorhandene Bindung für $v$ entfernt, dann eine neue Bindung
hinzugefügt:
% 
\begin{lstlisting}
; eine Umgebung um eine Bindung erweitern
(: extend-environment (environment symbol value -> environment))
(define extend-environment
  (lambda (environment variable value)
    (cons (make-binding variable value)
          (remove-environment-binding environment variable))))
\end{lstlisting}
%
Für das Entfernen der alten Bindung ist die Hilfsfunktion
\lstinline{remove-environment-binding} zuständig.  Sie folgt einmal mehr
strikt der Konstruktionsanleitung für Funktionen, die Listen akzeptieren:
% FIXME: Konstruktionsanleitung
\begin{lstlisting}
; die Bindung für eine Variable aus einer Umgebung entfernen
(: remove-environment-binding (environment symbol -> environment))
(define remove-environment-binding
  (lambda (environment variable)
    (cond
      ((empty? environment) empty)
      ((cons? environment)
       (if (equal? variable (binding-variable (first environment)))
           (rest environment)
           (cons (first environment)
                 (remove-environment-binding (rest environment) variable)))))))
\end{lstlisting} 
%
Auch die zweite Operation, das Nachschauen einer Bindung in der
Umgebung, folgt der Konstruktionsanleitung:
%
% FIXME: Konstruktionsanleitung
%
\begin{lstlisting}
; die Bindung für eine Variable in einer Umgebung finden
(: lookup-environment (environment symbol -> value))
(define lookup-environment
  (lambda (environment variable)
    (cond
      ((empty? environment) (violation "unbound variable"))
      ((cons? environment)
       (if (equal? variable (binding-variable (first environment)))
           (binding-value (first environment))
           (lookup-environment (rest environment) variable))))))
\end{lstlisting}
%
Damit sind die Operationen auf Umgebungen abgeschlossen.  Als Nächstes
sind Dumps an der Reihe: $D$ ist als Folge von Tupeln $S\times E\times
C$ definiert, auch genannt \textit{Frames\index{Frame}}.  Hier sind
Daten- und Record-Definition:
%
\begin{lstlisting}
; Ein Dump ist eine Liste von Frames

; Ein Frame ist ein Wert
;  (make-frame s e c)
; wobei s ein Stack, e eine Umgebung und c Maschinencode ist.
(define-record frame
  make-frame frame?
  (frame-stack stack)
  (frame-environment environment)
  (frame-code machine-code))
\end{lstlisting}
%
Schließlich fehlt noch eine Repräsentation für die Menge $W$ der
Werte:  Ein Wert ist entweder ein Basiswert oder eine Closure.
Basiswerte wurden bereits in Abschnitt~\ref{sec:secd-datenanalyse}
definiert; es fehlen noch Closures, die Tupel aus $V\times C\times E$
sind.  Hier sind die entsprechenden Definitionen:
%
\begin{lstlisting}
; Ein SECD-Wert ist ein Basiswert oder eine Closure
(define value (signature (mixed base closure)))

; Eine Closure ist ein Wert
;  (make-closure v c e)
; wobei v die Variable der Lambda-Abstraktion,
; c der Code der Lambda-Abstraktion
; und e ein Environment ist.
(define-record closure
  make-closure closure?
  (closure-variable symbol)
  (closure-code machine-code)
  (closure-environment environment))
\end{lstlisting}
%
Mit Hilfe dieser Definitionen ist es möglich, eine Daten- und eine
Record-Definition für die Zustände der SECD-Maschine anzugeben, also
die Tupel aus $S\times E\times C\times D$:
%
\begin{lstlisting}
; Ein SECD-Zustand ist ein Wert
;  (make-secd s e c d)
; wobei s ein Stack, e eine Umgebung, c Maschinencode
; und d ein Dump ist
(define-record secd
  make-secd secd?
  (secd-stack stack)
  (secd-environment environment)
  (secd-code machine-code)
  (secd-dump dump))
\end{lstlisting}
%
Damit kann es an die Zustandsübergangsfunktion gehen.   Sie wird als
Funktion realisiert, die einen SECD-Zustand akzeptiert und einen neuen
liefert.  Hier sind Kurzbeschreibung, Signatur und Gerüst:
%
\begin{lstlisting}
; Zustandsübergang berechnen
(: secd-step (secd -> secd))
(define secd-step
  (lambda (state)
    ...))
\end{lstlisting}
%
Entsprechend den Regeln der SECD-Maschine muss der Rumpf der Funktion
eine Verzeigung zwischen den verschiedenen Fällen bei der
Code-Komponente von \lstinline{state} sein.  Diese folgen den
Konstruktionsanleitungen für Listen und für gemischte Daten.  Es ist
bereits an den Regeln abzulesen, dass alle Regeln Zugriff auf die
Komponenten von \lstinline{state} benötigen.  Für diese werden gleich am
Anfang lokale Variablen angelegt:
%
\begin{lstlisting}
(define secd-step
  (lambda (state)
    (define stack (secd-stack state))
    (define environment (secd-environment state))
    (define code (secd-code state))
    (define dump (secd-dump state))
    (cond
      ((cons? code)
       (cond
         ((base? (first code)) ...)
         ((symbol? (first code)) ...)
         ((prim? (first code)) ...)
         ((abs? (first code)) ...)
         ((ap? (first code)) ...)))
      ((empty? code) ...))))
\end{lstlisting}
%
In diesem Gerüst werden nun die Regeln direkt abgebildet.  Hier zur
Erinnerung noch einmal die erste Regel für Basiswerte:
%
\begin{displaymath}
  (\underline{s}, e, b\underline{c}, \underline{d})
  \hookrightarrow
  (b\underline{s}, e, \underline{c}, \underline{d})
\end{displaymath}
%
Hier der passende Code dafür:
%
\begin{lstlisting}
(define secd-step
  (lambda (state)
      ...
        (cond
          ((base? (first code))
           (make-secd (cons (first code) stack)
                      environment
                      (rest code)
                      dump))
           ...)
      ...))
\end{lstlisting}
%
Hier die Regel für Variablen:
\begin{displaymath}
  (\underline{s}, e, v\underline{c}, \underline{d})
  \hookrightarrow
  (e(v)\underline{s}, e, \underline{c}, \underline{d})
\end{displaymath}
%
Hier der entsprechende Code:
%
\begin{lstlisting}
(define secd-step
  (lambda (state)
      ...
        (cond
          ((symbol? (first code))
           (make-secd (cons
                        (lookup-environment environment (first code))
                        stack)
                      environment
                      (rest code)
                      dump))
          ...)
      ...))
\end{lstlisting}
%
Die Regel für primitive Applikationen ist etwas aufwendiger:
%
\begin{eqnarray*}
  (b_k\ldots b_1 \underline{s}, e, \mathtt{prim}_{F^k}\underline{c}, \underline{d})
  &\hookrightarrow&
  (b\underline{s}, e, \underline{c}, \underline{d})
  \\ && \textrm{wobei $F^k\in\Sigma^k$ und $F_B(b_1,\ldots,b_k) = b$}
\end{eqnarray*}
%
Für die Implementierung werden Hilfsfunktionen gebraucht, welche die
Argumente vom Stack holen und in der Reihenfolge umdrehen, die
Argumente vom Stack entfernen und schließlich die eigentliche
$\delta$-Transition berechnen:
%
\begin{lstlisting}
(define secd-step
  (lambda (state)
      ...
        (cond
          ...
          ((prim? (first code))
           (make-secd (cons
                       (apply-primitive
                         (prim-operator (first code))
                         (take-reverse (prim-arity (first code)) stack))
                       (drop (prim-arity (first code)) stack))
                      environment
                      (rest code)
                      dump))
           ...)
       ...))
\end{lstlisting}
%
Die Funktion \lstinline{drop} ist gerade die in
Aufgabe~\ref{ex:drop} auf Seite~\pageref{ex:drop} geforderte Funktion:
%
\begin{lstlisting}
; die ersten Elemente einer Liste weglassen
(: drop (natural (list-of %a) -> (list-of %a)))
\end{lstlisting}
%
Die \lstinline{take-reverse}-Funktion ist das Pendant zu \lstinline{drop},
das die ersten $n$ Elemente einer Liste in umgekehrter Reihenfolge
liefert.  Dies ist am einfachsten über eine endrekursive Hilfsfunktion
zu erledigen~-- aus Kapitel~\ref{cha:accu} ist ja bekannt, dass bei
endrekursiver Konstruktion von Listen gerade immer die Reihenfolge
umgedreht wird:
%
\begin{lstlisting}
; die ersten Elemente einer Liste in umgekehrter Reihenfolge berechnen
(: take-reverse (natural (list-of %a) -> (list-of %a)))

(check-expect (take-reverse 2 '(1 2 3 4 5)) '(2 1))
(check-expect (take-reverse 0 '(1 2 3 4 5)) '())
(check-expect (take-reverse 5 '(1 2 3 4 5)) '(5 4 3 2 1))

(define take-reverse
  (lambda (n list0)
    ;; (: loop (natural (list-of a) (list-of a) -> (list-of a)))
    (define accumulate
      (lambda (n list acc)
        (cond
          ((zero? n) acc)
          ((positive? n)
           (accumulate (- n 1) (rest list) (cons (first list) acc))))))
    (accumulate n list0 '())))
\end{lstlisting}
%
Aus einem Primitiv und einer Liste von Argumenten berechnet
\lstinline{apply-primitive} das Resultat der primitiven Applikation.
Dabei handelt es sich bei \lstinline{primitive} um eine
Fallunterscheidung, der Rumpf der Funktion ist also eine entsprechende
Verzweigung:
%
\begin{lstlisting}
; Delta-Transition berechnen
(: apply-primitive (primitive (list-of value) -> value))

(check-expect (apply-primitive '+ '(1 2)) 3)
(check-expect (apply-primitive '- '(2 1)) 1)

(define apply-primitive
  (lambda (primitive args)
    (cond
      ((equal? primitive '+)
       (+ (first args) (first (rest args))))
      ((equal? primitive '-)
       (- (first args) (first (rest args))))
      ((equal? primitive '=)
       (= (first args) (first (rest args))))
      ((equal? primitive '*)
       (* (first args) (first (rest args))))
      ((equal? primitive '/)
       (/ (first args) (first (rest args)))))))
\end{lstlisting}
%
Die Regel für Abstraktionen macht aus einer Abstraktion eine Closure:
\begin{displaymath}
  (\underline{s}, e, (v, \underline{c'}) \underline{c}, \underline{d})
  \hookrightarrow
  ((v, \underline{c'}, e) \underline{s}, e, \underline{c}, \underline{d})
\end{displaymath}
%
Der Code macht dies genauso:
%
\begin{lstlisting}
(define secd-step
  (lambda (state)
      ...
        (cond
          ...
          ((abs? (first code))
           (make-secd (cons
                        (make-closure (abs-variable (first code))
                                      (abs-code (first code))
                                      environment)
                        stack)
                      environment
                      (rest code)
                      dump)))
       ...)))
\end{lstlisting}
%
Hier die Regel für die Applikation:
%
\begin{displaymath}
  (w (v,\underline{c'}, e') \underline{s}, e, \mathtt{ap}~\underline{c}, \underline{d})
  \hookrightarrow
  (\epsilon, e'[v\mapsto w], \underline{c'}, (\underline{s}, e, \underline{c}) \underline{d})
\end{displaymath}
%
Hier der Code dazu:
%
\begin{lstlisting}
(define secd-step
  (lambda (state)
      ...
        (cond
          ...
         ((ap? (first code))
          (define closure (first (rest stack)))
          (make-secd empty  
                     (extend-environment
                      (closure-environment closure)
                      (closure-variable closure)
                      (first stack))
                     (closure-code closure)
                     (cons
                      (make-frame (rest (rest stack)) environment (rest code))
                      dump)))
          ...)
      ...))
\end{lstlisting}
%
Schließlich bleibt noch der Code für die Rückgabe eines Wertes von
einer Funktion.  Hier ist die Regel:
%
\begin{displaymath}
  (w, e, \epsilon, (\underline{s'}, e', \underline{c'}) \underline{d})
  \hookrightarrow
  (w\underline{s'}, e', \underline{c'}, \underline{d})
\end{displaymath}
%
Hier ist der Code dazu:
%
\begin{lstlisting}
(define secd-step
  (lambda (state)
      ...
      (cond
        ...
      ((empty? code)
       (define frame (first dump))
       (make-secd
        (cons (first stack)
              (frame-stack frame))
        (frame-environment frame)
        (frame-code frame)
        (rest dump))))
       ...))
\end{lstlisting}
%
Damit die SECD-Maschine in Betrieb genommen werden kann, muss ein Term
$e$ noch in einen Anfangszustand $(\epsilon, \varnothing, \llbracket
e\rrbracket, \epsilon)$ übersetzt werden.  Das erledigt folgende
Hilfsfunktion:
%
\begin{lstlisting}
; Aus Term SECD-Anfangszustand machen
(: inject-secd (term -> secd))
(define inject-secd
  (lambda (term)
    (make-secd empty
               the-empty-environment
               (term->machine-code/t term)
               empty)))
\end{lstlisting}
%
Damit lässt sich die Maschine schon ausprobieren:
%
\begin{lstlisting}
(secd-step (inject-secd '(+ 1 2)))
|\evalsto| #<record:secd (1) () (2 #<record:prim + 2>) ()>
(secd-step (secd-step (inject-secd '(+ 1 2))))
|\evalsto| #<record:secd (2 1) () (#<record:prim + 2>) ()>
(secd-step (secd-step (secd-step (inject-secd '(+ 1 2)))))
|\evalsto| #<record:secd (3) () () ()>
\end{lstlisting}
%
Es fehlt noch die Auswertungsfunktion $\mathrm{eval}_\mathrm{SECD}$,
die eine Hilfsfunktion benötigt, um die reflexiv-transitive Hülle des
Zustandsübergangs $\hookrightarrow^*$ benötigt:
%
\begin{lstlisting}
; bis zum Ende Zustandsübergänge berechnen
(: secd-step* (secd -> secd))
(define secd-step*
  (lambda (state)
    (if (and (empty? (secd-code state))
             (empty? (secd-dump state)))
        state
        (secd-step* (secd-step state)))))
\end{lstlisting}
%
Die Auswertungsfunktion orientiert sich direkt an der mathematischen
Definition:
%
\begin{lstlisting}
; Evaluationsfunktion zur SECD-Maschine berechnen
(: eval-secd (term -> (mixed value (enum 'function))))

(check-expect (eval-secd '(+ 1 2)) 3)
(check-expect (eval-secd '(((lambda (x) (lambda (y) (+ x y))) 1) 2)) 3)

(define eval-secd
  (lambda (term)
    (define value (first
                   (secd-stack
                    (secd-step* 
                     (inject-secd term)))))
    (if (base? value)
        value
        'function)))
\end{lstlisting}
%
Damit läuft die SECD-Maschine:
%
\begin{lstlisting}
(eval-secd '(((lambda (x) (lambda (y) (+ x y))) 1) 2))
|\evalsto| 3
\end{lstlisting}

\section{Die endrekursive SECD-Maschine}

Die SECD-Maschine hat einen Schönheitsfehler: Bei endkursiven
Applikationen sollte sie eigentlich, wie in Lehrsprachen-Programmen, keinerlei
zusätzlichen Platz verbrauchen, da kein Kontext anfällt.  Folgende
Beispielauswertung für den Term $(\lambda x.x~x)~(\lambda x.x~x)$
zeigt aber, dass der Zustand mit fortschreitender Auswertung immer
größer wird:
%
% (secd-step*/tex (inject-secd '((lambda (x) (x x)) (lambda (x) (x x)))))
\begin{displaymath}\tiny
  \begin{array}{l@{}llll}
&(\epsilon, &\varnothing, &(x, x~x~\mathtt{ap})~(x, x~x~\mathtt{ap})~\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&((x, x~x~\mathtt{ap}, \varnothing), &\varnothing, &(x, x~x~\mathtt{ap})~\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&((x, x~x~\mathtt{ap}, \varnothing)~(x, x~x~\mathtt{ap}, \varnothing), &\varnothing, &\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&(\epsilon, &\{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, &x~x~\mathtt{ap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{ap}, \varnothing), &\{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, &x~\mathtt{ap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{ap}, \varnothing)~(x, x~x~\mathtt{ap}, \varnothing), &\{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, &\mathtt{ap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&(\epsilon, &\{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, &x~x~\mathtt{ap}, &(\epsilon, \{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, \epsilon)~(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{ap}, \varnothing), &\{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, &x~\mathtt{ap}, &(\epsilon, \{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, \epsilon)~(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{ap}, \varnothing)~(x, x~x~\mathtt{ap}, \varnothing), &\{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, &\mathtt{ap}, &(\epsilon, \{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, \epsilon)~(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&(\epsilon, &\{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, &x~x~\mathtt{ap}, &(\epsilon, \{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, \epsilon)~(\epsilon, \{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, \epsilon)~(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{ap}, \varnothing), &\{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, &x~\mathtt{ap}, &(\epsilon, \{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, \epsilon)~(\epsilon, \{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, \epsilon)~(\epsilon, \varnothing, \epsilon))
\\
& \ldots
  \end{array}
\end{displaymath}
%
Damit ist die SECD-Maschine, so wie ist, als Ausführungsmodell für
die Lehrsprachen ungeeignet.  Dieses Manko lässt sich zum Glück reparieren: Die
SECD-Maschine muss endrekursive und "<normale"> Applikationen
unterschiedlich behandeln.  Dazu wird eine neue Instruktion namens
$\mathtt{tailap}$ eingeführt, die wie $\mathtt{ap}$ eine Applikation
durchführt, aber eine endrekursive Applikation signalisiert:
%
\begin{eqnarray*}
  I &=& \ldots\\
  &&\cup \{ \mathtt{tailap} \}
\end{eqnarray*}
%
Als Nächstes muss die Übersetzungsfunktion von Termen in Maschinencode
geändert werden:  Applikationen, die Kontext um sich herum haben,
sollen mit $\mathtt{ap}$ übersetzt werden, solche ohne Kontext mit
$\mathtt{tailap}$.  Da der Applikation allein der Kontext nicht
anzusehen ist, sondern nur dem Term "<drumherum">, wird die
Übersetzungsfunktion $\llbracket \underline{~} \rrbracket$ in zwei
Teile aufgespalten: für einen Term $e$ wird die Auswertungsfunktion $\llbracket\underline{~}\rrbracket$ immer dann benutzt, wenn um $e$ Kontext steht.  Eine
weitere Funktion $\llbracket \underline{~} \rrbracket'$ wird immer
dann aufgerufen, wenn \emph{kein} Kontext drumherum steht.

Kontext entsteht seinerseits immer durch Funktionsapplikationen.  Bei
der Auswertung eines Terms $(e_0~e_1)$ muss \emph{nach} $e_0$ noch
$e_1$ ausgewertet werden, und nach Auswertung von $e_1$ muss noch die
Applikation durchgeführt werden.  Sowohl $e_0$ als auch $e_1$ stehen
in Kontext.  Ähnlich ist es bei den Argumenten von primitiven
Applikationen.

Auf der anderen Seite schneiden Abstraktionen für ihren Rumpf den
Kontext erst einmal ab: Der Rumpf einer Abstraktion kommt schließlich bei der
Auswertung der Abstraktion noch gar nicht zum Zug.  Ob er Kontext hat
oder nicht, entscheidet sich erst bei der Applikation.
Dementsprechend schalten Applikationen und Abstraktionen zwischen den
beiden Funktionen $\llbracket \underline{~} \rrbracket$ und
$\llbracket \underline{~} \rrbracket'$ hin und her:
%
\begin{eqnarray*}
  \llbracket \underline{~} \rrbracket &:& \mathcal{L}_{\lambda{}A} \rightarrow C\\
  \llbracket e \rrbracket &\deq&
  \begin{cases}
    b & \textrm{falls $e = b \in B$}\\
    v & \textrm{falls $e = v \in V$}\\
    \llbracket e_0\rrbracket~\llbracket e_1\rrbracket~\mathtt{ap}
    & \textrm{falls $e = (e_0~e_1)$}\\
    \llbracket e_1\rrbracket~\ldots~\llbracket e_k\rrbracket~\mathtt{prim}_{F^k}
    & \textrm{falls $e = (F~e_1~\ldots~e_k)$}\\
    (v, \llbracket e_0\rrbracket') & \textrm{falls $e = \lambda v.e_0$}
  \end{cases}\\[1ex]
  \llbracket \underline{~} \rrbracket' &:& \mathcal{L}_{\lambda{}A} \rightarrow C\\
  \llbracket e \rrbracket' &\deq&
  \begin{cases}
    b & \textrm{falls $e = b \in B$}\\
    v & \textrm{falls $e = v \in V$}\\
    \llbracket e_0\rrbracket~\llbracket e_1\rrbracket~\mathtt{tailap}
    & \textrm{falls $e = (e_0~e_1)$}\\
    \llbracket e_1\rrbracket~\ldots~\llbracket e_k\rrbracket~\mathtt{prim}_{F^k}
    & \textrm{falls $e = (F~e_1~\ldots~e_k)$}\\
    (v, \llbracket e_0\rrbracket') & \textrm{falls $e = \lambda v.e_0$}
  \end{cases}
\end{eqnarray*}
%
Die Übersetzungsfunktion hat die eigentliche Arbeit geleistet: Jetzt
muss nur noch eine Zustandsübergangsregel her, die $\mathtt{tailap}$
verarbeitet.  Diese ergibt sich direkt aus den Regeln für
$\mathtt{ap}$ und die Rückgabe eines Wertes:  $\mathtt{tailap}$
funktioniert so, wie $\mathtt{ap}$ direkt gefolgt von der
Rückgaberegel.  Hier sind die beiden Regeln noch einmal zur Erinnerung:
%
\begin{eqnarray*}
   (w (v,\underline{c'}, e') \underline{s}, e, \mathtt{ap}~\underline{c}, \underline{d})
  &\hookrightarrow&
  (\epsilon, e'[v\mapsto w], \underline{c'}, (\underline{s}, e, \underline{c}) \underline{d})
  \\
  (w, e, \epsilon, (\underline{s'}, e', \underline{c'}) \underline{d})
  &\hookrightarrow&
  (w\underline{s'}, e', \underline{c'}, \underline{d})
\end{eqnarray*}
%
Da die erste Regel ein neues Dump-Frame erzeugt und die zweite ein
Dump-Frame "<vernichtet">, entfällt diese Arbeit in der Regel für
$\mathtt{tailap}$:
%
\begin{eqnarray*}
  (w (v,\underline{c'}, e') \underline{s}, e, \mathtt{tailap}~\underline{c}, \underline{d})
  &\hookrightarrow&
  (\underline{s}, e'[v \mapsto w], \underline{c'}, \underline{d})
\end{eqnarray*}
%
Damit läuft das Beispiel zwar immer noch endlos, aber immerhin, ohne
immer mehr Platz zu verbrauchen:
%
\begin{displaymath}\scriptsize
  \begin{array}{l@{}llll}
 \hookrightarrow{}&(\epsilon, &\varnothing, &(x, x~x~\mathtt{tailap})~(x, x~x~\mathtt{tailap})~\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&((x, x~x~\mathtt{tailap}, \varnothing), &\varnothing, &(x, x~x~\mathtt{tailap})~\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&((x, x~x~\mathtt{tailap}, \varnothing)~(x, x~x~\mathtt{tailap}, \varnothing), &\varnothing, &\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&(\epsilon, &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &x~x~\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{tailap}, \varnothing), &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &x~\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{tailap}, \varnothing)~(x, x~x~\mathtt{tailap}, \varnothing), &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&(\epsilon, &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &x~x~\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{tailap}, \varnothing), &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &x~\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{tailap}, \varnothing)~(x, x~x~\mathtt{tailap}, \varnothing), &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&(\epsilon, &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &x~x~\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{tailap}, \varnothing), &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &x~\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{tailap}, \varnothing)~(x, x~x~\mathtt{tailap}, \varnothing), &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&(\epsilon, &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &x~x~\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{tailap}, \varnothing), &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &x~\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))
 \end{array}
\end{displaymath}
Die Implementierung der endrekursiven SECD-Maschine ist Gegenstand von
Übungsaufgabe~\ref{aufgabe:secd-endekursiv-implementieren}.

\section*{Übungsaufgaben}

\begin{aufgabe}
  Übersetze folgende Lambda-Terme in die Zwischenrepräsentation
  der SECD-Maschine:
  
  \begin{enumerate}
  \item \((\lambda xy.(+\:x\:y))\:(*\:5\:6)\:23\)

  \item \((\lambda x.(!\:x))\:(\lambda xy.(\&\&\:x\:y))\:((\lambda xy.(>\:x\:y))\:23~42)\:true\)

   
  \item \((\lambda xy.\:y\:x\:x)\:(\lambda z.\:z)\:(\lambda yz.\:(y\:y)\:(y\:z))\)

  \end{enumerate}

  Dabei steht $!$ für das boolesche \lstinline{not} und $\&\&$ für das
  boolesche \lstinline{and}.
\end{aufgabe}

\begin{aufgabe}
 Betrachte folgendes SECD-Programm:
 
 \newcommand{\tuple}[2]{\ensuremath{(#1,#2)}}

 \begin{center}
   \tuple{f}{\tuple{x}{\tuple{y}{f\:x\:\texttt{ap}\:y\:\texttt{ap}}}}\:\tuple{a}{\tuple{b}{a\:b\:\texttt{prim}_+}}\:\texttt{ap}\:23\:\texttt{ap}\:42\:\texttt{ap}
 \end{center}
 
 \begin{enumerate}
   \item Übersetze das SECD-Programm in den entsprechenden
   $\mathcal{L}_{\lambda{}A}$-Term.
   \item Werte das SECD-Programm aus und gibt die einzelnen
     Auswertungsschritte an!
 \end{enumerate}
  
\end{aufgabe}

\begin{aufgabe}\label{aufgabe:secd-endekursiv-implementieren}
  Erweitere die Implementierung der SECD-Maschine um korrekte
  Behandlung der Endrekursion!  Erweitere dazu zunächst die
  Datendefinition für Maschinencode. Implementiere dann die
  Übersetzung von $\lambda$-Termen für die endrekursive SECD-Maschine.
  Erweitere schließlich die Zustandsübergangsfunktion um einen
  Fall für die $\mathtt{tailap}$-Instruktion.
\end{aufgabe}

\begin{aufgabe}
  Die um Endrekursion erweiterte SECD-Maschine führt eine neue
  Maschinencode"=Instruktion \lstinline{tailap} ein.  Dies ist aber nicht
  unbedingt nötig.  Formuliere die Zustandsübergangsregeln der
  SECD-Maschine mit Endrekursion so um, dass die Funktionalität, also
  insbesondere die richtige Behandlung endrekursiver Applikationen,
  auch ohne das das zusätzliche Schlüsselwort \lstinline{tailap}
  erhalten bleibt.
\end{aufgabe}

\begin{aufgabe}
  Zeige in der um Endrekursion erweiterten
  SECD-Maschine, dass \lstinline{tailap} immer am Ende steht, also
  tatsächlich keinen Kontext besitzt.
\end{aufgabe}

\begin{aufgabe}\label{aufgabe:prim-arity}
  Erweitere die SECD-Maschine um Primitive anderer Stelligkeiten,
  zum Beispiel \lstinline{abs} oder \lstinline{odd?}.
\end{aufgabe}

\begin{aufgabe}
  Ändere die Implementierung der SECDH-Maschine dahingehend, dass
  sie Endrekursion korrekt behandelt.
\end{aufgabe}

\begin{aufgabe}
  Abstrahiere über \lstinline{remove-environment-binding} und
  \lstinline{remove-cell}.
\end{aufgabe}

\begin{aufgabe}
  Erweiter den angewandten $\lambda$-Kalkül um Abstraktionen und
  Applikationen mit mehr als einem Parameter.  Erweitere die
  SECD-Maschine und ihre Implementierung entsprechend.
\end{aufgabe}


\begin{aufgabe}
  Erweitere den angewandten $\lambda$-Kalkül um binäre
  Verzweigungen analog zu \lstinline{if}.  Erweitere entsprechend die
  SECD-Maschine und ihre Implementierung.
\end{aufgabe}

\begin{aufgabe}
  \lstinline{Begin} lässt sich im angewandten $\lambda$-Kalkül als
  syntaktischer Zucker auffassen: Wie müssten \lstinline{begin}-Ausdrücke
  in die Sprache des Kalküls übersetzt werden?
\end{aufgabe}

\begin{aufgabe}
  Anstatt Umgebungen durch Listen von Bindungen zu repräsentieren, ist
  es auch möglich, Funktionen zu verwenden, so dass
  \lstinline{lookup-environment} folgendermaßen aussieht:
\begin{lstlisting}
(define lookup-environment
  (lambda (environment variable)
    (environment variable)))
\end{lstlisting}
  Ergänze eine passende Definition für
  \lstinline{extend-environment}.
\end{aufgabe}

\begin{aufgabe}
  Auf den ersten Blick erscheint es etwas aufwendig, jedesmal bei der
  Auswertung einer Abstraktion die gesamte Umgebung in die Closure
  einzupacken.  Was würde sich ändern, wenn dieser Schritt weggelassen
  würde, Closures also nur Variable und Maschinencode für den Rumpf
  enthalten würden?  Formuliere die entsprechenden Regeln für die
  SECD-Maschine und ändere Sie die Implementierung entsprechend.
  Funktioniert die SECD-Maschine nach der Änderung noch korrekt?
\end{aufgabe}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "i1"
%%% End: 

