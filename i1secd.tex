% Diese Datei ist Teil des Buchs "Schreibe Dein Programm!"
% Das Buch ist lizensiert unter der Creative-Commons-Lizenz
% "Namensnennung - Weitergabe unter gleichen Bedingungen 4.0 International (CC BY-SA 4.0)"
% https://creativecommons.org/licenses/by-sa/4.0/deed.de

\chapter{Die SECD-Maschine}\label{cha:secd}

Der $\lambda$-Kalkül ist als theoretisches Modell für berechenbare
Funktionen lange vor der Erfindung des Computers entwickelt worden.
Die Reduktionsregeln dienen dabei der Entwicklung von Beweisen über
die Äquivalenz von $\lambda$-Termen.  Damit der $\lambda$-Kalkül auch
als Modell für die tatsächliche Ausführung von Programmen, auf dem
Computer geeignet ist, fehlen noch zwei Zutaten: die direkte
Definition von "<eingebauten"> Werten und Operationen wie Zahlen und
booleschen Werten sowie ein formales Auswertungsmodell.  Dieses
Kapitel stellt zunächst den \textit{angewandten $\lambda$-Kalkül} vor,
der den normalen $\lambda$-Kalkül um primitive Werte und Operationen
erweitert, und dann die \textit{SECD-Maschine}, ein klassisches
Auswertungsmodell für die Call-by-Value-Reduktion.  Angenehmerweise
lässt sich die SECD-Maschine auch als Programm implementieren,
was ebenfalls in diesem Kapitel geschieht.  Die SECD-Maschine
kennt keine Zuweisungen; es folgt darum noch die Darstellung der
\textit{SECDH-Maschine}, die auch einen \textit{Speicher} kennt und
damit Zuweisungen korrekt modelliert.

Ab diesem Kapitel wird die Sprachebene \texttt{Schreibe
  Dein Programm! - fortgeschritten} benötigt. 

\section{Der angewandte $\lambda$-Kalkül}

Abschnitt~\ref{sec:lambdaprog} zeigte bereits, dass sich auch boolesche
Werte und Zahlen im $\lambda$-Kalkül durch $\lambda$-Terme darstellen
lassen.  Das ist zwar aus theoretischer Sicht gut zu wissen, auf Dauer
aber etwas mühsam: Darum ist es sinnvoll, mit einer erweiterten
Version des $\lambda$-Kalküls zu arbeiten, die solche "<primitiven">
Werte direkt kennt.  Abschnitt~\ref{sec:lambdaprog} hat gezeigt,
dass eine solche Erweiterung nur syntaktischer Zucker ist,
also die Ausdruckskraft des Kalküls nicht wirklich erhöht.  Alle
Erkenntnisse aus dem normalen $\lambda$-Kalkül bleiben also erhalten.

Ein solcher erweiterter $\lambda$-Kalkül heißt auch
\textit{angewandter $\lambda$-Kalkül}:

\begin{definition}[Sprache des angewandten $\lambda$-Kalküls
  $\mathcal{L}_{\lambda{}A}$]\index{angewandter $\lambda$-Kalkül}\label{def:lambda-angewandt}
  
  Sei $V$ eine abzählbare Menge von Variablen.  Sei $B$ eine Menge von
  \textit{Basiswerten\index{Basiswert}}.  Sei für eine natürliche
  Zahl $n$ und $i \in \{1, \ldots, n\}$ jeweils $\Sigma^i$ eine Menge
  von \textit{$i$-stelligen Primitiva\index{Primitivum}}~-- die Namen
  von "<eingebauten Operationen">.  Jedem $F^i\in\Sigma^i$ ist eine
  $i$-stellige Funktion $F_B^i: B\times\ldots\times B \rightarrow
  B$~-- ihre \textit{Operation}~--
  zugordnet.  Die Sprache des angewandten $\lambda$"=Kalküls, die
  Menge der \textit{angewandten $\lambda$-Terme},
  $\mathcal{L}_{\lambda{}A}$\index{L@$\mathcal{L}_{\lambda{}A}$}, ist
  durch folgende Grammatik definiert:
  \begin{grammar}
    \meta{$\mathcal{L}_{\lambda{}A}$} \: \meta{$V$}
    \> \| (\meta{$\mathcal{L}_{\lambda{}A}$} \meta{$\mathcal{L}_{\lambda{}A}$})
    \> \| ($\lambda$\meta{$V$}.\meta{$\mathcal{L}_{\lambda{}A}$})
    \> \| \meta{$B$}
    \> \| (\meta{$\Sigma^1$}~\meta{$\mathcal{L}_{\lambda{}A}$})
    \> \| (\meta{$\Sigma^2$}~\meta{$\mathcal{L}_{\lambda{}A}$}~\meta{$\mathcal{L}_{\lambda{}A}$})
    \> \ldots
    \> \| (\meta{$\Sigma^n$}~\meta{$\mathcal{L}_{\lambda{}A}$}~\ldots~\meta{$\mathcal{L}_{\lambda{}A}$}) \quad \textrm{($n$-mal)}
  \end{grammar}
  Die Grammatik ist abgekürzt notiert: Die letzen Klauseln besagen,
  dass es für jede Stelligkeit $i$ eine Klausel mit \meta{$\Sigma^i$} gibt,
  bei der jeweils $i$ Wiederholungen von
  \meta{$\mathcal{L}_{\lambda{}A}$}~-- entsprechend der Stelligkeit
  der Primitiva in $\Sigma^i$.
  %
Dabei heißen Terme der Form $(F^k~e_1~\ldots~e_k)$ auch
\textit{primitive Applikationen\index{primitive Applikation}}.
\end{definition}
%
In diesem Kapitel dienen normalerweise die Zahlen als Basiswerte mit
den üblichen Operationen wie $+$, $-$, $\ast$, $/$ etc.  Damit sind
Terme wie zum Beispiel $(+~(-~5~3)~17)$ möglich.

Im angewandten $\lambda$-Kalkül kommen zu den Werten aus
Definition~\ref{def:wert} die Basiswerte dazu:
%
\begin{definition}[Werte im angewandten $\lambda$-Kalkül]\label{def:wert-angewandt}
  Im angewandten $\lambda$-Kalkül heißen die Abstraktionen und
  Basiswerte kollektiv \textit{Werte}.  Ein $\lambda$-Term, der kein
  Wert\index{Wert} ist, heißt \textit{Nichtwert\index{Nichtwert}}.
\end{definition}

Damit die primitiven Operationen auch tatsächlich eine Bedeutung
bekommen, muss eine spezielle Reduktionsregel für sie eingeführt
werden:
%
\begin{definition}[$\delta$-Reduktion]\index{delta-Reduktion@$\delta$-Reduktion}
\begin{displaymath}
  (F^k~e_1~\ldots~e_k) \rightarrow_{\delta} F_B^k(e_1, \ldots, e_k)
  \quad e_1, \ldots, e_k \in B
\end{displaymath}
\end{definition}
%
Diese Regel besagt, dass eine primitive Applikation, wenn alle
Operanden Werte sind, durch Anwendung der entsprechenden Operation 
reduziert werden kann.  Damit wird z.B.\ der
obige Beispielterm folgendermaßen reduziert:
%
\begin{displaymath}
  (+~(-~5~3)~17) \rightarrow_{\delta} (+~2~17) \rightarrow_{\delta} 19
\end{displaymath}

\section{Die einfache SECD-Maschine}

Wie schon in Abschnitt~\ref{sec:scheme-auswertung} erwähnt, ist 
der Call-by-Value-$\lambda$-Kalkül\index{Call-by-Value-Reduktion}
ein Modell für die Auswertung der Lehrsprachen und viele andere
Programmiersprachen .
Allerdings ist Definition~\ref{def:call-by-value} strenggenommen etwas
vage: Es wird immer nur der Subterm reduziert, der
"<möglichst weit links innen steht">, aber was das heißt, ist nicht
genau definiert.  Außerdem ist Reduktion zwar ein
mächtiges formales Modell, entspricht aber nicht der
Ausführungsmethode tatsächlicher Programmiersprachen auf echten
Prozessoren.  Ein präzises und echten Maschinen deutlich näheres
Modell ist die \textit{SECD-Maschine\index{SECD-Maschine}}, erfunden
schon in den 60er Jahren von Peter Landin~\cite{Landin1964}, und
seitdem die Grundlage für zahllose Implementierungen von
Call-by-Value-Sprachen.  (Die Darstellung hier ist gegenüber Landins
ursprünglicher Formulierung etwas modernisiert.)

Damit ein Programm aus dem angewandten $\lambda$-Kalkül mit der
SECD-Maschine ausgewertet werden kann, muss es erst einmal in einen
speziellen \textit{Maschinencode\index{Maschinencode}} übersetzt oder
"<compiliert"> werden.  Der Maschinencode besteht, anders als der
$\lambda$-Kalkül, nicht aus geschachtelten Termen, sondern aus einer
Folge von \textit{Instruktionen\index{Instruktion}}.  

\begin{definition}[Maschinencode]\label{def:secd-code}
  In der folgenden Definition ist $I$ die Menge der Instruktionen:
  \begin{grammar}
    \meta{I} \: \meta{B}
    \> \| \meta{V}
    \> \| ap
    \> \| prim$_{F^i}$ \textrm{für alle $F^i \in \Sigma^i$}
    \> \| (\meta{V}, \meta{C})
  \end{grammar}
  %
  Ein Maschinencode-Programm ist eine Folge von Instruktionen:
  %
  \begin{displaymath}
    C = I^\ast
  \end{displaymath}
\end{definition}

Ein Term aus dem angewandten $\lambda$-Kalkül wird mit Hilfe folgender
Funktion in Maschinencode übersetzt:
%
\begin{eqnarray*}
  \llbracket \underline{~} \rrbracket &:& \mathcal{L}_{\lambda{}A}
  \rightarrow C\\
  \llbracket e \rrbracket &\deq&
  \begin{cases}
    b & \textrm{falls $e = b \in B$}\\
    v & \textrm{falls $e = v \in V$}\\
    \llbracket e_0\rrbracket~\llbracket e_1\rrbracket~\mathtt{ap}
    & \textrm{falls $e = (e_0~e_1)$}\\
    \llbracket e_1\rrbracket~\ldots~\llbracket e_k\rrbracket~\mathtt{prim}_{F^k}
    & \textrm{falls $e = (F~e_1~\ldots~e_k)$}\\
    (v, \llbracket e_0\rrbracket) & \textrm{falls $e = \lambda v.e_0$}
  \end{cases}
\end{eqnarray*}
%
Die Übersetzungsfunktion "<linearisiert"> einen $\lambda$-Term.  Zum
Beispiel bedeutet die Übersetzung $\llbracket e_0\rrbracket~\llbracket
e_1\rrbracket~\mathtt{ap}$ für einen Term $(e_0~e_1)$, dass zuerst
$e_0$ ausgewertet wird, danach wird $e_1$ ausgewertet, und schließlich wird die
eigentliche Applikation ausgeführt:  Entsprechend steht $\mathtt{ap}$
für "<Applikation ausführen"> und $\mathtt{prim}_{F^k}$ für "<Primitiv
$F$ ausführen">.  Basiswerte und Variablen werden im Maschinencode
belassen.  Ein $\lambda$-Term wird übersetzt in ein Tupel aus seiner
Variable und dem Maschinencode für seinen Rumpf.

Durch die Linearisierung sind die Instruktionen schon in einer Liste in der
Reihenfolge ihrer Ausführung aufgereiht.  Insbesondere hat die
Linearisierung den Begriff "<links innen"> formalisiert: der jeweils
am weitesten links innen stehende Redex steht in der Liste der
Instruktionen vorn.

Beispiel:
%
\begin{eqnarray*}
  \llbracket \lambda f.\lambda x.\lambda y.f~(+~x~(*~y~2))\rrbracket
  &=&
  (f, \llbracket \lambda x.\lambda y.f~(+~x~(*~y~2))\rrbracket)\\
  &=&
  (f, (x, \llbracket \lambda y.f~(+~x~(*~y 2))\rrbracket))\\
  &=&
  (f, (x, (y, \llbracket f~(+~x~(*~y 2))\rrbracket)))\\
  &=&
  (f, (x, (y, \llbracket f\rrbracket \llbracket (+~x~(*~y
  2))\rrbracket \mathtt{ap})))\\
  &=&
  (f, (x, (y, f \llbracket (+~x~(*~y 2))\rrbracket\mathtt{ap})))\\
  &=&
  (f, (x, (y, f \llbracket x\rrbracket \llbracket (*~y~2)\rrbracket \mathtt{prim}_+~\mathtt{ap})))\\
  &=&
  (f, (x, (y, f~x \llbracket (*~y~2)\rrbracket \mathtt{prim}_+~\mathtt{ap})))\\
  &=&
  (f, (x, (y, f~x \llbracket y\rrbracket \llbracket 2\rrbracket \mathtt{prim}_*~\mathtt{prim}_+~\mathtt{ap})))\\
  &=&
  (f, (x, (y, f~x~y \llbracket 2\rrbracket \mathtt{prim}_*~\mathtt{prim}_+~\mathtt{ap})))\\
  &=&
  (f, (x, (y, f~x~y~2~\mathtt{prim}_*~\mathtt{prim}_+~\mathtt{ap})))\\
\end{eqnarray*}
%
Das Beispiel zeigt deutlich, wie der Rumpf der innersten Abstraktion
in eine lineare Folge von Instruktionen übersetzt wird, die genau der
Call-by-Value-Reduktionsstrategie entspricht: erst $f$ auswerten, dann
$x$, dann $y$, dann das Primitiv $*$ anwenden, dann $+$, und
schließlich die Applikation durchführen.

Nun zur eigentlichen SECD-Maschine~-- sie funktioniert ähnlich wie ein
Reduktionskalkül, operiert aber auf sogenannten
\textit{Maschinenzuständen}: die Maschine überführt also einen
Maschinenzustand durch einen Auswertungsschritt in einen neuen
Maschinenzustand.  Ein Maschinenzustand ist dabei ein 4-Tupel aus der
Menge $S\times E\times C\times D$ (daher der Name der Maschine).  Die
Buchstaben sind deshalb so gewählt, weil $S$ der sogenannte
\textit{Stack\index{Stack}}, $E$ die sogenannte
\textit{Umgebung\index{Umgebung}} beziehungsweise auf englisch das
\textit{Environment\index{Environment}}, $C$ der schon bekannte
Maschinencode beziehungsweise \textit{Code\index{Code}} und $D$ der
sogenannte \textit{Dump\index{Dump}} ist.  Die formalen Definitionen
dieser Mengen sind wie folgt; dabei ist $W$ die Menge der Werte:
%
\begin{eqnarray*}
  S &=& W^\ast\\
  E &=& \mathcal{P}(V\times W)\\
  D &=& (S\times E \times C)^\ast\\
  W &=& B \cup (V\times C\times E)
\end{eqnarray*}
%
Der Stack ist dabei eine Folge von Werten.  In der Maschine sind dies
die Werte der zuletzt ausgewerteten Terme, wobei der zuletzt
ausgewertete Term vorn beziehungsweise "<oben"> steht.  Die Umgebung ist eine
partielle Abbildung von Variablen auf Werte: sie ersetzt die
Substitution in der Reduktionsrelation des $\lambda$-Kalküls.  Anstatt
dass Werte für Variablen eingesetzt werden, merkt sich die Umgebung
einfach, an welche Werte die Variablen gebunden sind.  Erst wenn der
Wert einer Variablen benötigt wird, holt ihn die Maschine aus der
Umgebung.  Der Dump schließlich ist eine Liste früherer Zustände der
Maschine: er entspricht dem Kontext\index{Kontext} im
Substitutionsmodell.

Die Menge $W$ schließlich entspricht dem Wertebegriff aus
Definition~\ref{def:wert-angewandt}: Die Basiswerte gehören dazu,
außerdem Tripel aus $(V\times C\times E)$.  Ein solches Tripel,
genannt \textit{Closure\index{Closure}}~-- repräsentiert den Wert
einer Abstraktion~-- es besteht aus der Variable einer Abstraktion,
dem Maschinencode ihres Rumpfs und der Umgebung, die notwendig ist, um
die Abstraktion anzuwenden: Die Umgebung wird benötigt, damit die
freien Variablen der Abstraktion entsprechend der lexikalischen
Bindung\index{lexikalische Bindung} ausgewertet werden können.  Dies
ist anders als im Substitutionsmodell, wo Variablen bei der
Applikation direkt ersetzt werden und damit verschwinden.  Eine
Closure ist also einfach die Repräsentation einer Funktion.

Im Verlauf der Auswertung werden Umgebungen häufig um neue Bindungen
von einer Variable an einen Wert erweitert.  Dazu ist die Notation
$e[v\mapsto w]$ nützlich.  $e[v\mapsto w]$ konstruiert aus einer
Umgebung $e$ eine neue Umgebung, in der die Variable $v$ an den Wert
$w$ gebunden ist.  Hier ist die Definition:
%
\begin{displaymath}
  e[v\mapsto w] \deq (e \setminus \{ (v, w') | (v, w') \in e \}) \cup \{
    (v, w) \}
\end{displaymath}
%
Es wird also zunächst eine eventuell vorhandene alte Bindung entfernt
und dann eine neue hinzugefügt.

Um einen $\lambda$-Term $e$ in die SECD-Maschine zu "<injizieren">,
wird er in einen Anfangszustand $(\epsilon, \varnothing, \llbracket
e\rrbracket, \epsilon)$ übersetzt.  Dann wird dieser Zustand
wiederholt in die Zustandsübergangsrelation $\hookrightarrow$
gefüttert.  In der folgenden Definition von $\hookrightarrow$ sind
Bezeichner mit einem Unterstrich versehen, wenn es sich um Folgen
handelt, also z.B.\ \underline{s} für einen Stack:
%
\begin{eqnarray}
  \hookrightarrow &\in& \mathcal{P}((S\times E\times C\times D) \times (S\times E\times C\times D))\notag\\
  (\underline{s}, e, b\underline{c}, \underline{d})
  &\hookrightarrow& 
  (b\underline{s}, e, \underline{c}, \underline{d})
  \label{secd:base}
  \\
  (\underline{s}, e, v\underline{c}, \underline{d})
  &\hookrightarrow&
  (e(v)\underline{s}, e, \underline{c}, \underline{d})
  \label{secd:variable}
  \\
  (b_k\ldots b_1 \underline{s}, e, \mathtt{prim}_{F^k}\underline{c}, \underline{d})
  &\hookrightarrow&
  (b\underline{s}, e, \underline{c}, \underline{d})
  \label{secd:prim}
  \\ && \textrm{wobei $F^k\in\Sigma^k$ und $F^k_B(b_1,\ldots,b_k) = b$}\notag
  \\
  (\underline{s}, e, (v, \underline{c'}) \underline{c}, \underline{d})
  &\hookrightarrow&
  ((v, \underline{c'}, e) \underline{s}, e, \underline{c}, \underline{d})
  \label{secd:abstraction}
  \\
  (w (v,\underline{c'}, e') \underline{s}, e, \mathtt{ap}~\underline{c}, \underline{d})
  &\hookrightarrow&
  (\epsilon, e'[v\mapsto w], \underline{c'}, (\underline{s}, e, \underline{c}) \underline{d})
  \label{secd:app}
  \\
  (w, e, \epsilon, (\underline{s'}, e', \underline{c'}) \underline{d})
  &\hookrightarrow&
  (w\underline{s'}, e', \underline{c'}, \underline{d})
  \label{secd:return}
\end{eqnarray}
%
Die Regeln definieren eine Fallunterscheidung nach der ersten
Instruktion der Code"=Komponente des Zustands, beziehungsweise greift die letzte
Regel, wenn der Code leer ist.  Der Reihe nach arbeiten die Regeln wie
folgt:
%
\begin{itemize}
\item Regel~\ref{secd:base} (die
  \textit{Literalregel\index{Literalregel}}) schiebt einen Basiswert
  direkt auf den Stack.
\item Regel~\ref{secd:variable} (die
  \textit{Variablenregel\index{Variablenregel}}) ermittelt den Wert
  einer Variable aus der Umgebung und schiebt diesen auf den Stack.
\item Regel~\ref{secd:prim} ist die
  \textit{Primitivregel\index{Primitivregel}}.  Bei einer primitiven
  Applikation müssen soviele Basiswerte oben auf dem Stack liegen wie
  die Stelligkeit des Primitivs.  Dann ermittelt die Primitivregel das Ergebnis der
  primitiven Applikation und schiebt es oben auf den Stack.
\item Regel~\ref{secd:abstraction} ist die
  \textit{Abstraktionsregel\index{Abstraktionsregel}}: Das Tupel
  $(v,\underline{c'})$ ist bei der Übersetzung aus einer Abstraktion
  entstanden.  Die Regel ergänzt $v$ und $\underline{c'}$ mit
  $e$ zu einer Closure, die auf den Stack geschoben wird.
\item Regel~\ref{secd:app} ist die
  \textit{Applikationsregel\index{Applikationsregel}}: Bei einer
  Applikation müssen oben auf dem Stack ein Wert sowie eine Closure
  liegen.  (Zur Erinnerung: Eine Applikation kann nur ausgewertet
  werden, wenn eine Abstraktion vorliegt.  Abstraktionen werden zu
  Closures ausgewertet.)  In einem solchen Fall "<sichert"> die
  Applikation den aktuellen Zustand auf den Dump, und die Auswertung fährt mit
  einem leeren Stack, der Umgebung aus der Closure~-- erweitert um
  eine Bindung für die Variable~-- und dem Code aus der Closure fort.
\item Regel~\ref{secd:return} ist die
  \textit{Rückkehrregel\index{Rückkehrregel}}: Sie ist anwendbar,
  wenn das Ende des Codes erreicht ist.  Das heißt, dass gerade
  die Auswertung einer Applikation fertig ist.  Auf dem Dump liegt
  aber noch ein gesicherter Zustand, der jetzt "<zurückgeholt"> wird.
\end{itemize}
%
Hier ein Beispiel für den Ablauf der SECD-Maschine für den Term
$(((\lambda x.\lambda y.(+~x~y))~1)~2)$:
% (secd-step*/tex (inject-secd '(((lambda (x) (lambda (y) (+ x y))) 1) 2)))
%
\begin{displaymath}
  \begin{array}{l@{}llll}
&(\epsilon, &\varnothing, &(x, (y, x~y~\mathtt{prim}_+))~1~\mathtt{ap}~2~\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&((x, (y, x~y~\mathtt{prim}_+), \varnothing), &\varnothing, &1~\mathtt{ap}~2~\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&(1~(x, (y, x~y~\mathtt{prim}_+), \varnothing), &\varnothing, &\mathtt{ap}~2~\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&(\epsilon, &\{(x, 1)\}, &(y, x~y~\mathtt{prim}_+), &(\epsilon, \varnothing, 2~\mathtt{ap}))\\
\hookrightarrow{}&((y, x~y~\mathtt{prim}_+, \{(x, 1)\}), &\{(x, 1)\}, &\epsilon, &(\epsilon, \varnothing, 2~\mathtt{ap}))\\
\hookrightarrow{}&((y, x~y~\mathtt{prim}_+, \{(x, 1)\}), &\varnothing, &2~\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&(2~(y, x~y~\mathtt{prim}_+, \{(x, 1)\}), &\varnothing, &\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&(\epsilon, &\{(x, 1), (y, 2)\}, &x~y~\mathtt{prim}_+, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&(1, &\{(x, 1), (y, 2)\}, &y~\mathtt{prim}_+, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&(2~1, &\{(x, 1), (y, 2)\}, &\mathtt{prim}_+, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&(3, &\{(x, 1), (y, 2)\}, &\epsilon, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&(3, &\varnothing, &\epsilon, &\epsilon)
  \end{array}
\end{displaymath}
%
Die Zustandsübergangsrelation $\hookrightarrow$ ist nun die Grundlage
für die \textit{Auswertungsfunktion\index{Auswertungsfunktion}} der
SECD-Maschine, die für einen $\lambda$-Term dessen Bedeutung
ausrechnet.  Dies ist scheinbar ganz einfach:
%
\begin{eqnarray*}
  \mathit{eval}_\mathit{SECD} & : & \mathcal{L}_{\lambda{}A} \rightarrow B\\
  \mathit{eval}_\mathit{SECD}(e) &= & x \textrm{ wenn } (\epsilon, \varnothing, \llbracket e\rrbracket, \epsilon)
    \hookrightarrow^* (x, e, \epsilon, \epsilon)
\end{eqnarray*}
%
Diese Definition hat jedoch zwei Haken:
%
\begin{itemize}
\item Die Auswertung von $\lambda$-Termen terminiert nicht immer (wie
  zum Beispiel für den "<Endlos"=Term"> $(\lambda x.(x~x))~(\lambda x.(x~x))$), es kommt
  also nicht immer dazu, dass die Zustandsübergangsrelation bei einem
  Zustand der Form $(\epsilon, \varnothing, \llbracket e\rrbracket,
  \epsilon)$ terminiert.
\item Das $x$ aus dieser Definition ist nicht immer ein Basiswert~--
  es kann auch eine Closure sein.
\end{itemize}
%
Der erste Haken sorgt dafür, dass die Auswertungsfunktion nur eine
Relation im Sinne einer "<partiellen Funktion"> ist.  Meist wird
trotzdem von einer Auswertungsfunktion gesprochen.  Beim zweiten
Haken, wenn $x$ eine Closure ist, lässt sich mit dem Resultat nicht
viel anfangen: Um die genaue Bedeutung der Closure herauszubekommen,
müsste sie angewendet werden~-- das Programm ist aber schon fertig
gelaufen.  Es ist also gar nicht sinnvoll, zwischen verschiedenen
Closures zu unterscheiden.  Darum wird für die Zwecke der
Auswertungsfunktion eine Menge $Z$ der \textit{Antworten\index{Antwort}}
definiert, die einen designierten Spezialwert für Closures enthält:
%
\begin{displaymath}
  Z = B \cup \{ \texttt{function} \}
\end{displaymath}
%
Damit lässt sich die Evaluationsfunktion wie folgt definieren:
%
\begin{eqnarray*}
  \mathit{eval}_\mathit{SECD} & \in & \mathcal{L}_{\lambda{}A} \times Z\\
  \mathit{eval}_\mathit{SECD}(e) & = &
  \begin{cases}
    b & \textrm{falls } (\epsilon, \varnothing, \llbracket e\rrbracket, \epsilon)
    \hookrightarrow^* (b, e, \epsilon, \epsilon)\\
    \texttt{function} & \textrm{falls } (\epsilon, \varnothing, \llbracket e\rrbracket, \epsilon)
    \hookrightarrow^* ((v, \underline{c}, e'), e, \epsilon, \epsilon)\\
  \end{cases}
\end{eqnarray*}

\section{\texttt{Quote} und Symbole}
\label{sec:quote}

Dieses Kapitel wird ab hier Gebrauch von einer weiteren
Sprachebene\index{Sprachebene!fortgeschritten} in
\drscheme{} machen, nämlich \texttt{Die Macht der Abstraktion -
  fortgeschritten}.  Diese Ebene muss mit dem \drscheme{}-Menü \texttt{Sprache}
unter \texttt{Sprache auswählen} aktiviert sein, damit die
Programme dieses Kapitels funktionieren.

Die entscheidende Änderung gegenüber den früheren Sprachebenen ist
die Art, mit der die REPL Werte ausdruckt.  (Diese neue Schreibweise,
ermöglicht, die Programme des Interpreters, die als Werte
repräsentiert sind, korrekt auszudrucken.)  Bei Zahlen, Zeichenketten
und booleschen Werten bleibt alles beim alten:
%
\begin{lstlisting}
5
|\evalsto| 5
"Mike ist doof"
|\evalsto| "Mike ist doof"
#t
|\evalsto| #t
\end{lstlisting}
%
Bei Listen sieht es allerdings anders aus:
%
\begin{lstlisting}
(list 1 2 3 4 5 6)
|\evalsto| (1 2 3 4 5 6)
\end{lstlisting}
%
Die REPL druckt also eine Liste aus, indem sie zuerst eine öffnende
Klammer ausdruckt, dann die Listenelemente (durch Leerzeichen
getrennt) und dann eine schließende Klammer.

Das funktioniert auch für die leere Liste:
%
\begin{lstlisting}
empty
|\evalsto| ()
\end{lstlisting}
%
Mit der neuen Sprachebene bekommt außerdem der Apostroph, der dem
Literal\index{Literal} für die leere Liste voransteht, eine erweiterte Bedeutung.
Unter anderem kann der Apostroph benutzt werden, um Literale für
Listen zu formulieren:
%
\begin{lstlisting}
'(1 2 3 4 5 6)
|\evalsto| (1 2 3 4 5 6)
'(1 #t "Mike" (2 3) "doof" 4 #f 17)
|\evalsto| (1 #t "Mike" (2 3) "doof" 4 #f 17)
'()
|\evalsto| ()
\end{lstlisting}
%
In der neuen Sprachebene benutzen die Literale und die ausgedruckten
externen Repräsentationen für Listen also die gleiche
Notation\index{Repräsentation}.  Sie unterscheiden sich nur dadurch,
dass beim Literal der Apostroph voransteht.  Der Apostroph funktioniert
auch bei Zahlen, Zeichenketten und booleschen Werten:
%
\begin{lstlisting}
'5
|\evalsto| 5
'"Mike ist doof"
|\evalsto| "Mike ist doof"
'#t
|\evalsto| #t
\end{lstlisting}
%
Der Apostroph am Anfang eines Ausdrucks
kennzeichnet diesen also als Literal.  Der Wert des Literals wird 
genauso ausgedruckt, wie es im Programm steht.  (Abgesehen von
Leerzeichen und Zeilenumbrüchen.)  Der Apostroph heißt auf englisch
"<quote">\index{quote@\lstinline{quote}}, und deshalb ist diese
Literalschreibweise auch unter diesem Namen bekannt.  Bei Zahlen,
Zeichenketten und booleschen Literalen ist auch ohne Quote klar, dass
es sich um Literale handelt.  Das Quote ist darum bei ihnen rein
optional; sie heißen 
\textit{selbstquotierend}\index{selbstquotierend}.
Bei Listen hingegen sind Missverständnisse mit anderen
zusammengesetzten Formen möglich, die ja auch mit einer öffnenden Klammer
beginnen: \footnote{Tatsächlich ist die neue Schreibweise für externe
  Repräsentationen die Standard-Repräsentation in Scheme.  Die
  früheren Sprachebenen benutzten die alternative Schreibweise, um die
  Verwirrung zwischen Listenliteralen und zusammengesetzten Formen zu
  vermeiden.}
\begin{lstlisting}
(1 2 3 4 5 6)
|\evalsto| function application: expected function, given: 1;
     arguments were: 2 3 4 5 6
\end{lstlisting}
%
Mit der Einführung von Quote kommt noch eine völlig neue Sorte Werte
hinzu: die \textit{Symbole\index{Symbol}}.  Symbole sind Werte ähnlich wie Zeichenketten und
bestehen aus Text.  Sie unterscheiden sich allerdings dadurch, dass sie
als Literal mit Quote geschrieben und in der REPL ohne
Anführungszeichen ausgedruckt werden:
%
\begin{lstlisting}
'mike
|\evalsto| mike
'doof
|\evalsto| doof
\end{lstlisting}
%
Symbole lassen sich mit dem Prädikat
\lstinline{symbol?}\index{symbol@\texttt{symbol?}} von anderen Werten
unterscheiden:
%
\begin{lstlisting}
(symbol? 'mike)
|\evalsto| #t
(symbol? 5)
|\evalsto| #f
(symbol? "Mike")
|\evalsto| #f
\end{lstlisting}
%
Vergleichen lassen sich Symbole mit \lstinline{equal?} (siehe
Abbildung~\ref{scheme:equalp}):

\begin{lstlisting}
(equal? 'mike 'herb)
|\evalsto| #f
(equal? 'mike 'mike)
|\evalsto| #t
\end{lstlisting}

Symbole können nicht aus beliebigem Text bestehen.  
Leerzeichen sind zum Beispiel verboten.  Tatsächlich entsprechen die
Namen der zulässigen Symbole genau den Namen von Variablen:
%
\begin{lstlisting}
'karl-otto
|\evalsto| karl-otto
'mehrwertsteuer
|\evalsto| mehrwertsteuer
'duftmarke
|\evalsto| duftmarke
'lambda
|\evalsto| lambda
'+
|\evalsto| +
'*
|\evalsto| *
\end{lstlisting}
%
Diese Entsprechung wird in diesem Kapitel noch eine entscheidene Rolle
spielen.  Symbole können natürlich auch in Listen und damit auch in
Listenliteralen vorkommen:
%
\begin{lstlisting}
'(karl-otto mehrwertsteuer duftmarke)
|\evalsto| (karl-otto mehrwertsteuer duftmarke)
\end{lstlisting}
%
Mit Hilfe von Symbolen können Werte konstruiert werden, die in der REPL
ausgedruckt wie Ausdrücke aussehen:
%
\begin{lstlisting}
'(+ 1 2)
|\evalsto| (+ 1 2)
'(lambda (n) (+ n 1))
|\evalsto| (lambda (n) (+ n 1))
\end{lstlisting}
%
Auch wenn diese Werte wie Ausdrücke so aussehen, sind sie doch ganz
normale Listen: der Wert von \verb|'(+ 1 2)| ist eine Liste mit drei
Elementen: das Symbol \verb|+|, die Zahl \lstinline{1} und die Zahl
\lstinline{2}.  Der Wert von \verb|'(lambda (n) (+ n 1))| ist ebenfalls
eine Liste mit drei Elementen: das Symbol \verb|lambda|, eine Liste
mit einem einzelnen Element, nämlich dem Symbol \lstinline{n}, und einer
weiteren Liste mit drei Elementen: dem Symbol \lstinline{+}, dem Symbol
\lstinline{n} und der Zahl \lstinline{1}.

Quote hat noch eine weitere verwirrende Eigenheit:
%
\begin{lstlisting}
''()
|\evalsto| '()
\end{lstlisting}
%
Dieses Literal bezeichnet nicht die leere Liste (dann würde nur
\lstinline{()} ausgedruckt, ohne Quote), sondern etwas anderes:
%
\begin{lstlisting}
(cons? ''())
|\evalsto| #t
(first ''())
|\evalsto| quote
(rest ''())
|\evalsto| (())
\end{lstlisting}
%
Der Wert des Ausdrucks \verb|''()| ist also eine Liste mit zwei
Elementen: das erste Element ist das Symbol \lstinline{quote} und das
zweite Element ist die leere Liste.  \lstinline{'$t$}
ist selbst also nur syntaktischer Zucker, und zwar für
\lstinline{(quote $t$)}:
%
\begin{lstlisting}
(equal? (quote ()) '())
|\evalsto| #t
(equal? (quote (quote ())) ''())
|\evalsto| #t
\end{lstlisting}
%
Quote erlaubt die Konstruktion von Literalen für viele Werte, aber
nicht für alle.  Ein Wert, für den Quote ein Literal konstruieren kann,
heißt \textit{repräsentierbarer
  Wert\index{repräsentierbarer Wert}}.  Die folgende induktive
Definition spezifiziert, was ein repräsentierbarer Wert ist:
%
\begin{itemize}
\item Zahlen, boolesche Werte, Zeichenketten und Symbole sind
  repräsentierbare Werte.
\item Eine Liste aus repräsentierbaren Werten ist ihrerseits ein
  repräsentierbarer Wert. 
\item Nichts sonst ist ein repräsentierbarer Wert.
\end{itemize}

\section{Implementierung der SECD-Maschine}

Die SECD-Maschine ist ein Modell für die Implementierung des
$\lambda$-Kalküls.  Eine solche Implementierung lässt sich in
einfach bauen~-- dieser Abschnitt zeigt, wie.  Der grobe
Fahrplan ergibt sich dabei aus der Struktur der SECD-Maschine selbst:
Nach den obligatorischen Datendefinitionen müssen zunächst Terme in
Maschinencode übersetzt werden.  Dann kommt die
Zustandsübergangsfunktion und schließlich die Auswertungsfunktion an
die Reihe.

\subsection{Datenanalyse}
\label{sec:secd-datenanalyse}

Die erste Aufgabe ist dabei zunächst, wie immer, die Datenanalyse: Am
Anfang stehen die Terme des angewandten $\lambda$-Kalküls.  Eine
geeignete Repräsentation mit Listen und Symbolen lässt dabei die Terme
in der "<fortgeschrittenen"> Sprachebene genau wie entsprechenden
Programm-Terme aussehen:

\noindent\begin{tabular}{lll}
  \texttt{(+ 1 2)} & steht für & $(+~1~2)$\\
  \texttt{(lambda (x) x)} & steht für & $\lambda \lrm x.\lrm x$\\
  \texttt{((lambda (x) (x x)) (lambda (x) (x x)))} & steht für &
  $(\lambda \lrm x.(\lrm x~\lrm x))~(\lambda \lrm x.(\lrm x~\lrm x))$\\
  etc.
\end{tabular}

Die Datendefinition dafür orientiert sich direkt an
Definition~\ref{def:lambda-angewandt}:
%
\begin{lstlisting}
; Ein Lambda-Term ist eins der folgenden:
; - ein Symbol (für eine Variable)
; - eine zweielementige Liste (für eine reguläre Applikation)
; - eine Liste der Form (lambda (x) e) (für eine Abstraktion)
; - ein Basiswert
; - eine Liste mit einem Primitiv als erstem Element
;      (für eine primitive Applikation)
\end{lstlisting}
%
Hier die dazu passende Signatur-Definition:
%
\begin{lstlisting}
(define term
  (signature
    (mixed symbol
           application
           abstraction
           base
           primitive-application)))
\end{lstlisting}
%
Die Signaturen für \lstinline{application} etc.\ müssen noch definiert
werden.

Um Verzweigungen über die Sorte \lstinline{term} zu ermöglichen, müssen
Prädikate für die einzelnen Teilsorten geschrieben werden.  Diese
können dann für die Definition der entsprechenden Signaturen benutzt
werden.
%
\begin{lstlisting}
; Prädikat für reguläre Applikationen
(: application? (any -> boolean))
(define application?
  (lambda (term)
    (and (cons? term)
         (not (equal? 'lambda (first term)))
         (not (primitive? (first term))))))

(define application (signature (predicate application?)))

; Prädikat für Abstraktionen
(: abstraction? (any -> boolean))
(define abstraction?
  (lambda (term)
    (and (cons? term)
         (equal? 'lambda (first term)))))

(define abstraction (signature (predicate abstraction?)))

; Prädikat für primitive Applikationen
(: primitive-application? (any -> boolean))
(define primitive-application?
  (lambda (term)
    (and (cons? term)
         (primitive? (first term)))))

(define primitive-application (signature (predicate primitive-application?)))
\end{lstlisting}
%
Die Definition lässt noch offen, was genau ein "<Basiswert"> und was ein
"<Primitiv"> ist.  Auch hierfür werden noch Datendefinitionen
benötigt, zuerst für Basiswerte.  Der Einfachheit halber beschränkt
sich die Implementierung erst einmal auf boolesche Werte und Zahlen:
%
\begin{lstlisting}
; Ein Basiswert ist ein boolescher Wert oder eine Zahl
\end{lstlisting}
%
Damit Basiswerte in Fallunterscheidungen von den anderen Arten von
Termen unterschieden werden können, wird ein Prädikat benötigt:
%
\begin{lstlisting}
; Prädikat für Basiswerte
(: base? (any -> boolean))
(define base?
  (lambda (term)
    (or (boolean? term) (number? term))))

(define base (signature (predicate base?)))
\end{lstlisting}
%
Als Nächstes sind Primitive gefragt: Am obigen Beispiel ist zu
erkennen, dass zum Beispiel \lstinline{+} ein Primitiv sein sollte.  Die
Datendefinition für eine kleine beispielhafte Menge von Primitiven ist
wie folgt:
%
\begin{lstlisting}
; Ein Primitiv ist eins der Symbole +, -, *, /, =
\end{lstlisting}
%
Da die Primitive genau wie die Variablen Symbole sind, stehen die
Primitive als Variablen nicht mehr zur Verfügung:  Alle Symbole, die
keine Primitive sind, sind also Variablen.  Das dazugehörige Prädikat
ist das folgende:
%
\begin{lstlisting}
; Prädikat für Primitive
(: primitive? (any -> boolean))
(define primitive?
  (lambda (term)
    (or (equal? '+ term)
        (equal? '- term)
        (equal? '* term)
        (equal? '/ term)
        (equal? '= term))))

(define primitive (signature (predicate primitive?)))
\end{lstlisting}
%
Bevor nun ein die SECD-Maschine einen Term verarbeiten kann, muss
dieser erst in Maschinencode übersetzt werden.  Dabei entsteht aus
Definition~\ref{def:secd-code} direkt Daten- und Signatur-Definitionen
für Instruktionen und Maschinencode:
%
\begin{lstlisting}
; Eine Instruktion ist eins der folgenden:
; - ein Basiswert
; - eine Variable
; - eine Applikations-Instruktion
; - eine Instruktion für eine primitive Applikation
; - eine Abstraktion
(define instruction
  (signature
    (mixed base
           symbol
           ap
           tailap
           prim
           abs))

; Eine Maschinencode-Programm ist eine Liste von Instruktionen.
(define machine-code (signature (list-of instruction)))
\end{lstlisting}
%
Bei der Definition von Instruktionen ist wieder einiges Wunschdenken
im Spiel.  Basiswerte und Variablen sind wie bei den Termen.  Die
restlichen Fälle werden durch eigene Datendefinitionen abgebildet.
Wie schon bei den leeren Bäumen sind Record-Definitionen ohne Felder
im Spiel, die Fallunterscheidungen möglich machen:
%
\begin{lstlisting}
; Eine Applikations-Instruktion ist ein Wert
;   (make-ap)
(define-record ap
  make-ap ap?)
(: make-ap (-> ap))

; Die Instruktion für eine primitive Applikation
; ist ein Wert
;   (real-make-prim op arity)
; wobei op ein Symbol und arity die Stelligkeit
; ist
(define-record prim
  real-make-prim prim?
  (prim-operator symbol)
  (prim-arity natural))

; Eine Abstraktions-Instruktion ist ein Wert
;  (make-abs v c)
; wobei v ein Symbol (für eine Variable) und c
; Maschinencode ist
(define-record abst
  make-abs abs?
  (abs-variable symbol)
  (abs-code machine-code))
\end{lstlisting}
%
Da die Stelligkeit eines Primitivs dem Primitiv fest zugeordnet
ist, ist eine Hilfsfunktion nützlich, die bei der Erzeugung eines
Werts der Sorte \lstinline{prim} die Stelligkeit ergänzt.
Glücklicherweise haben alle oben eingeführten Primitive die gleiche
Stelligkeit:  FIXME
%
\begin{lstlisting}
; Primitiv erzeugen
(: make-prim (symbol -> prim))
(define make-prim
  (lambda (operator)
    (real-make-prim operator 2))) ; alle haben derzeit Stelligkeit 2
\end{lstlisting}
%
Die Einführung von Primitive mit anderen Stelligkeiten ist Gegenstand
von Aufgabe~\ref{aufgabe:prim-arity}.

\subsection{Übersetzung in Maschinencode}

Nun, da sowohl Terme als auch der Maschinencode Datendefinitionen
haben, ist es möglich, die Übersetzung zu programmieren.  Hier sind
Kurzbeschreibung, Signatur und Gerüst:
%
\begin{lstlisting}
; Term in Maschinencode übersetzen
(: term->machine-code (term -> machine-code))
(define term->machine-code
  (lambda (term)
    ...))
\end{lstlisting}
%
Da es sich bei \lstinline{term} um gemischte Daten handelt, muss~-- wie
immer~-- eine Verzweigung den Rumpf der Funktion bilden:
%
\begin{lstlisting}
(define term->machine-code
  (lambda (term)
    (cond
      ((symbol? term) ...)
      ((application? term) ...)
      ((abstraction? term) ...)
      ((base? term) ...)
      ((primitive-application? term) ...))))
\end{lstlisting}
%
Die Implementierung entspricht in den einzelnen Fällen genau der
Übersetzungsfunktion $\llbracket\underline{~}\rrbracket$. Die Fälle
für Variablen und Basiswerte sind, genau wie dort, trivial:
%
\begin{lstlisting}
(define term->machine-code
  (lambda (term)
    (cond
      ((symbol? term) (list term))
      ((base? term) (list term))
      ...)))
\end{lstlisting}
%
Bei regulären Applikationen werden
Operator und Operand übersetzt, und das ganze zusammen mit einer
\lstinline{ap}-Instruktion zu einer Liste zusammengesetzt:
%
\begin{lstlisting}
(define term->machine-code
  (lambda (term)
    (cond
      ...
      ((application? term)
       (append (term->machine-code (first term))
               (append (term->machine-code (first (rest term)))
                       (list (make-ap)))))
      ...)))
\end{lstlisting}
%
Bei den primitiven Applikationen werden erst einmal die Operanden in
Maschinencode übersetzt, die Resultate aneinandergehängt, und
schließlich kommt noch eine \lstinline{prim}-Instruktion ans Ende:
%
\begin{lstlisting}
(define term->machine-code
  (lambda (term)
    (cond
      ...
      ((primitive-application? term)
       (append
        (append-lists
         (map term->machine-code (rest term)))
        (list (make-prim (first term)))))
      ...)))
\end{lstlisting}
%
Dieses Stück Code benutzt die Hilfsfunktion \lstinline{append-lists}, die
aus einer Liste von Listen eine einzelne Liste macht, indem die
Elemente aneinandergehängt werden:
%
\begin{lstlisting}
; die Elemente einer Liste von Listen aneinanderhängen
(: append-lists ((list-of (list-of %a)) -> (list-of %a)))
(define append-lists
  (lambda (list)
    (fold '() append list)))
\end{lstlisting}
%
Zurück zur Übersetzung: Eine Abstraktionen wird direkt in eine
\lstinline{abs}-Instruktion übersetzt, wobei der Rumpf selbst
noch in Maschinencode übersetzt wird:
%
\begin{lstlisting}
(define term->machine-code
  (lambda (term)
    (cond
      ...
      ((abstraction? term)
       (list
        (make-abs (first (first (rest term)))
                  (term->machine-code
                   (first (rest (rest term))))))))))
\end{lstlisting}
%

\subsection{Zustandsübergang und Auswertung}
\label{sec:secd-transition}

Da nun alle $\lambda$-Terme in Maschinencode-Programme übersetzt
werden können, ist jetzt die eigentliche SECD-Maschine an der Reihe.
Hier sind erst einmal einige neue Datendefinitionen fällig.  Zunächst
einmal die Menge $S$ der Stacks:
%
\begin{lstlisting}
; Ein Stack ist eine Liste von Werten
(define stack (signature (list-of value)))
\end{lstlisting}
%
Die Definition von Werten $W$ kommt etwas später an die Reihe.

Umgebungen aus der Menge $E$ sind mathematisch gesehen Mengen aus
Tupeln.  In der Implementierung werden sie dargestellt aus Listen von
\textit{Bindungen\index{Bindung}}, wobei jede Bindung einem Tupel aus
der mathematischen Definition entspricht:

\begin{lstlisting}
; Eine Umgebung ist eine Liste von Bindungen.
; Dabei gibt es für jede Variable nur eine Bindung.
(define environment (signature (list-of binding)))

; Eine Bindung (Name: binding) ist ein Wert
;  (make-binding v x)
; wobei v der Name einer Variablen und x der dazugehörige Wert ist.

(define-record binding
  make-binding binding?
  (binding-variable symbol)
  (binding-value value))
\end{lstlisting}
% 
Die leere Umgebung wird öfter benötigt und wird darum schon
vordefiniert:
%
\begin{lstlisting}
; die leere Umgebung
(define the-empty-environment empty)
\end{lstlisting}
%
Zwei Operationen gibt es für eine Umgebung $e$: die Erweiterung um
eine Bindung $e[v\mapsto w]$ und das Nachschauen einer Bindung
$e(v)$.  Zunächst die Erweiterung: die Implementierung entspricht
genau der mathematischen Definition: zunächst wird eine eventuell
vorhandene Bindung für $v$ entfernt, dann eine neue Bindung
hinzugefügt:
% 
\begin{lstlisting}
; eine Umgebung um eine Bindung erweitern
(: extend-environment (environment symbol value -> environment))
(define extend-environment
  (lambda (environment variable value)
    (cons (make-binding variable value)
          (remove-environment-binding environment variable))))
\end{lstlisting}
%
Für das Entfernen der alten Bindung ist die Hilfsfunktion
\lstinline{remove-environment-binding} zuständig.  Sie folgt einmal mehr
strikt der Konstruktionsanleitung für Funktionen, die Listen akzeptieren:
% FIXME: Konstruktionsanleitung
\begin{lstlisting}
; die Bindung für eine Variable aus einer Umgebung entfernen
(: remove-environment-binding (environment symbol -> environment))
(define remove-environment-binding
  (lambda (environment variable)
    (cond
      ((empty? environment) empty)
      ((cons? environment)
       (if (equal? variable (binding-variable (first environment)))
           (rest environment)
           (cons (first environment)
                 (remove-environment-binding (rest environment) variable)))))))
\end{lstlisting} 
%
Auch die zweite Operation, das Nachschauen einer Bindung in der
Umgebung, folgt der Konstruktionsanleitung:
%
% FIXME: Konstruktionsanleitung
%
\begin{lstlisting}
; die Bindung für eine Variable in einer Umgebung finden
(: lookup-environment (environment symbol -> value))
(define lookup-environment
  (lambda (environment variable)
    (cond
      ((empty? environment) (violation "unbound variable"))
      ((cons? environment)
       (if (equal? variable (binding-variable (first environment)))
           (binding-value (first environment))
           (lookup-environment (rest environment) variable))))))
\end{lstlisting}
%
Damit sind die Operationen auf Umgebungen abgeschlossen.  Als Nächstes
sind Dumps an der Reihe: $D$ ist als Folge von Tupeln $S\times E\times
C$ definiert, auch genannt \textit{Frames\index{Frame}}.  Hier sind
Daten- und Record-Definition:
%
\begin{lstlisting}
; Ein Dump ist eine Liste von Frames

; Ein Frame ist ein Wert
;  (make-frame s e c)
; wobei s ein Stack, e eine Umgebung und c Maschinencode ist.
(define-record frame
  make-frame frame?
  (frame-stack stack)
  (frame-environment environment)
  (frame-code machine-code))
\end{lstlisting}
%
Schließlich fehlt noch eine Repräsentation für die Menge $W$ der
Werte:  Ein Wert ist entweder ein Basiswert oder eine Closure.
Basiswerte wurden bereits in Abschnitt~\ref{sec:secd-datenanalyse}
definiert; es fehlen noch Closures, die Tupel aus $V\times C\times E$
sind.  Hier sind die entsprechenden Definitionen:
%
\begin{lstlisting}
; Ein SECD-Wert ist ein Basiswert oder eine Closure
(define value (signature (mixed base closure)))

; Eine Closure ist ein Wert
;  (make-closure v c e)
; wobei v die Variable der Lambda-Abstraktion,
; c der Code der Lambda-Abstraktion
; und e ein Environment ist.
(define-record closure
  make-closure closure?
  (closure-variable symbol)
  (closure-code machine-code)
  (closure-environment environment))
\end{lstlisting}
%
Mit Hilfe dieser Definitionen ist es möglich, eine Daten- und eine
Record-Definition für die Zustände der SECD-Maschine anzugeben, also
die Tupel aus $S\times E\times C\times D$:
%
\begin{lstlisting}
; Ein SECD-Zustand ist ein Wert
;  (make-secd s e c d)
; wobei s ein Stack, e eine Umgebung, c Maschinencode
; und d ein Dump ist
(define-record secd
  make-secd secd?
  (secd-stack stack)
  (secd-environment environment)
  (secd-code machine-code)
  (secd-dump dump))
\end{lstlisting}
%
Damit kann es an die Zustandsübergangsfunktion gehen.   Sie wird als
Funktion realisiert, die einen SECD-Zustand akzeptiert und einen neuen
liefert.  Hier sind Kurzbeschreibung, Signatur und Gerüst:
%
\begin{lstlisting}
; Zustandsübergang berechnen
(: secd-step (secd -> secd))
(define secd-step
  (lambda (state)
    ...))
\end{lstlisting}
%
Entsprechend den Regeln der SECD-Maschine muss der Rumpf der Funktion
eine Verzeigung zwischen den verschiedenen Fällen bei der
Code-Komponente von \lstinline{state} sein.  Diese folgen den
Konstruktionsanleitungen für Listen und für gemischte Daten.  Es ist
bereits an den Regeln abzulesen, dass alle Regeln Zugriff auf die
Komponenten von \lstinline{state} benötigen.  Für diese werden gleich am
Anfang lokale Variablen angelegt:
%
\begin{lstlisting}
(define secd-step
  (lambda (state)
    (define stack (secd-stack state))
    (define environment (secd-environment state))
    (define code (secd-code state))
    (define dump (secd-dump state))
    (cond
      ((cons? code)
       (cond
         ((base? (first code)) ...)
         ((symbol? (first code)) ...)
         ((prim? (first code)) ...)
         ((abs? (first code)) ...)
         ((ap? (first code)) ...)))
      ((empty? code) ...))))
\end{lstlisting}
%
In diesem Gerüst werden nun die Regeln direkt abgebildet.  Hier zur
Erinnerung noch einmal die erste Regel für Basiswerte:
%
\begin{displaymath}
  (\underline{s}, e, b\underline{c}, \underline{d})
  \hookrightarrow
  (b\underline{s}, e, \underline{c}, \underline{d})
\end{displaymath}
%
Hier der passende Code dafür:
%
\begin{lstlisting}
(define secd-step
  (lambda (state)
      ...
        (cond
          ((base? (first code))
           (make-secd (cons (first code) stack)
                      environment
                      (rest code)
                      dump))
           ...)
      ...))
\end{lstlisting}
%
Hier die Regel für Variablen:
\begin{displaymath}
  (\underline{s}, e, v\underline{c}, \underline{d})
  \hookrightarrow
  (e(v)\underline{s}, e, \underline{c}, \underline{d})
\end{displaymath}
%
Hier der entsprechende Code:
%
\begin{lstlisting}
(define secd-step
  (lambda (state)
      ...
        (cond
          ((symbol? (first code))
           (make-secd (cons
                        (lookup-environment environment (first code))
                        stack)
                      environment
                      (rest code)
                      dump))
          ...)
      ...))
\end{lstlisting}
%
Die Regel für primitive Applikationen ist etwas aufwendiger:
%
\begin{eqnarray*}
  (b_k\ldots b_1 \underline{s}, e, \mathtt{prim}_{F^k}\underline{c}, \underline{d})
  &\hookrightarrow&
  (b\underline{s}, e, \underline{c}, \underline{d})
  \\ && \textrm{wobei $F^k\in\Sigma^k$ und $F_B(b_1,\ldots,b_k) = b$}
\end{eqnarray*}
%
Für die Implementierung werden Hilfsfunktionen gebraucht, welche die
Argumente vom Stack holen und in der Reihenfolge umdrehen, die
Argumente vom Stack entfernen und schließlich die eigentliche
$\delta$-Transition berechnen:
%
\begin{lstlisting}
(define secd-step
  (lambda (state)
      ...
        (cond
          ...
          ((prim? (first code))
           (make-secd (cons
                       (apply-primitive
                         (prim-operator (first code))
                         (take-reverse (prim-arity (first code)) stack))
                       (drop (prim-arity (first code)) stack))
                      environment
                      (rest code)
                      dump))
           ...)
       ...))
\end{lstlisting}
%
Die Funktion \lstinline{drop} ist gerade die in
Aufgabe~\ref{ex:drop} auf Seite~\pageref{ex:drop} geforderte Funktion:
%
\begin{lstlisting}
; die ersten Elemente einer Liste weglassen
(: drop (natural (list-of %a) -> (list-of %a)))
\end{lstlisting}
%
Die \lstinline{take-reverse}-Funktion ist das Pendant zu \lstinline{drop},
das die ersten $n$ Elemente einer Liste in umgekehrter Reihenfolge
liefert.  Dies ist am einfachsten über eine endrekursive Hilfsfunktion
zu erledigen~-- aus Kapitel~\ref{cha:accu} ist ja bekannt, dass bei
endrekursiver Konstruktion von Listen gerade immer die Reihenfolge
umgedreht wird:
%
\begin{lstlisting}
; die ersten Elemente einer Liste in umgekehrter Reihenfolge berechnen
(: take-reverse (natural (list-of %a) -> (list-of %a)))

(check-expect (take-reverse 2 '(1 2 3 4 5)) '(2 1))
(check-expect (take-reverse 0 '(1 2 3 4 5)) '())
(check-expect (take-reverse 5 '(1 2 3 4 5)) '(5 4 3 2 1))

(define take-reverse
  (lambda (n list0)
    ;; (: loop (natural (list-of a) (list-of a) -> (list-of a)))
    (define accumulate
      (lambda (n list acc)
        (cond
          ((zero? n) acc)
          ((positive? n)
           (accumulate (- n 1) (rest list) (cons (first list) acc))))))
    (accumulate n list0 '())))
\end{lstlisting}
%
Aus einem Primitiv und einer Liste von Argumenten berechnet
\lstinline{apply-primitive} das Resultat der primitiven Applikation.
Dabei handelt es sich bei \lstinline{primitive} um eine
Fallunterscheidung, der Rumpf der Funktion ist also eine entsprechende
Verzweigung:
%
\begin{lstlisting}
; Delta-Transition berechnen
(: apply-primitive (primitive (list-of value) -> value))

(check-expect (apply-primitive '+ '(1 2)) 3)
(check-expect (apply-primitive '- '(2 1)) 1)

(define apply-primitive
  (lambda (primitive args)
    (cond
      ((equal? primitive '+)
       (+ (first args) (first (rest args))))
      ((equal? primitive '-)
       (- (first args) (first (rest args))))
      ((equal? primitive '=)
       (= (first args) (first (rest args))))
      ((equal? primitive '*)
       (* (first args) (first (rest args))))
      ((equal? primitive '/)
       (/ (first args) (first (rest args)))))))
\end{lstlisting}
%
Die Regel für Abstraktionen macht aus einer Abstraktion eine Closure:
\begin{displaymath}
  (\underline{s}, e, (v, \underline{c'}) \underline{c}, \underline{d})
  \hookrightarrow
  ((v, \underline{c'}, e) \underline{s}, e, \underline{c}, \underline{d})
\end{displaymath}
%
Der Code macht dies genauso:
%
\begin{lstlisting}
(define secd-step
  (lambda (state)
      ...
        (cond
          ...
          ((abs? (first code))
           (make-secd (cons
                        (make-closure (abs-variable (first code))
                                      (abs-code (first code))
                                      environment)
                        stack)
                      environment
                      (rest code)
                      dump)))
       ...)))
\end{lstlisting}
%
Hier die Regel für die Applikation:
%
\begin{displaymath}
  (w (v,\underline{c'}, e') \underline{s}, e, \mathtt{ap}~\underline{c}, \underline{d})
  \hookrightarrow
  (\epsilon, e'[v\mapsto w], \underline{c'}, (\underline{s}, e, \underline{c}) \underline{d})
\end{displaymath}
%
Hier der Code dazu:
%
\begin{lstlisting}
(define secd-step
  (lambda (state)
      ...
        (cond
          ...
         ((ap? (first code))
          (define closure (first (rest stack)))
          (make-secd empty  
                     (extend-environment
                      (closure-environment closure)
                      (closure-variable closure)
                      (first stack))
                     (closure-code closure)
                     (cons
                      (make-frame (rest (rest stack)) environment (rest code))
                      dump)))
          ...)
      ...))
\end{lstlisting}
%
Schließlich bleibt noch der Code für die Rückgabe eines Wertes von
einer Funktion.  Hier ist die Regel:
%
\begin{displaymath}
  (w, e, \epsilon, (\underline{s'}, e', \underline{c'}) \underline{d})
  \hookrightarrow
  (w\underline{s'}, e', \underline{c'}, \underline{d})
\end{displaymath}
%
Hier ist der Code dazu:
%
\begin{lstlisting}
(define secd-step
  (lambda (state)
      ...
      (cond
        ...
      ((empty? code)
       (define frame (first dump))
       (make-secd
        (cons (first stack)
              (frame-stack frame))
        (frame-environment frame)
        (frame-code frame)
        (rest dump))))
       ...))
\end{lstlisting}
%
Damit die SECD-Maschine in Betrieb genommen werden kann, muss ein Term
$e$ noch in einen Anfangszustand $(\epsilon, \varnothing, \llbracket
e\rrbracket, \epsilon)$ übersetzt werden.  Das erledigt folgende
Hilfsfunktion:
%
\begin{lstlisting}
; Aus Term SECD-Anfangszustand machen
(: inject-secd (term -> secd))
(define inject-secd
  (lambda (term)
    (make-secd empty
               the-empty-environment
               (term->machine-code/t term)
               empty)))
\end{lstlisting}
%
Damit lässt sich die Maschine schon ausprobieren:
%
\begin{lstlisting}
(secd-step (inject-secd '(+ 1 2)))
|\evalsto| #<record:secd (1) () (2 #<record:prim + 2>) ()>
(secd-step (secd-step (inject-secd '(+ 1 2))))
|\evalsto| #<record:secd (2 1) () (#<record:prim + 2>) ()>
(secd-step (secd-step (secd-step (inject-secd '(+ 1 2)))))
|\evalsto| #<record:secd (3) () () ()>
\end{lstlisting}
%
Es fehlt noch die Auswertungsfunktion $\mathrm{eval}_\mathrm{SECD}$,
die eine Hilfsfunktion benötigt, um die reflexiv-transitive Hülle des
Zustandsübergangs $\hookrightarrow^*$ benötigt:
%
\begin{lstlisting}
; bis zum Ende Zustandsübergänge berechnen
(: secd-step* (secd -> secd))
(define secd-step*
  (lambda (state)
    (if (and (empty? (secd-code state))
             (empty? (secd-dump state)))
        state
        (secd-step* (secd-step state)))))
\end{lstlisting}
%
Die Auswertungsfunktion orientiert sich direkt an der mathematischen
Definition:
%
\begin{lstlisting}
; Evaluationsfunktion zur SECD-Maschine berechnen
(: eval-secd (term -> (mixed value (enum 'function))))

(check-expect (eval-secd '(+ 1 2)) 3)
(check-expect (eval-secd '(((lambda (x) (lambda (y) (+ x y))) 1) 2)) 3)

(define eval-secd
  (lambda (term)
    (define value (first
                   (secd-stack
                    (secd-step* 
                     (inject-secd term)))))
    (if (base? value)
        value
        'function)))
\end{lstlisting}
%
Damit läuft die SECD-Maschine:
%
\begin{lstlisting}
(eval-secd '(((lambda (x) (lambda (y) (+ x y))) 1) 2))
|\evalsto| 3
\end{lstlisting}

\section{Die endrekursive SECD-Maschine}

Die SECD-Maschine hat einen Schönheitsfehler: Bei endkursiven
Applikationen sollte sie eigentlich, wie in Lehrsprachen-Programmen, keinerlei
zusätzlichen Platz verbrauchen, da kein Kontext anfällt.  Folgende
Beispielauswertung für den Term $(\lambda x.x~x)~(\lambda x.x~x)$
zeigt aber, dass der Zustand mit fortschreitender Auswertung immer
größer wird:
%
% (secd-step*/tex (inject-secd '((lambda (x) (x x)) (lambda (x) (x x)))))
\begin{displaymath}\tiny
  \begin{array}{l@{}llll}
&(\epsilon, &\varnothing, &(x, x~x~\mathtt{ap})~(x, x~x~\mathtt{ap})~\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&((x, x~x~\mathtt{ap}, \varnothing), &\varnothing, &(x, x~x~\mathtt{ap})~\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&((x, x~x~\mathtt{ap}, \varnothing)~(x, x~x~\mathtt{ap}, \varnothing), &\varnothing, &\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&(\epsilon, &\{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, &x~x~\mathtt{ap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{ap}, \varnothing), &\{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, &x~\mathtt{ap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{ap}, \varnothing)~(x, x~x~\mathtt{ap}, \varnothing), &\{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, &\mathtt{ap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&(\epsilon, &\{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, &x~x~\mathtt{ap}, &(\epsilon, \{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, \epsilon)~(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{ap}, \varnothing), &\{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, &x~\mathtt{ap}, &(\epsilon, \{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, \epsilon)~(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{ap}, \varnothing)~(x, x~x~\mathtt{ap}, \varnothing), &\{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, &\mathtt{ap}, &(\epsilon, \{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, \epsilon)~(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&(\epsilon, &\{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, &x~x~\mathtt{ap}, &(\epsilon, \{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, \epsilon)~(\epsilon, \{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, \epsilon)~(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{ap}, \varnothing), &\{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, &x~\mathtt{ap}, &(\epsilon, \{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, \epsilon)~(\epsilon, \{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, \epsilon)~(\epsilon, \varnothing, \epsilon))
\\
& \ldots
  \end{array}
\end{displaymath}
%
Damit ist die SECD-Maschine, so wie ist, als Ausführungsmodell für
die Lehrsprachen ungeeignet.  Dieses Manko lässt sich zum Glück reparieren: Die
SECD-Maschine muss endrekursive und "<normale"> Applikationen
unterschiedlich behandeln.  Dazu wird eine neue Instruktion namens
$\mathtt{tailap}$ eingeführt, die wie $\mathtt{ap}$ eine Applikation
durchführt, aber eine endrekursive Applikation signalisiert:
%
\begin{eqnarray*}
  I &=& \ldots\\
  &&\cup \{ \mathtt{tailap} \}
\end{eqnarray*}
%
Als Nächstes muss die Übersetzungsfunktion von Termen in Maschinencode
geändert werden:  Applikationen, die Kontext um sich herum haben,
sollen mit $\mathtt{ap}$ übersetzt werden, solche ohne Kontext mit
$\mathtt{tailap}$.  Da der Applikation allein der Kontext nicht
anzusehen ist, sondern nur dem Term "<drumherum">, wird die
Übersetzungsfunktion $\llbracket \underline{~} \rrbracket$ in zwei
Teile aufgespalten: für einen Term $e$ wird die Auswertungsfunktion $\llbracket\underline{~}\rrbracket$ immer dann benutzt, wenn um $e$ Kontext steht.  Eine
weitere Funktion $\llbracket \underline{~} \rrbracket'$ wird immer
dann aufgerufen, wenn \emph{kein} Kontext drumherum steht.

Kontext entsteht seinerseits immer durch Funktionsapplikationen.  Bei
der Auswertung eines Terms $(e_0~e_1)$ muss \emph{nach} $e_0$ noch
$e_1$ ausgewertet werden, und nach Auswertung von $e_1$ muss noch die
Applikation durchgeführt werden.  Sowohl $e_0$ als auch $e_1$ stehen
in Kontext.  Ähnlich ist es bei den Argumenten von primitiven
Applikationen.

Auf der anderen Seite schneiden Abstraktionen für ihren Rumpf den
Kontext erst einmal ab: Der Rumpf einer Abstraktion kommt schließlich bei der
Auswertung der Abstraktion noch gar nicht zum Zug.  Ob er Kontext hat
oder nicht, entscheidet sich erst bei der Applikation.
Dementsprechend schalten Applikationen und Abstraktionen zwischen den
beiden Funktionen $\llbracket \underline{~} \rrbracket$ und
$\llbracket \underline{~} \rrbracket'$ hin und her:
%
\begin{eqnarray*}
  \llbracket \underline{~} \rrbracket &:& \mathcal{L}_{\lambda{}A} \rightarrow C\\
  \llbracket e \rrbracket &\deq&
  \begin{cases}
    b & \textrm{falls $e = b \in B$}\\
    v & \textrm{falls $e = v \in V$}\\
    \llbracket e_0\rrbracket~\llbracket e_1\rrbracket~\mathtt{ap}
    & \textrm{falls $e = (e_0~e_1)$}\\
    \llbracket e_1\rrbracket~\ldots~\llbracket e_k\rrbracket~\mathtt{prim}_{F^k}
    & \textrm{falls $e = (F~e_1~\ldots~e_k)$}\\
    (v, \llbracket e_0\rrbracket') & \textrm{falls $e = \lambda v.e_0$}
  \end{cases}\\[1ex]
  \llbracket \underline{~} \rrbracket' &:& \mathcal{L}_{\lambda{}A} \rightarrow C\\
  \llbracket e \rrbracket' &\deq&
  \begin{cases}
    b & \textrm{falls $e = b \in B$}\\
    v & \textrm{falls $e = v \in V$}\\
    \llbracket e_0\rrbracket~\llbracket e_1\rrbracket~\mathtt{tailap}
    & \textrm{falls $e = (e_0~e_1)$}\\
    \llbracket e_1\rrbracket~\ldots~\llbracket e_k\rrbracket~\mathtt{prim}_{F^k}
    & \textrm{falls $e = (F~e_1~\ldots~e_k)$}\\
    (v, \llbracket e_0\rrbracket') & \textrm{falls $e = \lambda v.e_0$}
  \end{cases}
\end{eqnarray*}
%
Die Übersetzungsfunktion hat die eigentliche Arbeit geleistet: Jetzt
muss nur noch eine Zustandsübergangsregel her, die $\mathtt{tailap}$
verarbeitet.  Diese ergibt sich direkt aus den Regeln für
$\mathtt{ap}$ und die Rückgabe eines Wertes:  $\mathtt{tailap}$
funktioniert so, wie $\mathtt{ap}$ direkt gefolgt von der
Rückgaberegel.  Hier sind die beiden Regeln noch einmal zur Erinnerung:
%
\begin{eqnarray*}
   (w (v,\underline{c'}, e') \underline{s}, e, \mathtt{ap}~\underline{c}, \underline{d})
  &\hookrightarrow&
  (\epsilon, e'[v\mapsto w], \underline{c'}, (\underline{s}, e, \underline{c}) \underline{d})
  \\
  (w, e, \epsilon, (\underline{s'}, e', \underline{c'}) \underline{d})
  &\hookrightarrow&
  (w\underline{s'}, e', \underline{c'}, \underline{d})
\end{eqnarray*}
%
Da die erste Regel ein neues Dump-Frame erzeugt und die zweite ein
Dump-Frame "<vernichtet">, entfällt diese Arbeit in der Regel für
$\mathtt{tailap}$:
%
\begin{eqnarray*}
  (w (v,\underline{c'}, e') \underline{s}, e, \mathtt{tailap}~\underline{c}, \underline{d})
  &\hookrightarrow&
  (\underline{s}, e'[v \mapsto w], \underline{c'}, \underline{d})
\end{eqnarray*}
%
Damit läuft das Beispiel zwar immer noch endlos, aber immerhin, ohne
immer mehr Platz zu verbrauchen:
%
\begin{displaymath}\scriptsize
  \begin{array}{l@{}llll}
 \hookrightarrow{}&(\epsilon, &\varnothing, &(x, x~x~\mathtt{tailap})~(x, x~x~\mathtt{tailap})~\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&((x, x~x~\mathtt{tailap}, \varnothing), &\varnothing, &(x, x~x~\mathtt{tailap})~\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&((x, x~x~\mathtt{tailap}, \varnothing)~(x, x~x~\mathtt{tailap}, \varnothing), &\varnothing, &\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&(\epsilon, &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &x~x~\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{tailap}, \varnothing), &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &x~\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{tailap}, \varnothing)~(x, x~x~\mathtt{tailap}, \varnothing), &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&(\epsilon, &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &x~x~\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{tailap}, \varnothing), &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &x~\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{tailap}, \varnothing)~(x, x~x~\mathtt{tailap}, \varnothing), &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&(\epsilon, &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &x~x~\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{tailap}, \varnothing), &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &x~\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{tailap}, \varnothing)~(x, x~x~\mathtt{tailap}, \varnothing), &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&(\epsilon, &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &x~x~\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{tailap}, \varnothing), &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &x~\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))
 \end{array}
\end{displaymath}
Die Implementierung der endrekursiven SECD-Maschine ist Gegenstand von
Übungsaufgabe~\ref{aufgabe:secd-endekursiv-implementieren}.

\section*{Übungsaufgaben}

\begin{aufgabe}
  Übersetze folgende Lambda-Terme in die Zwischenrepräsentation
  der SECD-Maschine:
  
  \begin{enumerate}
  \item \((\lambda xy.(+\:x\:y))\:(*\:5\:6)\:23\)

  \item \((\lambda x.(!\:x))\:(\lambda xy.(\&\&\:x\:y))\:((\lambda xy.(>\:x\:y))\:23~42)\:true\)

   
  \item \((\lambda xy.\:y\:x\:x)\:(\lambda z.\:z)\:(\lambda yz.\:(y\:y)\:(y\:z))\)

  \end{enumerate}

  Dabei steht $!$ für das boolesche \lstinline{not} und $\&\&$ für das
  boolesche \lstinline{and}.
\end{aufgabe}

\begin{aufgabe}
 Betrachte folgendes SECD-Programm:
 
 \newcommand{\tuple}[2]{\ensuremath{(#1,#2)}}

 \begin{center}
   \tuple{f}{\tuple{x}{\tuple{y}{f\:x\:\texttt{ap}\:y\:\texttt{ap}}}}\:\tuple{a}{\tuple{b}{a\:b\:\texttt{prim}_+}}\:\texttt{ap}\:23\:\texttt{ap}\:42\:\texttt{ap}
 \end{center}
 
 \begin{enumerate}
   \item Übersetze das SECD-Programm in den entsprechenden
   $\mathcal{L}_{\lambda{}A}$-Term.
   \item Werte das SECD-Programm aus und gibt die einzelnen
     Auswertungsschritte an!
 \end{enumerate}
  
\end{aufgabe}

\begin{aufgabe}\label{aufgabe:secd-endekursiv-implementieren}
  Erweitere die Implementierung der SECD-Maschine um korrekte
  Behandlung der Endrekursion!  Erweitere dazu zunächst die
  Datendefinition für Maschinencode. Implementiere dann die
  Übersetzung von $\lambda$-Termen für die endrekursive SECD-Maschine.
  Erweitere schließlich die Zustandsübergangsfunktion um einen
  Fall für die $\mathtt{tailap}$-Instruktion.
\end{aufgabe}

\begin{aufgabe}
  Die um Endrekursion erweiterte SECD-Maschine führt eine neue
  Maschinencode"=Instruktion \lstinline{tailap} ein.  Dies ist aber nicht
  unbedingt nötig.  Formuliere die Zustandsübergangsregeln der
  SECD-Maschine mit Endrekursion so um, dass die Funktionalität, also
  insbesondere die richtige Behandlung endrekursiver Applikationen,
  auch ohne das das zusätzliche Schlüsselwort \lstinline{tailap}
  erhalten bleibt.
\end{aufgabe}

\begin{aufgabe}
  Zeige in der um Endrekursion erweiterten
  SECD-Maschine, dass \lstinline{tailap} immer am Ende steht, also
  tatsächlich keinen Kontext besitzt.
\end{aufgabe}

\begin{aufgabe}\label{aufgabe:prim-arity}
  Erweitere die SECD-Maschine um Primitive anderer Stelligkeiten,
  zum Beispiel \lstinline{abs} oder \lstinline{odd?}.
\end{aufgabe}

\begin{aufgabe}
  Ändere die Implementierung der SECDH-Maschine dahingehend, dass
  sie Endrekursion korrekt behandelt.
\end{aufgabe}

\begin{aufgabe}
  Abstrahiere über \lstinline{remove-environment-binding} und
  \lstinline{remove-cell}.
\end{aufgabe}

\begin{aufgabe}
  Erweiter den angewandten $\lambda$-Kalkül um Abstraktionen und
  Applikationen mit mehr als einem Parameter.  Erweitere die
  SECD-Maschine und ihre Implementierung entsprechend.
\end{aufgabe}


\begin{aufgabe}
  Erweitere den angewandten $\lambda$-Kalkül um binäre
  Verzweigungen analog zu \lstinline{if}.  Erweitere entsprechend die
  SECD-Maschine und ihre Implementierung.
\end{aufgabe}

\begin{aufgabe}
  \lstinline{Begin} lässt sich im angewandten $\lambda$-Kalkül als
  syntaktischer Zucker auffassen: Wie müssten \lstinline{begin}-Ausdrücke
  in die Sprache des Kalküls übersetzt werden?
\end{aufgabe}

\begin{aufgabe}
  Anstatt Umgebungen durch Listen von Bindungen zu repräsentieren, ist
  es auch möglich, Funktionen zu verwenden, so dass
  \lstinline{lookup-environment} folgendermaßen aussieht:
\begin{lstlisting}
(define lookup-environment
  (lambda (environment variable)
    (environment variable)))
\end{lstlisting}
  Ergänze eine passende Definition für
  \lstinline{extend-environment}.
\end{aufgabe}

\begin{aufgabe}
  Auf den ersten Blick erscheint es etwas aufwendig, jedesmal bei der
  Auswertung einer Abstraktion die gesamte Umgebung in die Closure
  einzupacken.  Was würde sich ändern, wenn dieser Schritt weggelassen
  würde, Closures also nur Variable und Maschinencode für den Rumpf
  enthalten würden?  Formuliere die entsprechenden Regeln für die
  SECD-Maschine und ändere Sie die Implementierung entsprechend.
  Funktioniert die SECD-Maschine nach der Änderung noch korrekt?
\end{aufgabe}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "i1"
%%% End: 

