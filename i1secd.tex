% Diese Datei ist Teil des Buchs "Schreibe Dein Programm!"
% Das Buch ist lizensiert unter der Creative-Commons-Lizenz
% "Namensnennung 4.0 International (CC BY 4.0)"
% http://creativecommons.org/licenses/by/4.0/deed.de

\chapter{Die SECD-Maschine}\label{cha:secd}

Der $\lambda$-Kalk¸l ist als theoretisches Modell f¸r berechenbare
Funktionen lange vor der Erfindung des Computers entwickelt worden.
Die Reduktionsregeln dienen dabei der Entwicklung von Beweisen ¸ber
die ƒquivalenz von $\lambda$-Termen.  Damit der $\lambda$-Kalk¸l auch
als Modell f¸r die tats‰chliche Ausf¸hrung von Programmen, auf dem
Computer geeignet ist, fehlen noch zwei Zutaten: die direkte
Definition von "`eingebauten"' Werten und Operationen wie Zahlen und
booleschen Werten sowie ein formales Auswertungsmodell.  Dieses
Kapitel stellt zun‰chst den \textit{angewandten $\lambda$-Kalk¸l} vor,
der den normalen $\lambda$-Kalk¸l um primitive Werte und Operationen
erweitert, und dann die \textit{SECD-Maschine}, ein klassisches
Auswertungsmodell f¸r die Call-by-Value-Reduktion.  Angenehmerweise
l‰ﬂt sich die SECD-Maschine auch als Scheme-Programm implementieren,
was ebenfalls in diesem Kapitel geschieht.  Die SECD-Maschine
kennt keine Zuweisungen; es folgt darum noch die Darstellung der
\textit{SECDH-Maschine}, die auch einen \textit{Speicher} kennt und
damit Zuweisungen korrekt modelliert.

\section{Der angewandte $\lambda$-Kalk¸l}

Abschnitt~\ref{sec:lambdaprog} zeigte bereits, daﬂ sich auch boolesche
Werte und Zahlen im $\lambda$-Kalk¸l durch $\lambda$-Terme darstellen
lassen.  Das ist zwar aus theoretischer Sicht gut zu wissen, auf Dauer
aber etwas m¸hsam: Darum ist es sinnvoll, mit einer erweiterten
Version des $\lambda$-Kalk¸ls zu arbeiten, die solche "`primitiven"'
Werte direkt kennt.  Abschnitt~\ref{sec:lambdaprog} hat gezeigt,
daﬂ eine solche Erweiterung nur syntaktischer Zucker ist,
also die Ausdruckskraft des Kalk¸ls nicht wirklich erhˆht.  Alle
Erkenntnisse aus dem normalen $\lambda$-Kalk¸l bleiben also erhalten.

Ein solcher erweiterter $\lambda$-Kalk¸l heiﬂt auch
\textit{angewandter $\lambda$-Kalk¸l}:

\begin{definition}[Sprache des angewandten $\lambda$-Kalk¸ls
  $\mathcal{L}_{\lambda{}A}$]\index{angewandter $\lambda$-Kalk¸l}\label{def:lambda-angewandt}
  
  Sei $V$ eine abz‰hlbare Menge von Variablen.  Sei $B$ eine Menge von
  \textit{Basiswerten\index{Basiswert}}.  Sei f¸r eine nat¸rliche
  Zahl $n$ und $i \in \{1, \ldots, n\}$ jeweils $\Sigma^i$ eine Menge
  von \textit{$i$-stelligen Primitiva\index{Primitivum}}~-- die Namen
  von "`eingebauten Operationen"'.  Jedem $F^i\in\Sigma^i$ ist eine
  $i$-stellige Funktion $F_B^i: B\times\ldots\times B \rightarrow
  B$~-- ihre \textit{Operation}~--
  zugordnet.  Die Sprache des angewandten $\lambda$"=Kalk¸ls, die
  Menge der \textit{angewandten $\lambda$-Terme},
  $\mathcal{L}_{\lambda{}A}$\index{L@$\mathcal{L}_{\lambda{}A}$}, ist
  durch folgende Grammatik definiert:
  \begin{grammar}
    \meta{$\mathcal{L}_{\lambda{}A}$} \: \meta{$V$}
    \> \| (\meta{$\mathcal{L}_{\lambda{}A}$} \meta{$\mathcal{L}_{\lambda{}A}$})
    \> \| ($\lambda$\meta{$V$}.\meta{$\mathcal{L}_{\lambda{}A}$})
    \> \| \meta{$B$}
    \> \| (\meta{$\Sigma^1$}~\meta{$\mathcal{L}_{\lambda{}A}$})
    \> \| (\meta{$\Sigma^2$}~\meta{$\mathcal{L}_{\lambda{}A}$}~\meta{$\mathcal{L}_{\lambda{}A}$})
    \> \ldots
    \> \| (\meta{$\Sigma^n$}~\meta{$\mathcal{L}_{\lambda{}A}$}~\ldots~\meta{$\mathcal{L}_{\lambda{}A}$}) \quad \textrm{($n$-mal)}
  \end{grammar}
  Die Grammatik ist abgek¸rzt notiert: Die letzen Klauseln besagen,
  daﬂ es f¸r jede Stelligkeit $i$ eine Klausel mit \meta{$\Sigma^i$} gibt,
  bei der jeweils $i$ Wiederholungen von
  \meta{$\mathcal{L}_{\lambda{}A}$}~-- entsprechend der Stelligkeit
  der Primitiva in $\Sigma^i$.
  %
Dabei heiﬂen Terme der Form $(F^k~e_1~\ldots~e_k)$ auch
\textit{primitive Applikationen\index{primitive Applikation}}.
\end{definition}
%
In diesem Kapitel dienen normalerweise die Zahlen als Basiswerte mit
den ¸blichen Operationen wie $+$, $-$, $\ast$, $/$ etc.  Damit sind
Terme wie zum Beispiel $(+~(-~5~3)~17)$ mˆglich.

Im angewandten $\lambda$-Kalk¸l kommen zu den Werten aus
Definition~\ref{def:wert} die Basiswerte dazu:
%
\begin{definition}[Werte im angewandten $\lambda$-Kalk¸l]\label{def:wert-angewandt}
  Im angewandten $\lambda$-Kalk¸l heiﬂen die Abstraktionen und
  Basiswerte kollektiv \textit{Werte}.  Ein $\lambda$-Term, der kein
  Wert\index{Wert} ist, heiﬂt \textit{Nichtwert\index{Nichtwert}}.
\end{definition}

Damit die primitiven Operationen auch tats‰chlich eine Bedeutung
bekommen, muﬂ eine spezielle Reduktionsregel f¸r sie eingef¸hrt
werden:
%
\begin{definition}[$\delta$-Reduktion]\index{delta-Reduktion@$\delta$-Reduktion}
\begin{displaymath}
  (F^k~e_1~\ldots~e_k) \rightarrow_{\delta} F_B^k(e_1, \ldots, e_k)
  \quad e_1, \ldots, e_k \in B
\end{displaymath}
\end{definition}
%
Diese Regel besagt, daﬂ eine primitive Applikation, wenn alle
Operanden Werte sind, durch Anwendung der entsprechenden Operation 
reduziert werden kann.  Damit wird z.B.\ der
obige Beispielterm folgendermaﬂen reduziert:
%
\begin{displaymath}
  (+~(-~5~3)~17) \rightarrow_{\delta} (+~2~17) \rightarrow_{\delta} 19
\end{displaymath}

\section{Die einfache SECD-Maschine}

Wie schon in Abschnitt~\ref{sec:scheme-auswertung} erw‰hnt, ist 
der Call-by-Value-$\lambda$-Kalk¸l\index{Call-by-Value-Reduktion}
ein Modell f¸r die Auswertung von Scheme und viele andere
Programmiersprachen .
Allerdings ist Definition~\ref{def:call-by-value} strenggenommen etwas
vage: Es wird immer nur der Subterm reduziert, der
"`mˆglichst weit links innen steht"', aber was das heiﬂt, ist nicht
genau definiert.  Auﬂerdem ist Reduktion zwar ein
m‰chtiges formales Modell, entspricht aber nicht der
Ausf¸hrungsmethode tats‰chlicher Scheme-Implementierungen auf echten
Prozessoren.  Ein pr‰zises und echten Maschinen deutlich n‰heres
Modell ist die \textit{SECD-Maschine\index{SECD-Maschine}}, erfunden
schon in den 60er Jahren von Peter Landin~\cite{Landin1964}, und
seitdem die Grundlage f¸r zahllose Implementierungen von
Call-by-Value-Sprachen.  (Die Darstellung hier ist gegen¸ber Landins
urspr¸nglicher Formulierung etwas modernisiert.)

Damit ein Programm aus dem angewandten $\lambda$-Kalk¸l mit der
SECD-Maschine ausgewertet werden kann, muﬂ es erst einmal in einen
speziellen \textit{Maschinencode\index{Maschinencode}} ¸bersetzt oder
"`compiliert"' werden.  Der Maschinencode besteht, anders als der
$\lambda$-Kalk¸l, nicht aus geschachtelten Termen, sondern aus einer
Folge von \textit{Instruktionen\index{Instruktion}}.  

\begin{definition}[Maschinencode]\label{def:secd-code}
  In der folgenden Definition ist $I$ die Menge der Instruktionen:
  \begin{grammar}
    \meta{I} \: \meta{B}
    \> \| \meta{V}
    \> \| ap
    \> \| prim$_{F^i}$ \textrm{f¸r alle $F^i \in \Sigma^i$}
    \> \| (\meta{V}, \meta{C})
  \end{grammar}
  %
  Ein Maschinencode-Programm ist eine Folge von Instruktionen:
  %
  \begin{displaymath}
    C = I^\ast
  \end{displaymath}
\end{definition}

Ein Term aus dem angewandten $\lambda$-Kalk¸l wird mit Hilfe folgender
Funktion in Maschinencode ¸bersetzt:
%
\begin{eqnarray*}
  \llbracket \underline{~} \rrbracket &:& \mathcal{L}_{\lambda{}A}
  \rightarrow C\\
  \llbracket e \rrbracket &\deq&
  \begin{cases}
    b & \textrm{falls $e = b \in B$}\\
    v & \textrm{falls $e = v \in V$}\\
    \llbracket e_0\rrbracket~\llbracket e_1\rrbracket~\mathtt{ap}
    & \textrm{falls $e = (e_0~e_1)$}\\
    \llbracket e_1\rrbracket~\ldots~\llbracket e_k\rrbracket~\mathtt{prim}_{F^k}
    & \textrm{falls $e = (F~e_1~\ldots~e_k)$}\\
    (v, \llbracket e_0\rrbracket) & \textrm{falls $e = \lambda v.e_0$}
  \end{cases}
\end{eqnarray*}
%
Die ‹bersetzungsfunktion "`linearisiert"' einen $\lambda$-Term.  Zum
Beispiel bedeutet die ‹bersetzung $\llbracket e_0\rrbracket~\llbracket
e_1\rrbracket~\mathtt{ap}$ f¸r einen Term $(e_0~e_1)$, daﬂ zuerst
$e_0$ ausgewertet wird, danach wird $e_1$ ausgewertet, und schlieﬂlich wird die
eigentliche Applikation ausgef¸hrt:  Entsprechend steht $\mathtt{ap}$
f¸r "`Applikation ausf¸hren"' und $\mathtt{prim}_{F^k}$ f¸r "`Primitiv
$F$ ausf¸hren"'.  Basiswerte und Variablen werden im Maschinencode
belassen.  Ein $\lambda$-Term wird ¸bersetzt in ein Tupel aus seiner
Variable und dem Maschinencode f¸r seinen Rumpf.

Durch die Linearisierung sind die Instruktionen schon in einer Liste in der
Reihenfolge ihrer Ausf¸hrung aufgereiht.  Insbesondere hat die
Linearisierung den Begriff "`links innen"' formalisiert: der jeweils
am weitesten links innen stehende Redex steht in der Liste der
Instruktionen vorn.

Beispiel:
%
\begin{eqnarray*}
  \llbracket \lambda f.\lambda x.\lambda y.f~(+~x~(*~y~2))\rrbracket
  &=&
  (f, \llbracket \lambda x.\lambda y.f~(+~x~(*~y~2))\rrbracket)\\
  &=&
  (f, (x, \llbracket \lambda y.f~(+~x~(*~y 2))\rrbracket))\\
  &=&
  (f, (x, (y, \llbracket f~(+~x~(*~y 2))\rrbracket)))\\
  &=&
  (f, (x, (y, \llbracket f\rrbracket \llbracket (+~x~(*~y
  2))\rrbracket \mathtt{ap})))\\
  &=&
  (f, (x, (y, f \llbracket (+~x~(*~y 2))\rrbracket\mathtt{ap})))\\
  &=&
  (f, (x, (y, f \llbracket x\rrbracket \llbracket (*~y~2)\rrbracket \mathtt{prim}_+~\mathtt{ap})))\\
  &=&
  (f, (x, (y, f~x \llbracket (*~y~2)\rrbracket \mathtt{prim}_+~\mathtt{ap})))\\
  &=&
  (f, (x, (y, f~x \llbracket y\rrbracket \llbracket 2\rrbracket \mathtt{prim}_*~\mathtt{prim}_+~\mathtt{ap})))\\
  &=&
  (f, (x, (y, f~x~y \llbracket 2\rrbracket \mathtt{prim}_*~\mathtt{prim}_+~\mathtt{ap})))\\
  &=&
  (f, (x, (y, f~x~y~2~\mathtt{prim}_*~\mathtt{prim}_+~\mathtt{ap})))\\
\end{eqnarray*}
%
Das Beispiel zeigt deutlich, wie der Rumpf der innersten Abstraktion
in eine lineare Folge von Instruktionen ¸bersetzt wird, die genau der
Call-by-Value-Reduktionsstrategie entspricht: erst $f$ auswerten, dann
$x$, dann $y$, dann das Primitiv $*$ anwenden, dann $+$, und
schlieﬂlich die Applikation durchf¸hren.

Nun zur eigentlichen SECD-Maschine~-- sie funktioniert ‰hnlich wie ein
Reduktionskalk¸l, operiert aber auf sogenannten
\textit{Maschinenzust‰nden}: die Maschine ¸berf¸hrt also einen
Maschinenzustand durch einen Auswertungsschritt in einen neuen
Maschinenzustand.  Ein Maschinenzustand ist dabei ein 4-Tupel aus der
Menge $S\times E\times C\times D$ (daher der Name der Maschine).  Die
Buchstaben sind deshalb so gew‰hlt, weil $S$ der sogenannte
\textit{Stack\index{Stack}}, $E$ die sogenannte
\textit{Umgebung\index{Umgebung}} bzw.\ auf englisch das
\textit{Environment\index{Environment}}, $C$ der schon bekannte
Maschinencode bzw.\ \textit{Code\index{Code}} und $D$ der
sogenannte \textit{Dump\index{Dump}} ist.  Die formalen Definitionen
dieser Mengen sind wie folgt; dabei ist $W$ die Menge der Werte:
%
\begin{eqnarray*}
  S &=& W^\ast\\
  E &=& \mathcal{P}(V\times W)\\
  D &=& (S\times E \times C)^\ast\\
  W &=& B \cup (V\times C\times E)
\end{eqnarray*}
%
Der Stack ist dabei eine Folge von Werten.  In der Maschine sind dies
die Werte der zuletzt ausgewerteten Terme, wobei der zuletzt
ausgewertete Term vorn bzw.\ "`oben"' steht.  Die Umgebung ist eine
partielle Abbildung von Variablen auf Werte: sie ersetzt die
Substitution in der Reduktionsrelation des $\lambda$-Kalk¸ls.  Anstatt
daﬂ Werte f¸r Variablen eingesetzt werden, merkt sich die Umgebung
einfach, an welche Werte die Variablen gebunden sind.  Erst wenn der
Wert einer Variablen benˆtigt wird, holt ihn die Maschine aus der
Umgebung.  Der Dump schlieﬂlich ist eine Liste fr¸herer Zust‰nde der
Maschine: er entspricht dem Kontext\index{Kontext} im
Substitutionsmodell.

Die Menge $W$ schlieﬂlich entspricht dem Wertebegriff aus
Definition~\ref{def:wert-angewandt}: Die Basiswerte gehˆren dazu,
auﬂerdem Tripel aus $(V\times C\times E)$.  Ein solches Tripel,
genannt \textit{Closure\index{Closure}}~-- repr‰sentiert den Wert
einer Abstraktion~-- es besteht aus der Variable einer Abstraktion,
dem Maschinencode ihres Rumpfs und der Umgebung, die notwendig ist, um
die Abstraktion anzuwenden: Die Umgebung wird benˆtigt, damit die
freien Variablen der Abstraktion entsprechend der lexikalischen
Bindung\index{lexikalische Bindung} ausgewertet werden kˆnnen.  Dies
ist anders als im Substitutionsmodell, wo Variablen bei der
Applikation direkt ersetzt werden und damit verschwinden.  Eine
Closure ist also einfach die Repr‰sentation einer Funktion.

Im Verlauf der Auswertung werden Umgebungen h‰ufig um neue Bindungen
von einer Variable an einen Wert erweitert.  Dazu ist die Notation
$e[v\mapsto w]$ n¸tzlich.  $e[v\mapsto w]$ konstruiert aus einer
Umgebung $e$ eine neue Umgebung, in der die Variable $v$ an den Wert
$w$ gebunden ist.  Hier ist die Definition:
%
\begin{displaymath}
  e[v\mapsto w] \deq (e \setminus \{ (v, w') | (v, w') \in e \}) \cup \{
    (v, w) \}
\end{displaymath}
%
Es wird also zun‰chst eine eventuell vorhandene alte Bindung entfernt
und dann eine neue hinzugef¸gt.

Um einen $\lambda$-Term $e$ in die SECD-Maschine zu "`injizieren"',
wird er in einen Anfangszustand $(\epsilon, \varnothing, \llbracket
e\rrbracket, \epsilon)$ ¸bersetzt.  Dann wird dieser Zustand
wiederholt in die Zustands¸bergangsrelation $\hookrightarrow$
gef¸ttert.  In der folgenden Definition von $\hookrightarrow$ sind
Bezeichner mit einem Unterstrich versehen, wenn es sich um Folgen
handelt, also z.B.\ \underline{s} f¸r einen Stack:
%
\begin{eqnarray}
  \hookrightarrow &\in& \mathcal{P}((S\times E\times C\times D) \times (S\times E\times C\times D))\notag\\
  (\underline{s}, e, b\underline{c}, \underline{d})
  &\hookrightarrow& 
  (b\underline{s}, e, \underline{c}, \underline{d})
  \label{secd:base}
  \\
  (\underline{s}, e, v\underline{c}, \underline{d})
  &\hookrightarrow&
  (e(v)\underline{s}, e, \underline{c}, \underline{d})
  \label{secd:variable}
  \\
  (b_k\ldots b_1 \underline{s}, e, \mathtt{prim}_{F^k}\underline{c}, \underline{d})
  &\hookrightarrow&
  (b\underline{s}, e, \underline{c}, \underline{d})
  \label{secd:prim}
  \\ && \textrm{wobei $F^k\in\Sigma^k$ und $F^k_B(b_1,\ldots,b_k) = b$}\notag
  \\
  (\underline{s}, e, (v, \underline{c'}) \underline{c}, \underline{d})
  &\hookrightarrow&
  ((v, \underline{c'}, e) \underline{s}, e, \underline{c}, \underline{d})
  \label{secd:abstraction}
  \\
  (w (v,\underline{c'}, e') \underline{s}, e, \mathtt{ap}~\underline{c}, \underline{d})
  &\hookrightarrow&
  (\epsilon, e'[v\mapsto w], \underline{c'}, (\underline{s}, e, \underline{c}) \underline{d})
  \label{secd:app}
  \\
  (w, e, \epsilon, (\underline{s'}, e', \underline{c'}) \underline{d})
  &\hookrightarrow&
  (w\underline{s'}, e', \underline{c'}, \underline{d})
  \label{secd:return}
\end{eqnarray}
%
Die Regeln definieren eine Fallunterscheidung nach der ersten
Instruktion der Code"=Komponente des Zustands, bzw.\ greift die letzte
Regel, wenn der Code leer ist.  Der Reihe nach arbeiten die Regeln wie
folgt:
%
\begin{itemize}
\item Regel~\ref{secd:base} (die
  \textit{Literalregel\index{Literalregel}}) schiebt einen Basiswert
  direkt auf den Stack.
\item Regel~\ref{secd:variable} (die
  \textit{Variablenregel\index{Variablenregel}}) ermittelt den Wert
  einer Variable aus der Umgebung und schiebt diesen auf den Stack.
\item Regel~\ref{secd:prim} ist die
  \textit{Primitivregel\index{Primitivregel}}.  Bei einer primitiven
  Applikation m¸ssen soviele Basiswerte oben auf dem Stack liegen wie
  die Stelligkeit des Primitivs.  Dann ermittelt die Primitivregel das Ergebnis der
  primitiven Applikation und schiebt es oben auf den Stack.
\item Regel~\ref{secd:abstraction} ist die
  \textit{Abstraktionsregel\index{Abstraktionsregel}}: Das Tupel
  $(v,\underline{c'})$ ist bei der ‹bersetzung aus einer Abstraktion
  entstanden.  Die Regel erg‰nzt $v$ und $\underline{c'}$ mit
  $e$ zu einer Closure, die auf den Stack geschoben wird.
\item Regel~\ref{secd:app} ist die
  \textit{Applikationsregel\index{Applikationsregel}}: Bei einer
  Applikation m¸ssen oben auf dem Stack ein Wert sowie eine Closure
  liegen.  (Zur Erinnerung: Eine Applikation kann nur ausgewertet
  werden, wenn eine Abstraktion vorliegt.  Abstraktionen werden zu
  Closures ausgewertet.)  In einem solchen Fall "`sichert"' die
  Applikation den aktuellen Zustand auf den Dump, und die Auswertung f‰hrt mit
  einem leeren Stack, der Umgebung aus der Closure~-- erweitert um
  eine Bindung f¸r die Variable~-- und dem Code aus der Closure fort.
\item Regel~\ref{secd:return} ist die
  \textit{R¸ckkehrregel\index{R¸ckkehrregel}}: Sie ist anwendbar,
  wenn das Ende des Codes erreicht ist.  Das heiﬂt, daﬂ gerade
  die Auswertung einer Applikation fertig ist.  Auf dem Dump liegt
  aber noch ein gesicherter Zustand, der jetzt "`zur¸ckgeholt"' wird.
\end{itemize}
%
Hier ein Beispiel f¸r den Ablauf der SECD-Maschine f¸r den Term
$(((\lambda x.\lambda y.(+~x~y))~1)~2)$:
% (secd-step*/tex (inject-secd '(((lambda (x) (lambda (y) (+ x y))) 1) 2)))
%
\begin{displaymath}
  \begin{array}{l@{}llll}
&(\epsilon, &\varnothing, &(x, (y, x~y~\mathtt{prim}_+))~1~\mathtt{ap}~2~\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&((x, (y, x~y~\mathtt{prim}_+), \varnothing), &\varnothing, &1~\mathtt{ap}~2~\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&(1~(x, (y, x~y~\mathtt{prim}_+), \varnothing), &\varnothing, &\mathtt{ap}~2~\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&(\epsilon, &\{(x, 1)\}, &(y, x~y~\mathtt{prim}_+), &(\epsilon, \varnothing, 2~\mathtt{ap}))\\
\hookrightarrow{}&((y, x~y~\mathtt{prim}_+, \{(x, 1)\}), &\{(x, 1)\}, &\epsilon, &(\epsilon, \varnothing, 2~\mathtt{ap}))\\
\hookrightarrow{}&((y, x~y~\mathtt{prim}_+, \{(x, 1)\}), &\varnothing, &2~\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&(2~(y, x~y~\mathtt{prim}_+, \{(x, 1)\}), &\varnothing, &\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&(\epsilon, &\{(x, 1), (y, 2)\}, &x~y~\mathtt{prim}_+, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&(1, &\{(x, 1), (y, 2)\}, &y~\mathtt{prim}_+, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&(2~1, &\{(x, 1), (y, 2)\}, &\mathtt{prim}_+, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&(3, &\{(x, 1), (y, 2)\}, &\epsilon, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&(3, &\varnothing, &\epsilon, &\epsilon)
  \end{array}
\end{displaymath}
%
Die Zustands¸bergangsrelation $\hookrightarrow$ ist nun die Grundlage
f¸r die \textit{Auswertungsfunktion\index{Auswertungsfunktion}} der
SECD-Maschine, die f¸r einen $\lambda$-Term dessen Bedeutung
ausrechnet.  Dies ist scheinbar ganz einfach:
%
\begin{eqnarray*}
  \mathit{eval}_\mathit{SECD} & : & \mathcal{L}_{\lambda{}A} \rightarrow B\\
  \mathit{eval}_\mathit{SECD}(e) &= & x \textrm{ wenn } (\epsilon, \varnothing, \llbracket e\rrbracket, \epsilon)
    \hookrightarrow^* (x, e, \epsilon, \epsilon)
\end{eqnarray*}
%
Diese Definition hat jedoch zwei Haken:
%
\begin{itemize}
\item Die Auswertung von $\lambda$-Termen terminiert nicht immer (wie
  zum Beispiel f¸r den "`Endlos"=Term"' $(\lambda x.(x~x))~(\lambda x.(x~x))$), es kommt
  also nicht immer dazu, daﬂ die Zustands¸bergangsrelation bei einem
  Zustand der Form $(\epsilon, \varnothing, \llbracket e\rrbracket,
  \epsilon)$ terminiert.
\item Das $x$ aus dieser Definition ist nicht immer ein Basiswert~--
  es kann auch eine Closure sein.
\end{itemize}
%
Der erste Haken sorgt daf¸r, daﬂ die Auswertungsfunktion nur eine
Relation im Sinne einer "`partiellen Funktion"' ist.  Meist wird
trotzdem von einer Auswertungsfunktion gesprochen.  Beim zweiten
Haken, wenn $x$ eine Closure ist, l‰ﬂt sich mit dem Resultat nicht
viel anfangen: Um die genaue Bedeutung der Closure herauszubekommen,
m¸ﬂte sie angewendet werden~-- das Programm ist aber schon fertig
gelaufen.  Es ist also gar nicht sinnvoll, zwischen verschiedenen
Closures zu unterscheiden.  Darum wird f¸r die Zwecke der
Auswertungsfunktion eine Menge $Z$ der \textit{Antworten\index{Antwort}}
definiert, die einen designierten Spezialwert f¸r Closures enth‰lt:
%
\begin{displaymath}
  Z = B \cup \{ \texttt{function} \}
\end{displaymath}
%
Damit l‰ﬂt sich die Evaluationsfunktion wie folgt definieren:
%
\begin{eqnarray*}
  \mathit{eval}_\mathit{SECD} & \in & \mathcal{L}_{\lambda{}A} \times Z\\
  \mathit{eval}_\mathit{SECD}(e) & = &
  \begin{cases}
    b & \textrm{falls } (\epsilon, \varnothing, \llbracket e\rrbracket, \epsilon)
    \hookrightarrow^* (b, e, \epsilon, \epsilon)\\
    \texttt{function} & \textrm{falls } (\epsilon, \varnothing, \llbracket e\rrbracket, \epsilon)
    \hookrightarrow^* ((v, \underline{c}, e'), e, \epsilon, \epsilon)\\
  \end{cases}
\end{eqnarray*}

\section{\texttt{Quote} und Symbole}
\label{sec:quote}

Dieses Kapitel wird ab hier Gebrauch von einer weiteren
Sprachebene\index{Sprachebene!fortgeschritten} in
\drscheme{} machen, n‰mlich \texttt{Die Macht der Abstraktion -
  fortgeschritten}.  Diese Ebene muﬂ mit dem \drscheme{}-Men¸ \texttt{Sprache}
unter \texttt{Sprache ausw‰hlen} aktiviert sein, damit die
Programme dieses Kapitels funktionieren.

Die entscheidende ƒnderung gegen¸ber den fr¸heren Sprachebenen ist
die Art, mit der die REPL Werte ausdruckt.  (Diese neue Schreibweise,
ermˆglicht, die Programme des Interpreters, die als Werte
repr‰sentiert sind, korrekt auszudrucken.)  Bei Zahlen, Zeichenketten
und booleschen Werten bleibt alles beim alten:
%
\begin{alltt}
5
\evalsto{} 5
"Mike ist doof"
\evalsto{} "Mike ist doof"
#t
\evalsto{} #t
\end{alltt}
%
Bei Listen sieht es allerdings anders aus:
%
\begin{alltt}
(list 1 2 3 4 5 6)
\evalsto{} (1 2 3 4 5 6)
\end{alltt}
%
Die REPL druckt also eine Liste aus, indem sie zuerst eine ˆffnende
Klammer ausdruckt, dann die Listenelemente (durch Leerzeichen
getrennt) und dann eine schlieﬂende Klammer.

Das funktioniert auch f¸r die leere Liste:
%
\begin{alltt}
empty
\evalsto{} ()
\end{alltt}
%
Mit der neuen Sprachebene bekommt auﬂerdem der Apostroph, der dem
Literal\index{Literal} f¸r die leere Liste voransteht, eine erweiterte Bedeutung.
Unter anderem kann der Apostroph benutzt werden, um Literale f¸r
Listen zu formulieren:
%
\begin{alltt}
'(1 2 3 4 5 6)
\evalsto{} (1 2 3 4 5 6)
'(1 #t "Mike" (2 3) "doof" 4 #f 17)
\evalsto{} (1 #t "Mike" (2 3) "doof" 4 #f 17)
'()
\evalsto{} ()
\end{alltt}
%
In der neuen Sprachebene benutzen die Literale und die ausgedruckten
externen Repr‰sentationen f¸r Listen also die gleiche
Notation\index{Repr‰sentation}.  Sie unterscheiden sich nur dadurch,
daﬂ beim Literal der Apostroph voransteht.  Der Apostroph funktioniert
auch bei Zahlen, Zeichenketten und booleschen Werten:
%
\begin{alltt}
'5
\evalsto{} 5
'"Mike ist doof"
\evalsto{} "Mike ist doof"
'#t
\evalsto{} #t
\end{alltt}
%
Der Apostroph am Anfang eines Ausdrucks
kennzeichnet diesen also als Literal.  Der Wert des Literals wird 
genauso ausgedruckt, wie es im Programm steht.  (Abgesehen von
Leerzeichen und Zeilenumbr¸chen.)  Der Apostroph heiﬂt auf englisch
"`quote"'\index{quote@\texttt{quote}}, und deshalb ist diese
Literalschreibweise auch unter diesem Namen bekannt.  Bei Zahlen,
Zeichenketten und booleschen Literalen ist auch ohne Quote klar, daﬂ
es sich um Literale handelt.  Das Quote ist darum bei ihnen rein
optional; sie heiﬂen 
\textit{selbstquotierend}\index{selbstquotierend}.
Bei Listen hingegen sind Miﬂverst‰ndnisse mit anderen
zusammengesetzten Formen mˆglich, die ja auch mit einer ˆffnenden Klammer
beginnen: \footnote{Tats‰chlich ist die neue Schreibweise f¸r externe
  Repr‰sentationen die Standard-Repr‰sentation in Scheme.  Die
  fr¸heren Sprachebenen benutzten die alternative Schreibweise, um die
  Verwirrung zwischen Listenliteralen und zusammengesetzten Formen zu
  vermeiden.}
\begin{alltt}
(1 2 3 4 5 6)
\evalsto{} procedure application: expected procedure, given: 1;
     arguments were: 2 3 4 5 6
\end{alltt}
%
Mit der Einf¸hrung von Quote kommt noch eine vˆllig neue Sorte Werte
hinzu: die \textit{Symbole\index{Symbol}}.  Symbole sind Werte ‰hnlich wie Zeichenketten und
bestehen aus Text.  Sie unterscheiden sich allerdings dadurch, daﬂ sie
als Literal mit Quote geschrieben und in der REPL ohne
Anf¸hrungszeichen ausgedruckt werden:
%
\begin{alltt}
'mike
\evalsto{} mike
'doof
\evalsto{} doof
\end{alltt}
%
Symbole lassen sich mit dem Pr‰dikat
\texttt{symbol?\index{symbol@\texttt{symbol?}}} von anderen Werten
unterscheiden:
%
\begin{alltt}
(symbol? 'mike)
\evalsto{} #t
(symbol? 5)
\evalsto{} #f
(symbol? "Mike")
\evalsto{} #f
\end{alltt}
%
Vergleichen lassen sich Symbole mit \texttt{equal?} (siehe
Abbildung~\ref{scheme:equalp}):

\begin{alltt}
(equal? 'mike 'herb)
\evalsto{} #f
(equal? 'mike 'mike)
\evalsto{} #t
\end{alltt}

Symbole kˆnnen nicht aus beliebigem Text bestehen.  
Leerzeichen sind zum Beispiel verboten.  Tats‰chlich entsprechen die
Namen der zul‰ssigen Symbole genau den Namen von Variablen:
%
\begin{alltt}
'karl-otto
\evalsto{} karl-otto
'mehrwertsteuer
\evalsto{} mehrwertsteuer
'duftmarke
\evalsto{} duftmarke
'lambda
\evalsto{} lambda
'+
\evalsto{} +
'*
\evalsto{} *
\end{alltt}
%
Diese Entsprechung wird in diesem Kapitel noch eine entscheidene Rolle
spielen.  Symbole kˆnnen nat¸rlich auch in Listen und damit auch in
Listenliteralen vorkommen:
%
\begin{alltt}
'(karl-otto mehrwertsteuer duftmarke)
\evalsto{} (karl-otto mehrwertsteuer duftmarke)
\end{alltt}
%
Mit Hilfe von Symbolen kˆnnen Werte konstruiert werden, die in der REPL
ausgedruckt wie Scheme-Ausdr¸cke aussehen:
%
\begin{alltt}
'(+ 1 2)
\evalsto{} (+ 1 2)
'(lambda (n) (+ n 1))
\evalsto{} (lambda (n) (+ n 1))
\end{alltt}
%
Auch wenn diese Werte wie Ausdr¸cke so aussehen, sind sie doch ganz
normale Listen: der Wert von \verb|'(+ 1 2)| ist eine Liste mit drei
Elementen: das Symbol \verb|+|, die Zahl \texttt{1} und die Zahl
\texttt{2}.  Der Wert von \verb|'(lambda (n) (+ n 1))| ist ebenfalls
eine Liste mit drei Elementen: das Symbol \verb|lambda|, eine Liste
mit einem einzelnen Element, n‰mlich dem Symbol \texttt{n}, und einer
weiteren Liste mit drei Elementen: dem Symbol \verb|+|, dem Symbol
\texttt{n} und der Zahl \texttt{1}.

Quote hat noch eine weitere verwirrende Eigenheit:
%
\begin{alltt}
''()
\evalsto{} '()
\end{alltt}
%
Dieses Literal bezeichnet nicht die leere Liste (dann w¸rde nur
\texttt{()} ausgedruckt, ohne Quote), sondern etwas anderes:
%
\begin{alltt}
(pair? ''())
\evalsto{} #t
(first ''())
\evalsto{} quote
(rest ''())
\evalsto{} (())
\end{alltt}
%
Der Wert des Ausdrucks \verb|''()| ist also eine Liste mit zwei
Elementen: das erste Element ist das Symbol \texttt{quote} und das
zweite Element ist die leere Liste.  \texttt{'$t$}
ist selbst also nur syntaktischer Zucker, und zwar f¸r \texttt{(quote
  $t$)}:
%
\begin{alltt}
(equal? (quote ()) '())
\evalsto{} #t
(equal? (quote (quote ())) ''())
\evalsto{} #t
\end{alltt}
%
Quote erlaubt die Konstruktion von Literalen f¸r viele Werte, aber
nicht f¸r alle.  Ein Wert, f¸r den Quote ein Literal konstruieren kann,
heiﬂt \textit{repr‰sentierbarer
  Wert\index{repr‰sentierbarer Wert}}.  Die folgende induktive
Definition spezifiziert, was ein repr‰sentierbarer Wert ist:
%
\begin{itemize}
\item Zahlen, boolesche Werte, Zeichenketten und Symbole sind
  repr‰sentierbare Werte.
\item Eine Liste aus repr‰sentierbaren Werten ist ihrerseits ein
  repr‰sentierbarer Wert. 
\item Nichts sonst ist ein repr‰sentierbarer Wert.
\end{itemize}

\section{Implementierung der SECD-Maschine}

Die SECD-Maschine ist ein Modell f¸r die Implementierung des
$\lambda$-Kalk¸ls.  Eine solche Implementierung l‰ﬂt sich in
Scheme einfach bauen~-- dieser Abschnitt zeigt, wie.  Der grobe
Fahrplan ergibt sich dabei aus der Struktur der SECD-Maschine selbst:
Nach den obligatorischen Datendefinitionen m¸ssen zun‰chst Terme in
Maschinencode ¸bersetzt werden.  Dann kommt die
Zustands¸bergangsfunktion und schlieﬂlich die Auswertungsfunktion an
die Reihe.

\subsection{Datenanalyse}
\label{sec:secd-datenanalyse}

Die erste Aufgabe ist dabei zun‰chst, wie immer, die Datenanalyse: Am
Anfang stehen die Terme des angewandten $\lambda$-Kalk¸ls.  Eine
geeignete Repr‰sentation mit Listen und Symbolen l‰ﬂt dabei die Terme
in der "`fortgeschrittenen"' Sprachebene genau wie entsprechenden
Scheme-Terme aussehen:

\noindent\begin{tabular}{lll}
  \texttt{(+ 1 2)} & steht f¸r & $(+~1~2)$\\
  \texttt{(lambda (x) x)} & steht f¸r & $\lambda x.x$\\
  \texttt{((lambda (x) (x x)) (lambda (x) (x x)))} & steht f¸r &
  $(\lambda x.(x~x))~(\lambda x.(x~x))$\\
  etc.
\end{tabular}

Die Datendefinition daf¸r orientiert sich direkt an
Definition~\ref{def:lambda-angewandt}:
%
\begin{verbatim}
 Ein Lambda-Term ist eins der folgenden:
; - ein Symbol (f¸r eine Variable)
; - eine zweielementige Liste (f¸r eine regul‰re Applikation)
; - eine Liste der Form (lambda (x) e) (f¸r eine Abstraktion)
; - ein Basiswert
; - eine Liste mit einem Primitiv als erstem Element
;      (f¸r eine primitive Applikation)
\end{verbatim}
%
Hier die dazu passende Signaturdefinition:
%
\begin{verbatim}
(define term
  (signature
    (mixed symbol
           application
           abstraction
           base
           primitive-application)))
\end{verbatim}
%
Die Signaturen f¸r \texttt{application} etc.\ m¸ssen noch definiert
werden.

Um Verzweigungen ¸ber die Sorte \texttt{term} zu ermˆglichen, m¸ssen
Pr‰dikate f¸r die einzelnen Teilsorten geschrieben werden.  Diese
kˆnnen dann f¸r die Definition der entsprechenden Signaturen benutzt
werden.
%
\begin{verbatim}
(: application? (%a -> boolean))
(define application?
  (lambda (t)
    (and (pair? t)
         (not (equal? 'lambda (first t)))
         (not (primitive? (first t))))))

(define application (signature (predicate application?)))

; Pr‰dikat f¸r Abstraktionen
(: abstraction? (%a -> boolean))
(define abstraction?
  (lambda (t)
    (and (pair? t)
         (equal? 'lambda (first t)))))

(define abstraction (signature (predicate abstraction?)))

; Pr‰dikat f¸r primitive Applikationen
(: primitive-application? (%a -> boolean))
(define primitive-application?
  (lambda (t)
    (and (pair? t)
         (primitive? (first t)))))

(define primitive-application (signature (predicate primitive-application?)))
\end{verbatim}
%
Die Definition l‰ﬂt noch offen, was genau ein "`Basiswert"' und was ein
"`Primitiv"' ist.  Auch hierf¸r werden noch Datendefinitionen
benˆtigt, zuerst f¸r Basiswerte.  Der Einfachheit halber beschr‰nkt
sich die Implementierung erst einmal auf boolesche Werte und Zahlen:
%
\begin{verbatim}
; Ein Basiswert ist ein boolescher Wert oder eine Zahl
\end{verbatim}
%
Damit Basiswerte in Fallunterscheidungen von den anderen Arten von
Termen unterschieden werden kˆnnen, wird ein Pr‰dikat benˆtigt:
%
\begin{verbatim}
; Pr‰dikat f¸r Basiswerte
(: base? (%a -> boolean))
(define base?
  (lambda (v)
    (or (boolean? v) (number? v))))

(define base (signature (predicate base?)))
\end{verbatim}
%
Als n‰chstes sind Primitive gefragt: Am obigen Beispiel ist zu
erkennen, daﬂ z.B.\ \texttt{+} ein Primitiv sein sollte.  Die
Datendefinition f¸r eine kleine beispielhafte Menge von Primitiven ist
wie folgt:
%
\begin{verbatim}
; Ein Primitiv ist eins der Symbole +, -, *, /, =
\end{verbatim}
%
Da die Primitive genau wie die Variablen Symbole sind, stehen die
Primitive als Variablen nicht mehr zur Verf¸gung:  Alle Symbole, die
keine Primitive sind, sind also Variablen.  Das dazugehˆrige Pr‰dikat
ist das folgende:
%
\begin{verbatim}
; Pr‰dikat f¸r Primitive
(: primitive? (%a -> boolean))
(define primitive?
  (lambda (s)
    (or (equal? '+ s)
        (equal? '- s)
        (equal? '* s)
        (equal? '/ s)
        (equal? '= s))))

(define primitive (signature (predicate primitive?)))
\end{verbatim}
%
Bevor nun ein die SECD-Maschine einen Term verarbeiten kann, muﬂ
dieser erst in Maschinencode ¸bersetzt werden.  Dabei entsteht aus
Definition~\ref{def:secd-code} direkt Daten- und Signaturdefinitionen
f¸r Instruktionen und Maschinencode:
%
\begin{verbatim}
; Eine Instruktion ist eins der folgenden:
; - ein Basiswert
; - eine Variable
; - eine Applikations-Instruktion
; - eine Instruktion f¸r eine primitive Applikation
; - eine Abstraktion
(define instruction
  (signature
    (mixed base
           symbol
           ap
           tailap
           prim
           abs))

; Eine Maschinencode-Programm ist eine Liste von Instruktionen.
(define machine-code (signature (list-of instruction)))
\end{verbatim}
%
Bei der Definition von Instruktionen ist wieder einiges Wunschdenken
im Spiel.  Basiswerte und Variablen sind wie bei den Termen.  Die
restlichen F‰lle werden durch eigene Datendefinitionen abgebildet.
Wie schon bei den leeren B‰umen sind Record-Definitionen ohne Felder
im Spiel, die Fallunterscheidungen mˆglich machen:
%
\begin{verbatim}
; Eine Applikations-Instruktion ist ein Wert
;   (make-ap)
(define-record-procedures ap
  make-ap ap?
  ())
(: make-ap (-> ap))

; Die Instruktion f¸r eine primitive Applikation
; ist ein Wert
;   (real-make-prim op arity)
; wobei op ein Symbol und arity die Stelligkeit
; ist
(define-record-procedures prim
  real-make-prim prim?
  (prim-operator prim-arity))
(: make-prim (symbol natural -> prim))

; Eine Abstraktions-Instruktion ist ein Wert
;  (make-abs v c)
; wobei v ein Symbol (f¸r eine Variable) und c
; Maschinencode ist
(define-record-procedures abs
  make-abs abs?
  (abs-variable abs-code))
(: make-abs (symbol machine-code -> abs))
\end{verbatim}
%
Da die Stelligkeit eines Primitivs dem Primitiv fest zugeordnet
ist, ist eine Hilfsprozedur n¸tzlich, die bei der Erzeugung eines
Werts der Sorte \texttt{prim} die Stelligkeit erg‰nzt.
Gl¸cklicherweise haben alle oben eingef¸hrten Primitive die gleiche
Stelligkeit:
%
\begin{verbatim}
; Primitiv erzeugen
(: make-prim (symbol -> prim))
(define make-prim
  (lambda (s)
    (real-make-prim s 2)))
\end{verbatim}
%
Die Einf¸hrung von Primitive mit anderen Stelligkeiten ist Gegenstand
von Aufgabe~\ref{aufgabe:prim-arity}.

\subsection{‹bersetzung in Maschinencode}

Nun, da sowohl Terme als auch der Maschinencode Datendefinitionen
haben, ist es mˆglich, die ‹bersetzung zu programmieren.  Hier sind
Kurzbeschreibung, Signatur und Ger¸st:
%
\begin{verbatim}
; Term in Maschinencode ¸bersetzen
(: term->machine-code (term -> machine-code))
(define term->machine-code
  (lambda (e)
    ...))
\end{verbatim}
%
Da es sich bei \texttt{term} um gemischte Daten handelt, muﬂ~-- wie
immer~-- eine Verzweigung den Rumpf der Prozedur bilden:
%
\begin{verbatim}
(define term->machine-code
  (lambda (e)
    (cond
      ((symbol? e) ...)
      ((application? e) ...)
      ((abstraction? e) ...)
      ((base? e) ...)
      ((primitive-application? e) ...))))
\end{verbatim}
%
Die Implementierung entspricht in den einzelnen F‰llen genau der
‹bersetzungsfunktion $\llbracket\underline{~}\rrbracket$. Die F‰lle
f¸r Variablen und Basiswerte sind, genau wie dort, trivial:
%
\begin{verbatim}
(define term->machine-code
  (lambda (e)
    (cond
      ((symbol? e) (list e))
      ((base? e) (list e))
      ...)))
\end{verbatim}
%
Bei regul‰ren Applikationen werden
Operator und Operand ¸bersetzt, und das ganze zusammen mit einer
\texttt{ap}-Instruktion zu einer Liste zusammengesetzt:
%
\begin{verbatim}
(define term->machine-code
  (lambda (e)
    (cond
      ...
      ((application? e)
       (append (term->machine-code (first e))
               (append (term->machine-code (first (rest e)))
                       (list (make-ap)))))
      ...)))
\end{verbatim}
%
Bei den primitiven Applikationen werden erst einmal die Operanden in
Maschinencode ¸bersetzt, die Resultate aneinandergeh‰ngt, und
schlieﬂlich kommt noch eine \texttt{prim}-Instruktion ans Ende:
%
\begin{verbatim}
(define term->machine-code
  (lambda (e)
    (cond
      ...
      ((primitive-application? e)
       (append
        (append-lists
         (map term->machine-code (rest e)))
        (list (make-prim (first e)))))
      ...)))
\end{verbatim}
%
Dieses St¸ck Code benutzt die Hilfsprozedur \texttt{append-lists}, die
aus einer Liste von Listen eine einzelne Liste macht, indem die
Elemente aneinandergeh‰ngt werden:
%
\begin{verbatim}
; die Elemente einer Liste von Listen aneinanderh‰ngen
(: append-lists ((list-of (list-of %a)) -> (list-of %a)))
(define append-lists
  (lambda (l)
    (fold '() append l)))
\end{verbatim}
%
Zur¸ck zur ‹bersetzung: Eine Abstraktionen wird direkt in eine
\texttt{abs}-Instruktion ¸bersetzt, wobei der Rumpf selbst
noch in Maschinencode ¸bersetzt wird:
%
\begin{verbatim}
(define term->machine-code
  (lambda (e)
    (cond
      ...
      ((abstraction? e)
       (list
        (make-abs (first (first (rest e)))
                  (term->machine-code
                   (first (rest (rest e))))))))))
\end{verbatim}
%

\subsection{Zustands¸bergang und Auswertung}
\label{sec:secd-transition}

Da nun alle $\lambda$-Terme in Maschinencode-Programme ¸bersetzt
werden kˆnnen, ist jetzt die eigentliche SECD-Maschine an der Reihe.
Hier sind erst einmal einige neue Datendefinitionen f‰llig.  Zun‰chst
einmal die Menge $S$ der Stacks:
%
\begin{verbatim}
; Ein Stack ist eine Liste von Werten
(define stack (signature (list-of value)))
\end{verbatim}
%
Die Definition von Werten $W$ kommt etwas sp‰ter an die Reihe.

Umgebungen aus der Menge $E$ sind mathematisch gesehen Mengen aus
Tupeln.  In der Implementierung werden sie dargestellt aus Listen von
\textit{Bindungen\index{Bindung}}, wobei jede Bindung einem Tupel aus
der mathematischen Definition entspricht:

\begin{verbatim}
; Eine Umgebung ist eine Liste von Bindungen.
; Dabei gibt es f¸r jede Variable nur eine Bindung.
(define environment (signature (list-of binding)))

; Eine Bindung (Name: binding) ist ein Wert
;  (make-binding v x)
; wobei v der Name einer Variablen und x der dazugehˆrige Wert ist.

(define-record-procedures binding
  make-binding binding?
  (binding-variable binding-value))
(: make-binding (symbol value -> binding))
\end{verbatim}
% 
Die leere Umgebung wird ˆfter benˆtigt und wird darum schon
vordefiniert:
%
\begin{verbatim}
; die leere Umgebung
(define the-empty-environment empty)
\end{verbatim}
%
Zwei Operationen gibt es f¸r eine Umgebung $e$: die Erweiterung um
eine Bindung $e[v\mapsto w]$ und das Nachschauen einer Bindung
$e(v)$.  Zun‰chst die Erweiterung: die Implementierung entspricht
genau der mathematischen Definition: zun‰chst wird eine eventuell
vorhandene Bindung f¸r $v$ entfernt, dann eine neue Bindung
hinzugef¸gt:
% 
\begin{verbatim}
; eine Umgebung um eine Bindung erweitern
(: extend-environment (environment symbol value -> environment))
(define extend-environment
  (lambda (e v w)
    (make-pair (make-binding v w)
               (remove-environment-binding e v))))
\end{verbatim}
%
F¸r das Entfernen der alten Bindung ist die Hilfsprozedur
\texttt{remove-environment-binding} zust‰ndig.  Sie folgt einmal mehr
strikt der Konstruktionsanleitung f¸r Prozeduren, die Listen akzeptieren:
% FIXME: Konstruktionsanleitung
\begin{verbatim}
; die Bindung f¸r eine Variable aus einer Umgebung entfernen
(: remove-environment-binding (environment symbol -> environment))
(define remove-environment-binding
  (lambda (e v)
    (cond
      ((empty? e) empty)
      ((pair? e)
       (if (equal? v (binding-variable (first e)))
           (rest e)
           (make-pair (first e)
                      (remove-environment-binding (rest e) v)))))))
\end{verbatim} 
%
Auch die zweite Operation, das Nachschauen einer Bindung in der
Umgebung, folgt der Konstruktionsanleitung:
%
% FIXME: Konstruktionsanleitung
%
\begin{verbatim}
; die Bindung f¸r eine Variable in einer Umgebung finden
(: lookup-environment (environment symbol -> value))
(define lookup-environment
  (lambda (e v)
    (cond
      ((empty? e) (violation "unbound variable"))
      ((pair? e)
       (if (equal? v (binding-variable (first e)))
           (binding-value (first e))
           (lookup-environment (rest e) v))))))
\end{verbatim}
%
Damit sind die Operationen auf Umgebungen abgeschlossen.  Als n‰chstes
sind Dumps an der Reihe: $D$ ist als Folge von Tupeln $S\times E\times
C$ definiert, auch genannt \textit{Frames\index{Frame}}.  Hier sind
Daten- und Record-Definition:
%
\begin{verbatim}
; Ein Dump ist eine Liste von Frames

; Ein Frame ist ein Wert
;  (make-frame s e c)
; wobei s ein Stack, e eine Umgebung und c Maschinencode ist.
(define-record-procedures frame
  make-frame frame?
  (frame-stack frame-environment frame-code))
(: make-frame (stack environment machine-code -> frame))
\end{verbatim}
%
Schlieﬂlich fehlt noch eine Repr‰sentation f¸r die Menge $W$ der
Werte:  Ein Wert ist entweder ein Basiswert oder eine Closure.
Basiswerte wurden bereits in Abschnitt~\ref{sec:secd-datenanalyse}
definiert; es fehlen noch Closures, die Tupel aus $V\times C\times E$
sind.  Hier sind die entsprechenden Definitionen:
%
\begin{verbatim}
; Ein SECD-Wert ist ein Basiswert oder eine Closure
(define value (signature (mixed base closure)))

; Eine Closure ist ein Wert
;  (make-closure v c e)
; wobei v die Variable der Lambda-Abstraktion,
; c der Code der Lambda-Abstraktion
; und e ein Environment ist.
(define-record-procedures closure
  make-closure closure?
  (closure-variable closure-code closure-environment))
(: make-closure (symbol machine-code environment -> closure))
\end{verbatim}
%
Mit Hilfe dieser Definitionen ist es mˆglich, eine Daten- und eine
Record-Definition f¸r die Zust‰nde der SECD-Maschine anzugeben, also
die Tupel aus $S\times E\times C\times D$:
%
\begin{verbatim}
; Ein SECD-Zustand ist ein Wert
;  (make-secd s e c d)
; wobei s ein Stack, e eine Umgebung, c Maschinencode
; und d ein Dump ist
(define-record-procedures secd
  make-secd secd?
  (secd-stack secd-environment secd-code secd-dump))
(: make-secd (stack environment machine-code dump -> secd))
\end{verbatim}
%
Damit kann es an die Zustands¸bergangsfunktion gehen.   Sie wird als
Prozedur realisiert, die einen SECD-Zustand akzeptiert und einen neuen
liefert.  Hier sind Kurzbeschreibung, Signatur und Ger¸st:
%
\begin{verbatim}
; Zustands¸bergang berechnen
(: secd-step (secd -> secd))
(define secd-step
  (lambda (state)
    ...))
\end{verbatim}
%
Entsprechend den Regeln der SECD-Maschine muﬂ der Rumpf der Prozedur
eine Verzeigung zwischen den verschiedenen F‰llen bei der
Code-Komponente von \texttt{state} sein.  Diese folgen den
Konstruktionsanleitungen f¸r Listen und f¸r gemischte Daten.  Es ist
bereits an den Regeln abzulesen, daﬂ alle Regeln Zugriff auf die
Komponenten von \texttt{state} benˆtigen.  F¸r diese werden gleich am
Anfang lokale Variablen angelegt:
%
\begin{verbatim}
(define secd-step
  (lambda (state)
    (let ((stack (secd-stack state))
          (environment (secd-environment state))
          (code (secd-code state))
          (dump (secd-dump state)))
      (cond
        ((pair? code)
         (cond
           ((base? (first code)) ...)
           ((symbol? (first code)) ...)
           ((prim? (first code)) ...)
           ((abs? (first code)) ...)
           ((ap? (first code)) ...)))
        ((empty? code) ...)))))
\end{verbatim}
%
In diesem Ger¸st werden nun die Regeln direkt abgebildet.  Hier zur
Erinnerung noch einmal die erste Regel f¸r Basiswerte:
%
\begin{displaymath}
  (\underline{s}, e, b\underline{c}, \underline{d})
  \hookrightarrow
  (b\underline{s}, e, \underline{c}, \underline{d})
\end{displaymath}
%
Hier der passende Code daf¸r:
%
\begin{verbatim}
(define secd-step
  (lambda (state)
      ...
        (cond
          ((base? (first code))
           (make-secd (make-pair (first code) stack)
                      environment
                      (rest code)
                      dump))
           ...)
      ...))
\end{verbatim}
%
Hier die Regel f¸r Variablen:
\begin{displaymath}
  (\underline{s}, e, v\underline{c}, \underline{d})
  \hookrightarrow
  (e(v)\underline{s}, e, \underline{c}, \underline{d})
\end{displaymath}
%
Hier der entsprechende Code:
%
\begin{verbatim}
(define secd-step
  (lambda (state)
      ...
        (cond
          ((symbol? (first code))
           (make-secd (make-pair
                        (lookup-environment environment (first code))
                        stack)
                      environment
                      (rest code)
                      dump))
          ...)
      ...))
\end{verbatim}
%
Die Regel f¸r primitive Applikationen ist etwas aufwendiger:
%
\begin{eqnarray*}
  (b_k\ldots b_1 \underline{s}, e, \mathtt{prim}_{F^k}\underline{c}, \underline{d})
  &\hookrightarrow&
  (b\underline{s}, e, \underline{c}, \underline{d})
  \\ && \textrm{wobei $F^k\in\Sigma^k$ und $F_B(b_1,\ldots,b_k) = b$}
\end{eqnarray*}
%
F¸r die Implementierung werden Hilfsprozeduren gebraucht, welche die
Argumente vom Stack holen und in der Reihenfolge umdrehen, die
Argumente vom Stack entfernen und schlieﬂlich die eigentliche
$\delta$-Transition berechnen:
%
\begin{verbatim}
(define secd-step
  (lambda (state)
      ...
        (cond
          ...
          ((prim? (first code))
           (make-secd (make-pair
                       (apply-primitive
                         (prim-operator (first code))
                         (take-reverse (prim-arity (first code)) stack))
                       (drop (prim-arity (first code)) stack))
                      environment
                      (rest code)
                      dump))
           ...)
       ...))
\end{verbatim}
%
Die Prozedur \texttt{drop} ist gerade die in
Aufgabe~\ref{ex:kartenspiel} geforderte Prozedur:
%
\begin{verbatim}
; die ersten Elemente einer Liste weglassen
(: drop (natural (list-of %a) -> (list-of %a)))
\end{verbatim}
%
Die \texttt{take-reverse}-Prozedur ist das Pendant zu \texttt{drop},
das die ersten $n$ Elemente einer Liste in umgekehrter Reihenfolge
liefert.  Dies ist am einfachsten ¸ber eine endrekursive Hilfsprozedur
zu erledigen~-- aus Kapitel~\ref{cha:accu} ist ja bekannt, daﬂ bei
endrekursiver Konstruktion von Listen gerade immer die Reihenfolge
umgedreht wird:
%
\begin{verbatim}
; die ersten Elemente einer Liste in umgekehrter Reihenfolge berechnen
(: take-reverse (natural (list-of %a) -> (list-of %a)))
(define take-reverse
  (lambda (n l)
    ;; (: loop (natural (list-of %a) (list-of %a) -> (list-of %a)))
    (letrec ((loop (lambda (n l r)
                     (if (= n 0)
                         r
                         (loop (- n 1) (rest l) (make-pair (first l) r))))))
      (loop n l '()))))
\end{verbatim}
%
Aus einem Primitiv und einer Liste von Argumenten berechnet
\texttt{apply-primitive} das Resultat der primitiven Applikation.
Dabei handelt es sich bei \texttt{primitive} um eine
Fallunterscheidung, der Rumpf der Prozedur ist also eine entsprechende
Verzweigung:
%
\begin{verbatim}
; Delta-Transition berechnen
(: apply-primitive (primitive (list-of value) -> value))
(define apply-primitive
  (lambda (p args)
    (cond
      ((equal? p '+)
       (+ (first args) (first (rest args))))
      ((equal? p '-)
       (- (first args) (first (rest args))))
      ((equal? p '=)
       (= (first args) (first (rest args))))
      ((equal? p '*)
       (* (first args) (first (rest args))))
      ((equal? p '/)
       (/ (first args) (first (rest args)))))))
\end{verbatim}
%
Die Regel f¸r Abstraktionen macht aus einer Abstraktion eine Closure:
\begin{displaymath}
  (\underline{s}, e, (v, \underline{c'}) \underline{c}, \underline{d})
  \hookrightarrow
  ((v, \underline{c'}, e) \underline{s}, e, \underline{c}, \underline{d})
\end{displaymath}
%
Der Code macht dies genauso:
%
\begin{verbatim}
(define secd-step
  (lambda (state)
      ...
        (cond
          ...
          ((abs? (first code))
           (make-secd (make-pair
                        (make-closure (abs-variable (first code))
                                      (abs-code (first code))
                                      environment)
                        stack)
                      environment
                      (rest code)
                      dump)))
       ...)))
\end{verbatim}
%
Hier die Regel f¸r die Applikation:
%
\begin{displaymath}
  (w (v,\underline{c'}, e') \underline{s}, e, \mathtt{ap}~\underline{c}, \underline{d})
  \hookrightarrow
  (\epsilon, e'[v\mapsto w], \underline{c'}, (\underline{s}, e, \underline{c}) \underline{d})
\end{displaymath}
%
Hier der Code dazu:
%
\begin{verbatim}
(define secd-step
  (lambda (state)
      ...
        (cond
          ...
          ((ap? (first code))
           (let ((closure (first (rest stack))))
             (make-secd empty  
                        (extend-environment
                         (closure-environment closure)
                         (closure-variable closure)
                         (first stack))
                        (closure-code closure)
                        (make-pair
                         (make-frame (rest (rest stack))
                                     environment (rest code))
                         dump))))
          ...)
      ...))
\end{verbatim}
%
Schlieﬂlich bleibt noch der Code f¸r die R¸ckgabe eines Wertes von
einer Prozedur.  Hier ist die Regel:
%
\begin{displaymath}
  (w, e, \epsilon, (\underline{s'}, e', \underline{c'}) \underline{d})
  \hookrightarrow
  (w\underline{s'}, e', \underline{c'}, \underline{d})
\end{displaymath}
%
Hier ist der Code dazu:
%
\begin{verbatim}
(define secd-step
  (lambda (state)
      ...
      (cond
        ...
        ((empty? code)
         (let ((f (first dump)))
           (make-secd
            (make-pair (first stack)
                       (frame-stack f))
            (frame-environment f)
            (frame-code f)
            (rest dump)))))
       ...))
\end{verbatim}
%
Damit die SECD-Maschine in Betrieb genommen werden kann, muﬂ ein Term
$e$ noch in einen Anfangszustand $(\epsilon, \varnothing, \llbracket
e\rrbracket, \epsilon)$ ¸bersetzt werden.  Das erledigt folgende
Hilfsprozedur:
%
\begin{verbatim}
; Aus Term SECD-Anfangszustand machen
(: inject-secd (term -> secd))
(define inject-secd
  (lambda (e)
    (make-secd empty
               the-empty-environment
               (term->machine-code e)
               empty)))
\end{verbatim}
%
Damit l‰ﬂt sich die Maschine schon ausprobieren:
%
\begin{alltt}
(secd-step (inject-secd '(+ 1 2)))
\evalsto{}#<record:secd (1) () (2 #<record:prim + 2>) ()>
(secd-step (secd-step (inject-secd '(+ 1 2))))
\evalsto{}#<record:secd (2 1) () (#<record:prim + 2>) ()>
(secd-step (secd-step (secd-step (inject-secd '(+ 1 2)))))
\evalsto{}#<record:secd (3) () () ()>
\end{alltt}
%
Es fehlt noch die Auswertungsfunktion $\mathrm{eval}_\mathrm{SECD}$,
die eine Hilfsprozedur benˆtigt, um die reflexiv-transitive H¸lle des
Zustands¸bergangs $\hookrightarrow^*$ benˆtigt:
%
\begin{verbatim}
; bis zum Ende Zustands¸berg‰nge berechnen
(: secd-step* (secd -> secd))
(define secd-step*
  (lambda (state)
    (if (and (empty? (secd-code state))
             (empty? (secd-dump state)))
        state
        (secd-step* (secd-step state)))))
\end{verbatim}
%
Die Auswertungsfunktion orientiert sich direkt an der mathematischen
Definition:
%
\begin{verbatim}
; Evaluationsfunktion zur SECD-Maschine berechnen
(: eval-secd (term -> (mixed value (one-of 'function))))
(define eval-secd
  (lambda (e)
    (let ((val (first
                (secd-stack
                 (secd-step* 
                  (inject-secd e))))))
      (if (base? val)
          val
          'proc))))
\end{verbatim}
%
Damit l‰uft die SECD-Maschine:
%
\begin{alltt}
(eval-secd '(((lambda (x) (lambda (y) (+ x y))) 1) 2))
\evalsto{}3
\end{alltt}

\section{Die endrekursive SECD-Maschine}

Die SECD-Maschine hat einen Schˆnheitsfehler: Bei endkursiven
Applikationen sollte sie eigentlich, wie in Scheme, keinerlei
zus‰tzlichen Platz verbrauchen, da kein Kontext anf‰llt.  Folgende
Beispielauswertung f¸r den Term $(\lambda x.x~x)~(\lambda x.x~x)$
zeigt aber, daﬂ der Zustand mit fortschreitender Auswertung immer
grˆﬂer wird:
%
% (secd-step*/tex (inject-secd '((lambda (x) (x x)) (lambda (x) (x x)))))
\begin{displaymath}\tiny
  \begin{array}{l@{}llll}
&(\epsilon, &\varnothing, &(x, x~x~\mathtt{ap})~(x, x~x~\mathtt{ap})~\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&((x, x~x~\mathtt{ap}, \varnothing), &\varnothing, &(x, x~x~\mathtt{ap})~\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&((x, x~x~\mathtt{ap}, \varnothing)~(x, x~x~\mathtt{ap}, \varnothing), &\varnothing, &\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&(\epsilon, &\{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, &x~x~\mathtt{ap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{ap}, \varnothing), &\{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, &x~\mathtt{ap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{ap}, \varnothing)~(x, x~x~\mathtt{ap}, \varnothing), &\{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, &\mathtt{ap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&(\epsilon, &\{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, &x~x~\mathtt{ap}, &(\epsilon, \{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, \epsilon)~(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{ap}, \varnothing), &\{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, &x~\mathtt{ap}, &(\epsilon, \{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, \epsilon)~(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{ap}, \varnothing)~(x, x~x~\mathtt{ap}, \varnothing), &\{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, &\mathtt{ap}, &(\epsilon, \{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, \epsilon)~(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&(\epsilon, &\{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, &x~x~\mathtt{ap}, &(\epsilon, \{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, \epsilon)~(\epsilon, \{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, \epsilon)~(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{ap}, \varnothing), &\{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, &x~\mathtt{ap}, &(\epsilon, \{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, \epsilon)~(\epsilon, \{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, \epsilon)~(\epsilon, \varnothing, \epsilon))
\\
& \ldots
  \end{array}
\end{displaymath}
%
Damit ist die SECD-Maschine, so wie ist, als Ausf¸hrungsmodell f¸r
Scheme ungeeignet.  Dieses Manko l‰ﬂt sich zum Gl¸ck reparieren: Die
SECD-Maschine muﬂ endrekursive und "`normale"' Applikationen
unterschiedlich behandeln.  Dazu wird eine neue Instruktion namens
$\mathtt{tailap}$ eingef¸hrt, die wie $\mathtt{ap}$ eine Applikation
durchf¸hrt, aber eine endrekursive Applikation signalisiert:
%
\begin{eqnarray*}
  I &=& \ldots\\
  &&\cup \{ \mathtt{tailap} \}
\end{eqnarray*}
%
Als n‰chstes muﬂ die ‹bersetzungsfunktion von Termen in Maschinencode
ge‰ndert werden:  Applikationen, die Kontext um sich herum haben,
sollen mit $\mathtt{ap}$ ¸bersetzt werden, solche ohne Kontext mit
$\mathtt{tailap}$.  Da der Applikation allein der Kontext nicht
anzusehen ist, sondern nur dem Term "`drumherum"', wird die
‹bersetzungsfunktion $\llbracket \underline{~} \rrbracket$ in zwei
Teile aufgespalten: f¸r einen Term $e$ wird die Auswertungsfunktion $\llbracket\underline{~}\rrbracket$ immer dann benutzt, wenn um $e$ Kontext steht.  Eine
weitere Funktion $\llbracket \underline{~} \rrbracket'$ wird immer
dann aufgerufen, wenn \emph{kein} Kontext drumherum steht.

Kontext entsteht seinerseits immer durch Funktionsapplikationen.  Bei
der Auswertung eines Terms $(e_0~e_1)$ muﬂ \emph{nach} $e_0$ noch
$e_1$ ausgewertet werden, und nach Auswertung von $e_1$ muﬂ noch die
Applikation durchgef¸hrt werden.  Sowohl $e_0$ als auch $e_1$ stehen
in Kontext.  ƒhnlich ist es bei den Argumenten von primitiven
Applikationen.

Auf der anderen Seite schneiden Abstraktionen f¸r ihren Rumpf den
Kontext erst einmal ab: Der Rumpf einer Abstraktion kommt schlieﬂlich bei der
Auswertung der Abstraktion noch gar nicht zum Zug.  Ob er Kontext hat
oder nicht, entscheidet sich erst bei der Applikation.
Dementsprechend schalten Applikationen und Abstraktionen zwischen den
beiden Funktionen $\llbracket \underline{~} \rrbracket$ und
$\llbracket \underline{~} \rrbracket'$ hin und her:
%
\begin{eqnarray*}
  \llbracket \underline{~} \rrbracket &:& \mathcal{L}_{\lambda{}A} \rightarrow C\\
  \llbracket e \rrbracket &\deq&
  \begin{cases}
    b & \textrm{falls $e = b \in B$}\\
    v & \textrm{falls $e = v \in V$}\\
    \llbracket e_0\rrbracket~\llbracket e_1\rrbracket~\mathtt{ap}
    & \textrm{falls $e = (e_0~e_1)$}\\
    \llbracket e_1\rrbracket~\ldots~\llbracket e_k\rrbracket~\mathtt{prim}_{F^k}
    & \textrm{falls $e = (F~e_1~\ldots~e_k)$}\\
    (v, \llbracket e_0\rrbracket') & \textrm{falls $e = \lambda v.e_0$}
  \end{cases}\\[1ex]
  \llbracket \underline{~} \rrbracket' &:& \mathcal{L}_{\lambda{}A} \rightarrow C\\
  \llbracket e \rrbracket' &\deq&
  \begin{cases}
    b & \textrm{falls $e = b \in B$}\\
    v & \textrm{falls $e = v \in V$}\\
    \llbracket e_0\rrbracket~\llbracket e_1\rrbracket~\mathtt{tailap}
    & \textrm{falls $e = (e_0~e_1)$}\\
    \llbracket e_1\rrbracket~\ldots~\llbracket e_k\rrbracket~\mathtt{prim}_{F^k}
    & \textrm{falls $e = (F~e_1~\ldots~e_k)$}\\
    (v, \llbracket e_0\rrbracket') & \textrm{falls $e = \lambda v.e_0$}
  \end{cases}
\end{eqnarray*}
%
Die ‹bersetzungsfunktion hat die eigentliche Arbeit geleistet: Jetzt
muﬂ nur noch eine Zustands¸bergangsregel her, die $\mathtt{tailap}$
verarbeitet.  Diese ergibt sich direkt aus den Regeln f¸r
$\mathtt{ap}$ und die R¸ckgabe eines Wertes:  $\mathtt{tailap}$
funktioniert so, wie $\mathtt{ap}$ direkt gefolgt von der
R¸ckgaberegel.  Hier sind die beiden Regeln noch einmal zur Erinnerung:
%
\begin{eqnarray*}
   (w (v,\underline{c'}, e') \underline{s}, e, \mathtt{ap}~\underline{c}, \underline{d})
  &\hookrightarrow&
  (\epsilon, e'[v\mapsto w], \underline{c'}, (\underline{s}, e, \underline{c}) \underline{d})
  \\
  (w, e, \epsilon, (\underline{s'}, e', \underline{c'}) \underline{d})
  &\hookrightarrow&
  (w\underline{s'}, e', \underline{c'}, \underline{d})
\end{eqnarray*}
%
Da die erste Regel ein neues Dump-Frame erzeugt und die zweite ein
Dump-Frame "`vernichtet"', entf‰llt diese Arbeit in der Regel f¸r
$\mathtt{tailap}$:
%
\begin{eqnarray*}
  (w (v,\underline{c'}, e') \underline{s}, e, \mathtt{tailap}~\underline{c}, \underline{d})
  &\hookrightarrow&
  (\underline{s}, e'[v \mapsto w], \underline{c'}, \underline{d})
\end{eqnarray*}
%
Damit l‰uft das Beispiel zwar immer noch endlos, aber immerhin, ohne
immer mehr Platz zu verbrauchen:
%
\begin{displaymath}\scriptsize
  \begin{array}{l@{}llll}
 \hookrightarrow{}&(\epsilon, &\varnothing, &(x, x~x~\mathtt{tailap})~(x, x~x~\mathtt{tailap})~\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&((x, x~x~\mathtt{tailap}, \varnothing), &\varnothing, &(x, x~x~\mathtt{tailap})~\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&((x, x~x~\mathtt{tailap}, \varnothing)~(x, x~x~\mathtt{tailap}, \varnothing), &\varnothing, &\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&(\epsilon, &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &x~x~\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{tailap}, \varnothing), &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &x~\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{tailap}, \varnothing)~(x, x~x~\mathtt{tailap}, \varnothing), &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&(\epsilon, &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &x~x~\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{tailap}, \varnothing), &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &x~\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{tailap}, \varnothing)~(x, x~x~\mathtt{tailap}, \varnothing), &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&(\epsilon, &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &x~x~\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{tailap}, \varnothing), &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &x~\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{tailap}, \varnothing)~(x, x~x~\mathtt{tailap}, \varnothing), &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&(\epsilon, &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &x~x~\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{tailap}, \varnothing), &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &x~\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))
 \end{array}
\end{displaymath}
Die Implementierung der endrekursiven SECD-Maschine ist Gegenstand von
‹bungsaufgabe~\ref{aufgabe:secd-endekursiv-implementieren}.


\section{Der $\lambda$-Kalk¸l mit Zustand}

Der bisher vorgestellte $\lambda$-Kalk¸l liefert keinerlei Erkl‰rung
f¸r das Verhalten von Zuweisungen.  Tats‰chlich hat sich schon in
Abschnitt~\ref{sec:assignment-problems} angedeutet, daﬂ Zuweisungen
die Formalisierung deutlich erschweren.  Mˆglich ist es trotzdem, und
dieser Abschnitt zeigt, wie es geht.

Als erstes muﬂ wieder einmal die Sprache des $\lambda$-Kalk¸ls
erweitert werden, diesmal um \texttt{set!}-Ausdr¸cke:
%
\begin{definition}[Sprache des angewandten $\lambda$-Kalk¸ls mit Zustand
  $\mathcal{L}_{\lambda{}S}$]\index{angewandter $\lambda$-Kalk¸l}\index{Zustand}
  Sei $V$ eine abz‰hlbare Menge von Variablen.  Sei $B$ eine Menge von
  \textit{Basiswerten\index{Basiswert}} mit $\mathtt{void} \in B$.
  Sei f¸r eine nat¸rliche Zahl $n$ und $i \in \{1, \ldots, n\}$
  jeweils $\Sigma^i$ eine Menge von \textit{$i$-stelligen
    Primitiva\index{Primitivum}}.  Jedem $F^i\in\Sigma^i$ ist eine
  $i$-stellige Funktion $F_B^i: B\times\ldots\times B \rightarrow
  B$~-- ihre \textit{Operation}~-- zugordnet.
  Seit $A$ eine abz‰hlbare Menge von Adressen mit $V\cap A =
  \varnothing$.\index{Adresse}. 

  Die Sprache des angewandten $\lambda$"=Kalk¸ls mit Zustand, die
  Menge der \textit{angewandten $\lambda$-Terme mit Zustand},
  $\mathcal{L}_{\lambda{}S}$\index{L@$\mathcal{L}_{\lambda{}S}$}, ist
  durch folgende Grammatik definiert:
  \begin{grammar}
    \meta{$\mathcal{L}_{\lambda{}S}$} \: \meta{$V$}
    \> \| (\meta{$\mathcal{L}_{\lambda{}S}$} \meta{$\mathcal{L}_{\lambda{}S}$})
    \> \| ($\lambda$\meta{$V$}.\meta{$\mathcal{L}_{\lambda{}S}$})
    \> \| \meta{$B$}
    \> \| (\meta{$\Sigma^1$}~\meta{$\mathcal{L}_{\lambda{}S}$})
    \> \| (\meta{$\Sigma^2$}~\meta{$\mathcal{L}_{\lambda{}S}$}~\meta{$\mathcal{L}_{\lambda{}S}$})
    \> \ldots
    \> \| (\meta{$\Sigma^n$}~\meta{$\mathcal{L}_{\lambda{}S}$}~\ldots~\meta{$\mathcal{L}_{\lambda{}S}$})  \quad \textrm{($n$-mal)}
    \> \| (set! \meta{V} \meta{$\mathcal{L}_{\lambda{}S}$})
  \end{grammar}
  %
\end{definition}
%
Der \texttt{void}-Wert wird als R¸ckgabewert von
\texttt{set!}-Ausdr¸cken dienen.

Um Reduktionsregeln f¸r Zuweisungen zu bilden, ist es notwendig, den
Begriff des \textit{Speichers\index{Speicher}} in den $\lambda$-Kalk¸l
einzuf¸hren: Im $\lambda$-Kalk¸l mit Zustand stehen Variablen nicht
mehr f¸r Werte, die f¸r sie eingesetzt werden kˆnnen, sondern f¸r
\textit{Speicherzellen\index{Speicherzelle}}.  Eine Speicherzelle ist
ein Ort im Speicher, der einen Wert aufnimmt, der auch wieder
ver‰ndert werden kann.  Dabei wird jede Speicherzelle durch eine
\textit{Adresse\index{Adresse}} identifiziert.  Eine Adresse ist eine
abstrakte Grˆﬂe, es kommt also gar nicht darauf an, um was f¸r
eine Art Wert es sich handelt~-- im realen Computer ist eine Adresse
in der Regel einfach eine Zahl.  In diesem Abschnitt steht $A$ f¸r die
Menge der Adressen, die abz‰hlbar sein sollte.

Ein Speicher aus der Menge $M$ ist eine Zuordnung zwischen Adressen aus $A$
und Werten\index{Wert}.  Die Werte sind wie schon im normalen
$\lambda$-Kalk¸l die Basiswerte und die Abstraktionen~-- hier bekommen
sie, weil sie eine Rolle in den Reduktionsregeln spielen, den Namen
$X$:
%
\begin{eqnarray*}
  M &=& \mathcal{P}(A\times X)\\
  X &=& B \cup \{ \lambda v.e | \lambda v.e \in \mathcal{L}_{\lambda{}S} \}
\end{eqnarray*}

Um Reduktionsregeln f¸r den $\lambda$-Kalk¸l mit Zustand zu
formulieren, muﬂ $\mathcal{L}_{\lambda{}S}$ noch erweitert werden,
damit die Adressen ins Spiel kommen: Adressen werden Terme und sind
auf der linken Seite von Zuweisungen zul‰ssig:
%
\begin{grammar}
  \meta{$\mathcal{L}_{\lambda{}S}$} \: \ldots
  \> \| \meta{A}
  \> \| (set! \meta{A} \meta{$\mathcal{L}_{\lambda{}S}$})
\end{grammar}
%
Adressen tauchen dabei nur als Zwischenschritte bei der Reduktion auf;
sie sind nicht daf¸r gedacht, daﬂ sie der Programmierer in ein
Programm schreibt.

Da das bisherige Substitutionsprinzip bei Zuweisungen nicht mehr funktioniert, reicht es
nicht, die Reduktionsregeln f¸r den $\lambda$-Kalk¸l mit Zustand
einfach nur auf Termen auszudr¸cken: Ein Term, der ja Adressen
enthalten kann, ergibt nur Sinn, wenn er mit einem Speicher kombiniert
wird.  Die Reduktionsregeln ¸berf¸hren somit immer ein Paar, bestehend aus
einem Term und einem Speicher in ein ebensolches Paar.  Hierbei wird der
Einfachheit halber kein Unterschied mehr zwischen den verschiedenen
Arten der Reduktion gemacht:
%
\begin{eqnarray*}
  b, m &\rightarrow& a, m[a\mapsto b] \textrm{ wobei $a$ frisch}
  \\
  \lambda v.e, m &\rightarrow&
  a, m[a\mapsto \lambda v.e]  \textrm{ wobei $a$ frisch}
  \\
  (a_0~a_1), m &\rightarrow& e[v\mapsto a], m[a\mapsto m(a_1)]
  \textrm{ wobei $m(a_0) = \lambda v.e$ und $a$ frisch} 
  \\
  (\mathtt{set!}~a_0~a_1), m &\rightarrow& \mathtt{void}, m[a_0\mapsto m(a_1)]
  \\
  (F^k a_1 \ldots a_k), m &\rightarrow& a, m[a\mapsto F_B(b_1, \ldots, b_k)] \textrm{
    wobei $b_i = m(a_i) \in B$, $a$ frisch}
\end{eqnarray*}
%
Die Formulierung "`$a$ frisch"' bedeutet dabei, daﬂ $a$ eine Adresse
sein sollte, die in $m$ bisher noch nicht benutzt wurde.  Die Operation
$m[a\mapsto x]$ ist ‰hnlich wie bei Umgebungen definiert: der alte
Speicherinhalt bei $a$ wird zun‰chst entfernt, und dann eine neue
Zuordnung f¸r $a$ nach $x$ hinzugef¸gt:
%
\begin{displaymath}
  m[a\mapsto x] \deq (e \setminus \{ (a, x') | (a, x') \in m) \cup \{
    (a, x) \}
\end{displaymath}
%
Die Regeln sind immer noch ¸ber Substitution definiert, allerdings
werden f¸r Variablen jetzt nicht mehr Werte sondern Adressen
eingesetzt.  Sie werden, wie beim normalen Call-by-Value-Kalk¸l auch,
auf Subterme fortgesetzt, die mˆglichst weit links innen stehen.

Im folgenden Beispiel stehen fettgedruckte Zahlen ${\bf
0}$, ${\bf 1}$ f¸r Adressen. Die Redexe sind jeweils
unterstrichen:
%
{\small
\begin{displaymath}
  \begin{array}{l}
    ((\lambda x.((\lambda y.x) (\mathtt{set!}~x~(+~x~1))))~12), \varnothing
    \\
    \rightarrow({\bf 0}~\underline{12}), \{ ({\bf 0}, \lambda x.((\lambda
    y.x) (\mathtt{set!}~x~(+~x~1)))) \}
    \\
    \rightarrow\underline{({\bf 0}~{\bf 1})}, \{ ({\bf 0}, \lambda x.((\lambda
    y.x) (\mathtt{set!}~x~(+~x~1)))), ({\bf 1}, 12) \}
    \\
    \rightarrow 
    (\underline{(\lambda y.{\bf 2})} (\mathtt{set!}~{\bf
    2}~(+~{\bf 2}~1))),
    \{ ({\bf 0}, \lambda x.((\lambda
    y.x) (\mathtt{set!}~x~(+~x~1)))), ({\bf 1}, 12), ({\bf
    2}, 12)\}\\
    \rightarrow 
    ({\bf 3}~(\mathtt{set!}~{\bf
    2}~(+~{\bf 2}~\underline{1}))),
    \\
    \quad
    \{ ({\bf 0}, \lambda x.((\lambda
    y.x) (\mathtt{set!}~x~(+~x~1)))), ({\bf 1}, 12), ({\bf
    2}, 12), ({\bf 3}, (\lambda y.{\bf 2}) \}
    \\
    \rightarrow 
    ({\bf 3}~(\mathtt{set!}~{\bf
    2}~\underline{(+~{\bf 2}~{\bf 4})})),
    \\
    \quad
    \{ ({\bf 0}, \lambda x.((\lambda
    y.x) (\mathtt{set!}~x~(+~x~1)))), ({\bf 1}, 12), ({\bf
    2}, 12), ({\bf 3}, (\lambda y.{\bf 2}),
    ({\bf 4}, 1) \}\\
    \rightarrow 
    ({\bf 3} \underline{(\mathtt{set!}~{\bf
      2}~{\bf 5})}),
    \\
    \quad
    \{ ({\bf 0}, \lambda x.((\lambda
    y.x) (\mathtt{set!}~x~(+~x~1)))), ({\bf 1}, 12), ({\bf
    2}, 12), ({\bf 3}, (\lambda y.{\bf 2}),
    ({\bf 4}, 1), ({\bf 5}, 13) \}
    \\
    \rightarrow 
    ({\bf 3}~\mathtt{void}),
    \\
    \quad
    \{ ({\bf 0}, \lambda x.((\lambda
    y.x) (\mathtt{set!}~x~(+~x~1)))), ({\bf 1}, 12), ({\bf
    2}, 13), ({\bf 3}, (\lambda y.{\bf 2}),
    ({\bf 4}, 1), ({\bf 5}, 13) \}
    \\
    \rightarrow 
    \underline{({\bf 3}~{\bf 6})},
    \\
    \quad
    \{ ({\bf 0}, \lambda x.((\lambda
    y.x) (\mathtt{set!}~x~(+~x~1)))), ({\bf 1}, 12), ({\bf
    2}, 13), ({\bf 3}, (\lambda y.{\bf 2}),
    ({\bf 4}, 1), ({\bf 5}, 13), ({\bf 6}, \mathtt{void}) \}
    \\
    \rightarrow 
    {\bf 2},
    \\
    \quad    \{ ({\bf 0}, \lambda x.((\lambda
    y.x) (\mathtt{set!}~x~(+~x~1)))), ({\bf 1}, 12), ({\bf
    2}, 13), ({\bf 3}, (\lambda y.{\bf 2}),
    ({\bf 4}, 1), ({\bf 5}, 13), ({\bf 6}, \mathtt{void}) \}
  \end{array}
\end{displaymath}
}
%
Der Endausdruck steht f¸r die Speicherzelle an Adresse ${\bf
2}$, wo der Wert $13$ steht.  Es ist sichtbar, daﬂ die
Auswertungsmaschinerie durch die Einf¸hrung von Zustand deutlich
komplizierter wird.

\section{Die SECDH-Maschine}
\index{sec:SECDH-Maschine}

Die SECD-Maschine ist nicht m‰chtig genug, um den $\lambda$-Kalk¸l mit
Zustand zu modellieren: Es fehlt ein Speicher.  Darum muﬂ das
Maschinen-Pendant zum $\lambda$-Kalk¸l mit Zustand um eine
Speicher-Komponente erweitert werden: Heraus kommt die
\textit{SECDH-Maschine}, um die es in diesem Abschnitt geht.

Der Maschinencode f¸r die SECDH-Maschine ist dabei genau wie bei der
SECD-Maschine, nur daﬂ eine spezielle Zuweisungsoperation hinzukommt:
%
\begin{grammar}
  \meta{I} \: \ldots
  \> \| :=
\end{grammar}
%
Die ‹bersetzungsfunktion produziert diese neue Instruktion bei
\texttt{set!}-Ausdr¸cken:
%
\begin{eqnarray*}
  \llbracket e \rrbracket &\deq&
  \begin{cases}
    \ldots\\
    v~\llbracket e'\rrbracket~\mathtt{:=}
    & \textrm{falls $e = (\mathtt{set!}~v~e')$}
  \end{cases}
\end{eqnarray*}  
%
Der Begriff der Adresse aus der Menge $A$ wird direkt aus dem Kalk¸l
¸bernommen.  ƒhnlich wie im Kalk¸l landen Zwischenergebnisse nicht
mehr direkt auf dem Stack, sondern stattdessen landen ihre Adressen im
Speicher.  Dementsprechend bilden nun Umgebungen Variablen auf
Adressen ab.  Die neue Komponente $H$ ist gerade der Speicher, auch
genannt \textit{Heap\index{Heap}}, der die Adressen auf Werte
abbildet:
%
\begin{eqnarray*}
  S &=& A^{\ast}\\
  E &=& \mathcal{P}(V\times A)\\
  D &=& (S\times E\times C)^{\ast}\\
  H &=& \mathcal{P}(A\times W)\\
  W &=& B \cup (V\times C\times E)
\end{eqnarray*}
%
Die Regeln f¸r die SECDH-Maschine sind analog zu den Regeln f¸r die
SECD-Maschine.  Zwei Hauptunterschiede gibt es dabei:
%
\begin{itemize}
\item Der Heap aus $H$ gehˆrt nun zum Zustand dazu.  Anders als die
  Umgebung wird er nicht bei der Bildung von Closures "`eingepackt"':
  Stattdessen wird der Heap stets linear von links nach rechts durch
  Regeln durchgef‰delt.
\item Zwischenergebnisse nehmen stets den Umweg ¸ber den Heap: Immer,
  wenn ein neues Zwischenergebnis entsteht, wird es bei einer neuen
  Adresse im Heap abgelegt. Auf dem Stack landen die
  Adressen der Zwischenergebnisse.
\end{itemize}

\begin{eqnarray*}
  \hookrightarrow &\in& \mathcal{P}((S\times E\times C\times D\times H) \times (S\times E\times C\times D\times H))\\
  (\underline{s}, e, b\underline{c}, \underline{d}, h)
  &\hookrightarrow& 
  (a\underline{s}, e, \underline{c}, \underline{d}, h[a \mapsto b] )
  \\ && \textrm{wobei $a$ frisch}
  \\
  (\underline{s}, e, v\underline{c}, \underline{d}, h)
  &\hookrightarrow&
  (e(v)\underline{s}, e, \underline{c}, \underline{d}, h)
  \\
  (a_k\ldots a_1\underline{s}, e, \mathtt{prim}_{F^k}\underline{c},
  \underline{d}, h)
  &\hookrightarrow&
  (a\underline{s}, e, \underline{c}, \underline{d}, h[a\mapsto b] )
  \\ && \textrm{wobei $a$ frisch, $b_i = h(a_i)$ und $F^k\in\Sigma^k$ und $F^k_B(b_1,\ldots,b_k) = b$}
  \\
  (a_1a_0\underline{s}, e, \mathtt{:=} \underline{c}, \underline{d}, h)
  &\hookrightarrow&
  (a\underline{s}, e, \underline{c}, \underline{d}, h[a_0 \mapsto
  h(a_1)][a\mapsto \mathtt{void}] )
  \\ && \textrm{wobei $a$ frisch}
  \\
  (\underline{s}, e, (v, \underline{c'})\underline{c}, \underline{d},
  h)
  &\hookrightarrow&
  (a\underline{s}, e, \underline{c}, \underline{d}, h[a \mapsto (v,
  \underline{c'}, e)] )
  \\ && \textrm{wobei $a$ frisch}
  \\
  (a_1a_0\underline{s}, e, \mathtt{ap}\underline{c}, \underline{d}, h)
  &\hookrightarrow&
  (\epsilon, e'[v\mapsto a], \underline{c'}, (\underline{s}, e,
  \underline{c}) \underline{d}, h[a\mapsto h(a_1)])
  \\ && \textrm{wobei $a$ frisch und $h(a_0) = (v, \underline{c'}, e')$}
  \\
  (a, e, \epsilon, (\underline{s'}, e', \underline{c'}) \underline{d}, h)
  &\hookrightarrow&
  (a\underline{s'}, e', \underline{c'}, \underline{d}, h)
\end{eqnarray*}

Entsprechend muﬂ die Auswertungsfunktion das Endergebnis im Heap nachschauen:

\begin{eqnarray*}
  \mathit{eval}_\mathit{SECD} & \in & \mathcal{L}_{\lambda{}S} \times Z\\
  \mathit{eval}_\mathit{SECD}(e) & = &
  \begin{cases}
    h(a) & \textrm{falls } (\epsilon, \varnothing, \llbracket
    e\rrbracket, \epsilon, \varnothing)
    \hookrightarrow^* (a, e, \epsilon, \epsilon, h), h(a) \in B\\
    \texttt{proc} & \textrm{falls } (\epsilon, \varnothing, \llbracket e\rrbracket, \epsilon,\varnothing)
    \hookrightarrow^* (a, e, \epsilon, \epsilon, h), h(a) = (v, \underline{c}, e')\\
  \end{cases}
\end{eqnarray*}


\section{Implementierung der SECDH-Maschine}


F¸r die Implementierung der SECDH-Maschine werden einige der
Prozeduren wiederverwendet, die f¸r die SECD-Maschine programmiert
wurden.  Zun‰chst einmal muﬂ~-- genau wie bei der SECD-Maschine~--
erst einmal die ‹bersetzung von Termen in Maschinencode realisiert
werden.  Zuweisungsterme haben wie in Scheme die folgende Form:
%
\begin{alltt}
(set! \(v\) \(e\))
\end{alltt}
%
Das dazu passende Pr‰dikat ist das folgende:
%
\begin{verbatim}
; Pr‰dikat f¸r Zuweisungen
(: assignment? (%a -> boolean))
(define assignment?
  (lambda (t)
    (and (pair? t)
         (equal? 'set! (first t)))))

(define assignment (signature (predicate assignment?)))
\end{verbatim}
%
Mit Hilfe dieser Definition kann die Signaturdefinition von
\texttt{term} erweitert werden:
%
\begin{verbatim}
(define term
  (signature
    (mixed symbol
           application
           abstraction
           base
           primitive-application
           assignment)))
\end{verbatim}
%
Um zu vermeiden, daﬂ Zuweisungen mit regul‰ren Applikationen
verwechselt werden, muﬂ das Pr‰dikat \texttt{application?} erweitert
werden:
%
\begin{verbatim}
(define application?
  (lambda (t)
    (and (pair? t)
         (not (equal? 'set! (first t)))
         (not (equal? 'lambda (first t)))
         (not (primitive? (first t))))))
\end{verbatim}
%
Als n‰chstes wird die zus‰tzliche $\mathtt{:=}$-Instruktion
repr‰sentiert.  Hier sind Daten- und Record-Definition:
%
\begin{verbatim}
; Eine Zuweisungs-Instruktion ist ein Wert
;  (make-:=)
(define-record-procedures :=
  make-:= :=?
  ())
(: make-:= (-> :=))
\end{verbatim}
%
Die Signaturdefinition f¸r Maschinen-Instruktionen kann um \texttt{:=}
erweitert werden:
%
\begin{verbatim}
(define instruction
  (signature
    (mixed base
           symbol
           ap
           tailap
           prim
           abs
           :=)))
\end{verbatim}

Bei der ‹bersetzung in Maschinencode kommt in
\texttt{term->machine-code} ein weiterer Zweig hinzu:
%
\begin{verbatim}
; Term in Maschinencode ¸bersetzen
(: term->machine-code (term -> machine-code))
(define term->machine-code
  (lambda (e)
    (cond
      ...
      ((assignment? e)
       (make-pair (first (rest e))
                  (append (term->machine-code (first (rest (rest e))))
                          (list (make-:=))))))))
\end{verbatim}
%
Wie bei der SECD-Maschine werden die verschiedenen Mengendefinitionen
erst einmal in Daten- und Record-Definitionen ¸bersetzt.  Das ist f¸r
Stacks, Umgebungen und Speicheradressen ganz einfach:
%
\begin{verbatim}
; Ein Stack ist eine Liste aus Adressen.
(define stackh (signature (list-of address)))

; Eine Umgebung bildet Variablen auf Adressen ab.

; Eine Adresse ist eine ganze Zahl.
(define address (signature natural))
\end{verbatim}
%
Die ƒnderung in der Definition von Umgebungen bedingt eine ƒnderung
der Signatur von \texttt{make-binding}:
%
\begin{verbatim}
(: make-binding (symbol address -> binding))
\end{verbatim}

%
Bei der Repr‰sentation des Heaps ist wichtig, daﬂ eine Operation zur
Beschaffung frischer Adressen eingebaut wird.  Aus diesem Grund
enth‰lt der Heap zus‰tzlich zu den Zellen auch noch einen Z‰hler mit
der n‰chsten frischen Adresse:
%
\begin{verbatim}
; Ein Heap ist ein Wert
;   (make-heap s n)
; wobei n die n‰chste freie Adresse ist und s eine Liste
; von Zellen.
(define-record-procedures heap
  make-heap heap?
  (heap-cells heap-next))
(: make-heap ((list-of cell) natural -> heap))
\end{verbatim}
%
Der leere Heap wird schon einmal vorfabriziert:
%
\begin{verbatim}
(define the-empty-heap (make-heap empty 0))
\end{verbatim}
%
Jede Zelle ordnet einer Adresse einen Wert zu:
%
\begin{verbatim}
; Eine Zelle ist ein Wert
;   (make-cell a w)
; wobei a eine Adresse und w ein Wert ist
(define-record-procedures cell
  make-cell cell?
  (cell-address cell-value))
(: make-cell (address value -> cell))
\end{verbatim}
%
Die Prozedur \texttt{heap-store}, erweitert den Heap um eine Zelle
entsprechend der mathematischen Definition:
%
\begin{verbatim}
; Wert im Speicher ablegen
(: heap-store (heap address value -> heap))
(define heap-store
  (lambda (h a w)
    (make-heap (make-pair (make-cell a w)
                          (remove-cell a (heap-cells h)))
               ...)))
\end{verbatim}
%
Die Ellipse steht f¸r die n‰chste frische Adresse: Wenn die bisherige
frische Adresse in \texttt{heap-store} belegt wird, so muﬂ eine neue
frische Adresse gew‰hlt werden:
%
\begin{verbatim}
(define heap-store
  (lambda (h a w)
    (make-heap (make-pair (make-cell a w)
                          (remove-cell a (heap-cells h)))
               (let ((next (heap-next h)))
                 (if (= a next)
                     (+ next 1)
                     next)))))
\end{verbatim}
%
Es fehlt noch die Hilfsprozedur \texttt{remove-cell}:
%
\begin{verbatim}
; Zelle zu einer Adresse entfernen
(: remove-cell (address (list-of cell) -> (list-of cell)))
(define remove-cell
  (lambda (a c)
    (cond
      ((empty? c) empty)
      ((pair? c)
       (if (= a (cell-address (first c)))
           (rest c)
           (make-pair (first c)
                      (remove-cell a (rest c))))))))
\end{verbatim}
%
Als n‰chstes ist die Operation an der Reihe, die den Wert, der an einer
Adresse im Heap gespeichert ist.  Die Prozedur \texttt{heap-lookup} benutzt
eine Hilfsprozedur \texttt{cells-lookup}, um in der Liste von Zellen
nach der richtigen zu suchen:
%
\begin{verbatim}
; den Wert an einer Adresse im Heap nachschauen
(: heap-lookup (heap address -> value))
(define heap-lookup
  (lambda (h a)
    (cells-lookup (heap-cells h) a)))

; den Wert an einer Adresse in einer Liste von Zellen nachschauen
(: cells-lookup ((list-of cell) address -> value))
(define cells-lookup
  (lambda (c a)
    (cond
      ((empty? c) (violation "unassigned address"))
      ((pair? c)
       (if (= a (cell-address (first c)))
           (cell-value (first c))
           (cells-lookup (rest c) a))))))
\end{verbatim}
%
Schlieﬂlich fehlt noch eine Repr‰sentation f¸r den $\mathtt{void}$-Wert:
%
\begin{verbatim}
; Ein void-Wert ist ein Wert
;  (make-void)
(define-record-procedures void
  make-void void?
  ())
(: make-void (-> void))
\end{verbatim}
%
Auch hier wird nur ein $\mathtt{void}$-Wert benˆtigt, der 
vorfabriziert wird:
%
\begin{verbatim}
(define the-void (make-void))
\end{verbatim}
%
Der Zustand f¸r die SECDH-Maschine wird genau wie bei der
SECD-Maschine repr‰sentiert, erg‰nzt um die Komponente f¸r den Heap:
%
\begin{verbatim}
; Ein SECDH-Zustand ist ein Wert
;   (make-secd s e c d h)
; wobei s ein Stack, e eine Umgebung, c Maschinencode,
; d ein Dump und h ein Speicher ist.
(define-record-procedures secdh
  make-secdh secdh?
  (secdh-stack secdh-environment secdh-code secdh-dump secdh-heap))
(: make-secdh (stackh environment machine-code dump heap -> secdh))
\end{verbatim}
%
Die Implementierung der Zustands¸bergangsfunktion hat exakt die
gleiche Struktur wie die Implementierung der SECD-Maschine und h‰lt
sich eng an die mathematische Definition der Regeln:
%
\begin{verbatim}
; eine Zustandstransition berechnen
(: secdh-step (secdh -> secdh))
(define secdh-step
  (lambda (state)
    (let ((stack (secdh-stack state))
          (environment (secdh-environment state))
          (code (secdh-code state))
          (dump (secdh-dump state))
          (heap (secdh-heap state)))
      (cond
        ((pair? code)
         (cond
           ((base? (first code))
            (let ((a (heap-next heap)))
              (make-secdh
               (make-pair a stack)
               environment
               (rest code)
               dump
               (heap-store heap a (first code)))))
           ((symbol? (first code))
            (make-secdh
             (make-pair (lookup-environment environment (first code))
                        stack)
             environment
             (rest code)
             dump
             heap))
           ((prim? (first code))
            (let ((a (heap-next heap)))
              (make-secdh
               (make-pair a
                          (drop (prim-arity (first code)) stack))
               environment
               (rest code)
               dump
               (heap-store heap a
                           (apply-primitive
                            (prim-operator (first code))
                            (map (lambda (address)
                                   (heap-lookup heap address))
                                 (take-reverse (prim-arity (first code)) stack)))))))
           ((:=? (first code))
            (let ((a (heap-next heap)))
              (make-secdh
               (make-pair a (rest (rest stack)))
               environment
               (rest code)
               dump
               (heap-store
                (heap-store heap
                            (first (rest stack)) 
                            (heap-lookup heap (first stack)))
                a the-void))))
           ((abs? (first code))
            (let ((a (heap-next heap)))
              (make-secdh
               (make-pair a stack)
               environment
               (rest code)
               dump
               (heap-store heap a
                           (make-closure (abs-variable (first code))
                                         (abs-code (first code))
                                         environment)))))
           ((ap? (first code))
            (let ((closure (heap-lookup heap (first (rest stack))))
                  (a (heap-next heap)))
              (make-secdh empty
                          (extend-environment
                           (closure-environment closure)
                           (closure-variable closure)
                           a)
                          (closure-code closure)
                          (make-pair
                           (make-frame (rest (rest stack)) environment (rest code))
                           dump)
                          (heap-store heap a (heap-lookup heap (first stack))))))
           ((tailap? (first code))
            (let ((closure (heap-lookup heap (first (rest stack))))
                  (a (heap-next heap)))
              (make-secdh (rest (rest stack))
                          (extend-environment
                           (closure-environment closure)
                           (closure-variable closure)
                           a)
                          (closure-code closure)
                          dump
                          (heap-store heap a
                                      (heap-lookup heap (first stack))))))))
        ((empty? code)
         (let ((f (first dump)))
           (make-secdh
            (make-pair (first stack)
                       (frame-stack f))
            (frame-environment f)
            (frame-code f)
            (rest dump)
            heap)))))))
\end{verbatim}    
%
Es bleibt die Auswertungsfunktion, die ebenfalls genau wie bei der
SECD-Maschine realisiert wird:
%
\begin{verbatim}
; aus Term SECDH-Anfangszustand machen
(: inject-secdh (term -> secdh))
(define inject-secdh
  (lambda (e)
    (make-secdh empty
                the-empty-environment
                (term->machine-code e)
                empty
               the-empty-heap)))

; bis zum Ende Zustands¸berg‰nge berechnen
(: secdh-step* (secdh -> secdh))
(define secdh-step*
  (lambda (state)
    (if (and (empty? (secdh-code state))
             (empty? (secdh-dump state)))
        state
        (secdh-step* (secdh-step state)))))


; Evaluationsfunktion zur SECD-Maschine berechnen
(: eval-secdh (term -> (mixed value (one-of 'function))))
(define eval-secdh
  (lambda (e)
    (let ((final (secdh-step* (inject-secdh e))))
      (let ((val (heap-lookup (secdh-heap final)
                              (first (secdh-stack final)))))
        (if (base? val)
            val
            'proc)))))
\end{verbatim}


\section*{‹bungsaufgaben}

\begin{aufgabe}
  ‹bersetzen Sie folgende Lambda-Terme in die Zwischenrepr‰sentation
  der SECD-Maschine:
  
  \begin{enumerate}
  \item \((\lambda xy.(+\:x\:y))\:(*\:5\:6)\:23\)

  \item \((\lambda x.(!\:x))\:(\lambda xy.(\&\&\:x\:y))\:((\lambda xy.(>\:x\:y))\:23~42)\:true\)

   
  \item \((\lambda xy.\:y\:x\:x)\:(\lambda z.\:z)\:(\lambda yz.\:(y\:y)\:(y\:z))\)

  \end{enumerate}

  Dabei steht $!$ f¸r das boolesche \texttt{not} und $\&\&$ f¸r das
  boolesche \texttt{and}.
\end{aufgabe}

\begin{aufgabe}
 Betrachten Sie folgendes SECD-Programm:
 
 \newcommand{\tuple}[2]{\ensuremath{(#1,#2)}}

 \begin{center}
   \tuple{f}{\tuple{x}{\tuple{y}{f\:x\:\texttt{ap}\:y\:\texttt{ap}}}}\:\tuple{a}{\tuple{b}{a\:b\:\texttt{prim}_+}}\:\texttt{ap}\:23\:\texttt{ap}\:42\:\texttt{ap}
 \end{center}
 
 \begin{enumerate}
   \item ‹bersetzen Sie das SECD-Programm in den entsprechenden
   $\mathcal{L}_{\lambda{}A}$-Term.
   \item Werten Sie das SECD-Programm aus und geben Sie die einzelnen
     Auswertungsschritte an!
 \end{enumerate}
  
\end{aufgabe}

\begin{aufgabe}\label{aufgabe:secd-endekursiv-implementieren}
  Erweitern Sie die Implementierung der SECD-Maschine um korrekte
  Behandlung der Endrekursion!  Erweitern Sie dazu zun‰chst die
  Datendefinition f¸r Maschinencode. Implementieren Sie dann die
  ‹bersetzung von $\lambda$-Termen f¸r die endrekursive SECD-Maschine.
  Erweitern Sie schlieﬂlich die Zustands¸bergangsfunktion um einen
  Fall f¸r die $\mathtt{tailap}$-Instruktion.
\end{aufgabe}

\begin{aufgabe}
  Die um Endrekursion erweiterte SECD-Maschine f¸hrt eine neue
  Maschinencode"=Instruktion \texttt{tailap} ein.  Dies ist aber nicht
  unbedingt nˆtig.  Formulieren Sie die Zustands¸bergangsregeln der
  SECD-Maschine mit Endrekursion so um, daﬂ die Funktionalit‰t, also
  insbesondere die richtige Behandlung endrekursiver Applikationen,
  auch ohne das das zus‰tzliche Schl¸sselwort \texttt{tailap}
  erhalten bleibt.
\end{aufgabe}

\begin{aufgabe}
  Zeigen Sie in der um Endrekursion erweiterten
  SECD-Maschine, daﬂ \texttt{tailap} immer am Ende steht, also
  tats‰chlich keinen Kontext besitzt.
\end{aufgabe}

\begin{aufgabe}\label{aufgabe:prim-arity}
  Erweitern Sie die SECD-Maschine um Primitive anderer Stelligkeiten,
  z.B.\ \texttt{abs} oder \texttt{odd?}.
\end{aufgabe}

\begin{aufgabe}
  ƒndern Sie die Implementierung der SECDH-Maschine dahingehend, daﬂ
  sie Endrekursion korrekt behandelt.
\end{aufgabe}

\begin{aufgabe}
  Abstrahieren Sie ¸ber \texttt{remove-environment-binding} und
  \texttt{remove-cell}.
\end{aufgabe}

\begin{aufgabe}
  Erweitern Sie den angewandten $\lambda$-Kalk¸l um Abstraktionen und
  Applikationen mit mehr als einem Parameter.  Erweitern Sie die
  SECD-Maschine und ihre Implementierung entsprechend.
\end{aufgabe}


\begin{aufgabe}
  Erweitern Sie den angewandten $\lambda$-Kalk¸l um bin‰re
  Verzweigungen analog zu \texttt{if}.  Erweitern Sie entsprechend die
  SECD-Maschine und ihre Implementierung.
\end{aufgabe}

\begin{aufgabe}
  \texttt{Begin} l‰ﬂt sich im angewandten $\lambda$-Kalk¸l als
  syntaktischer Zucker auffassen: Wie m¸ﬂten \texttt{begin}-Ausdr¸cke
  in die Sprache des Kalk¸ls ¸bersetzt werden?
\end{aufgabe}

\begin{aufgabe}
  Anstatt Umgebungen durch Listen von Bindungen zu repr‰sentieren, ist
  es auch mˆglich, Prozeduren zu verwenden, so daﬂ
  \texttt{lookup-environment} folgendermaﬂen aussieht:
\begin{verbatim}
(define lookup-environment
  (lambda (e v)
    (e v)))
\end{verbatim}
  Erg‰nzen Sie eine passende Definition f¸r
  \texttt{extend-environment}.
\end{aufgabe}

\begin{aufgabe}
  Auf den ersten Blick erscheint es etwas aufwendig, jedesmal bei der
  Auswertung einer Abstraktion die gesamte Umgebung in die Closure
  einzupacken.  Was w¸rde sich ‰ndern, wenn dieser Schritt weggelassen
  w¸rde, Closures also nur Variable und Maschinencode f¸r den Rumpf
  enthalten w¸rden?  Formulieren Sie die entsprechenden Regeln f¸r die
  SECD-Maschine und ‰ndern Sie die Implementierung entsprechend.
  Funktioniert die SECD-Maschine nach der ƒnderung noch korrekt?
\end{aufgabe}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "i1"
%%% End: 

