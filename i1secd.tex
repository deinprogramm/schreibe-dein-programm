% Diese Datei ist Teil des Buchs "Schreibe Dein Programm!"
% Das Buch ist lizensiert unter der Creative-Commons-Lizenz
% "Namensnennung - Weitergabe unter gleichen Bedingungen 4.0 International (CC BY-SA 4.0)"
% https://creativecommons.org/licenses/by-sa/4.0/deed.de

\chapter{Exkurs: Die SECD-Maschine}\label{cha:secd}

Dieses Kapitel baut auf dem $\lambda$-Kalkül aus dem vorigen Kapitel auf.
Der $\lambda$-Kalkül ist als theoretisches Modell für berechenbare
Funktionen lange vor der Erfindung des Computers entwickelt worden.
Er bildet zwar die Grundlage für unsere Lehrsprachen, erklärt aber
nicht, wie diese eigentlich auf einem "<echten"> Computer ablaufen.
Moderne Mikroprozessoren werden in einer \textit{Maschinensprache}
programmiert, die sich erheblich vom $\lambda$-Kalkül unterscheidet.
Damit unsere Programme auf so einem Prozessor laufen können, müssen
sie in die Maschinensprache\index{Maschinensprache} übersetzt werden,
mit einem sogenannten \textit{Compiler}.

In diesem Kapitel beschreiben wir eine idealisierte Maschine, die zwar
so nie gebaut wurde, dessen Maschinensprache aber auf den gleichen
Prinzipien basiert wie reale Maschinen~-- die \textit{SECD-Maschine}.
Dann schreiben wir
einen Compiler vom $\lambda$-Kalkül in die SECD-Maschinensprache
und außerdem eine sogenannte
\textit{virtuelle Maschine}, die es uns erlaubt, die compilierten
Programme auch laufenzulassen.

\section{Der angewandte $\lambda$-Kalkül}

Abschnitt~\ref{sec:lambdaprog} auf Seite~\pageref{sec:lambdaprog}
zeigte bereits, dass sich auch boolesche Werte und Zahlen im
$\lambda$-Kalkül durch $\lambda$-Terme darstellen lassen.  Das ist
zwar aus theoretischer Sicht gut zu wissen.  Für die Praxis ist es
aber zu mühsam, immer mit Church-Numeralen zu arbeiten. Darum
erweitern wir den $\lambda$-Kalkül um einige Extras, so dass er mit
Zahlen und Booleans direkt umgehen kann.
Abschnitt~\ref{sec:lambdaprog} hat Dich hoffentlich überzeugt, dass
wir jederzeit auf die neuen Elemente verzichten könnten, indem wir sie
in die Terme aus Abschnitt~\ref{sec:lambdaprog} übersetzen.

Der resultierende erweiterte $\lambda$-Kalkül heißt 
\textit{angewandter $\lambda$-Kalkül}:

\begin{definition}[Sprache des angewandten $\lambda$-Kalküls
  $\mathcal{L}_{\lambda{}A}$]\index{angewandter $\lambda$-Kalkül}\label{def:lambda-angewandt}
  
  Sei $V$ eine abzählbare Menge von Variablen, wie im
  $\lambda$-Kalkül.

  Sei $B$ eine Menge von \textit{Basiswerten\index{Basiswert}}.  Zu
  den Basiswerten gehören mindestens die booleschen Werte und die
  natürlichen Zahlen, also:
  %
  \begin{displaymath}
    B \deq{} \{ \texttt{\#f}, \texttt{\#t}, 0, 1, 2, \ldots \}
  \end{displaymath}
  %
  Sei für eine natürliche Zahl $i$ jeweils $\Sigma^i$ eine Menge von
  \textit{$i$-stelligen Primitiva\index{Primitivum}}~-- die Namen von
  "<eingebauten Operationen">.  Jedem $F\in\Sigma^i$ ist eine
  $i$-stellige Funktion $F^{\textrm{op}}$~-- ihre \textit{Operation}~--
  zugordnet.

  Zum Beispiel könnte die Addition eine primitive Operation
  $+\in \Sigma^2$ sein.  Die Operation dazu wäre:
  %
  \begin{displaymath}
    +^{\textrm{op}}(a, b) \deq a + b
  \end{displaymath}
  %
  Die Sprache des angewandten
  $\lambda$"=Kalküls, die Menge der \textit{angewandten
    $\lambda$-Terme},
  $\mathcal{L}_{\lambda{}A}$\index{L@$\mathcal{L}_{\lambda{}A}$}, ist
  durch folgende Grammatik definiert:
  \begin{grammar}
    \meta{$\mathcal{L}_{\lambda{}A}$} \: \meta{$V$}
    \> \| (\meta{$\mathcal{L}_{\lambda{}A}$} \meta{$\mathcal{L}_{\lambda{}A}$})
    \> \| ($\lambda$\meta{$V$}.\meta{$\mathcal{L}_{\lambda{}A}$})
    \> \| \meta{$B$}
    \> \| (\meta{$\Sigma^1$}~\meta{$\mathcal{L}_{\lambda{}A}$})
    \> \| (\meta{$\Sigma^2$}~\meta{$\mathcal{L}_{\lambda{}A}$}~\meta{$\mathcal{L}_{\lambda{}A}$})
    \> \ldots
    \> \| (\meta{$\Sigma^n$}~\meta{$\mathcal{L}_{\lambda{}A}$}~\ldots~\meta{$\mathcal{L}_{\lambda{}A}$}) \quad \textrm{($n$-mal)}
  \end{grammar}
  Die Grammatik ist abgekürzt notiert: Die letzen Klauseln besagen,
  dass es für jede Menge von Primitiva \meta{$\Sigma^i$} mit
  Stelligkeit $i$ eine entsprechende Klausel mit $i$ Operanden gibt.
  Terme der Form $(F^i~e_1~\ldots~e_i)$ heißen
  \textit{primitive Applikationen\index{primitive Applikation}}.
\end{definition}
%
Im angewandten $\lambda$-Kalkül sind also
Terme wie zum Beispiel $(+~(-~5~3)~17)$ möglich, wenn $+$ und $-$ in
$\Sigma^2$ enthalten sind.
%
\begin{definition}[Werte im angewandten $\lambda$-Kalkül]\label{def:wert-angewandt}
  Die Vereinigung aus Abstraktionen und
  Basiswerten heißt \textit{Werte}.
\end{definition}
%
Damit die primitiven Operationen auch tatsächlich eine Bedeutung
bekommen, muss eine spezielle Reduktionsregel für sie eingeführt
werden:
%
\begin{definition}[$\delta$-Reduktion]\index{delta-Reduktion@$\delta$-Reduktion}
\begin{displaymath}
  (F^i~e_1~\ldots~e_i) \rightarrow_{\delta} F^{\textrm{op}}(e_1, \ldots, e_k)
  \quad e_1, \ldots, e_i \in B
\end{displaymath}
\end{definition}
%
Diese Regel besagt, dass eine primitive Applikation, wenn alle
Operanden Werte sind, durch Anwendung der entsprechenden Operation 
reduziert werden kann.  Damit wird zum Beispiel der
obige Beispielterm folgendermaßen reduziert:
%
\begin{displaymath}
  (+~\underline{(-~5~3)}~17) \rightarrow_{\delta} \underline{(+~2~17)} \rightarrow_{\delta} 19
\end{displaymath}
%
\begin{aufgabeinline}
  Leider ist es nicht möglich, Verzweigungen nicht mit einer
  $\delta$-Regel zu beschreiben.  Aber warum?  Zur Beantwortung dieser
  Frage Schreibe zunächst eine mögliche Definition der dazugehörigen
  Funktion $F^\mathbf{if}$ hin.  Bedenke nun, dass die
  $\delta$-Reduktion erst dann greift, wenn alle Argumente von
  $\mathbf{if}$ Werte sind.  Könntest Du mit diesem $\mathbf{if}$ zum
  Beispiel die Fakultät aus Abschnitt~\ref{sec:fixpunktsatz} auf
  Seite~\pageref{sec:fixpunktsatz} definieren?
\end{aufgabeinline}
%
In den folgenden Abschnitten werden wir SECD-Maschine und Compiler
für den angewandten $\lambda$-Kalkül ohne binäre Verzweigungen
definieren.  Wir wissen ja, wie wir sie mit den Mitteln aus
Abschnitt~\ref{sec:booleans} auf Seite~\pageref{sec:booleans}
definieren können.

Wir werden aber Dich bitten, binäre Verzweigungen als Ergänzung
direkt zu realisieren in einer Reihe von Übungsaufgaben.  Hier ist die
erste davon:
%
\begin{aufgabeinline}
  \begin{enumerate}
  \item Erweitere den erweiterten $\lambda$-Kalkül um eine
    Grammatik-Klausel für binäre Verzweigungen.
  \item Definiere eine Reduktionsregel für binäre Verzweigungen,
    analog zur $\delta$-Reduktion.  (Du kannst Sie $\iota$-Reduktion
    nennen~-- $\iota$ ist der griechische Buchstabe "<iota">.)
  \end{enumerate}
\end{aufgabeinline}

\section{Die SECD-Maschine}

Leider läuft auf handelsüblichen Prozessoren der $\lambda$-Kalkül
nicht direkt.  Stattdessen führen diese Prozessoren
sogenannte \textit{Maschinensprache}\index{Maschinensprache} aus.  
Maschinensprache besteht aus einzelnen Anweisungen, die hintereinander
im Speicher abgelegt und auch hintereinander ausgeführt werden.  Das
unterscheidet die Maschinensprache von unseren Lehrsprachen, die auf
dem Call-by-Value-$\lambda$-Kalkül\index{Call-by-Value-Reduktion}
aufbauen: Dort läuft die Auswertung von innen nach außen.

Um eine Brücke zwischen beiden Ideen zu schlagen, entwickelte Peter Landin
die SECD"=Maschine~\cite{Landin1964}.  Die SECD-Maschine ist zwar über
50~Jahre alt, aber auch auf modernen Maschinen immer noch die
Grundlage für das Zusammenspiel zwischen Programmiersprache und
Maschinensprache.  Die Sprache der SECD-Maschine ist eine idealisierte
Maschinensprache, die auch aus Anweisungen besteht, die
hintereinander ausgeführt werden.  Viele Details echter
Maschinensprachen lässt die SECD-Maschine aber weg.

\begin{definition}[Sprache der SECD-Machine]\label{def:secd-code}
  Die Anweisungen der SECD-Maschine heißen
  \textit{Instruktionen}\index{Instruktion} und sind durch folgende Grammatik definiert:
  \begin{grammar}
    \meta{I} \: \meta{B}
    \> \| \meta{V}
    \> \| ap
    \> \| prim$_{F^i}$ \textrm{für alle $F^i \in \Sigma^i$}
    \> \| (\meta{V}, \meta{C})
  \end{grammar}
  %
  Ein Maschinensprachen-Programm~-- auch genannt
  \textit{Maschinencode}\index{Maschinencode} oder
  \textit{Code}\index{Code} ist eine Folge von Instruktionen:
  %
  \begin{displaymath}
    C \deq I^\ast
  \end{displaymath}
\end{definition}
%
Diie SECD-Maschine operiert aber auf sogenannten
\textit{Maschinenzuständen}.  Ein Maschinenzustand ist ein 4-Tupel aus der
Menge $S\times E\times C\times D$ (daher der Name der Maschine).  Die
Buchstaben sind deshalb so gewählt, weil $S$ der sogenannte
\textit{Stack\index{Stack}}, $E$ die sogenannte
\textit{Umgebung\index{Umgebung}} beziehungsweise auf englisch das
\textit{Environment\index{Environment}}, $C$ der schon bekannte
Code und $D$ der
sogenannte \textit{Dump\index{Dump}} ist.  Die formalen Definitionen
dieser Mengen sind wie folgt; dabei ist $W$ die Menge der Werte:
%
\begin{eqnarray*}
  S &\deq& W^\ast\\
  E &\subseteq& V\times W\\
  D &\deq& (S\times E \times C)^\ast\\
  W &\deq& B \cup (V\times C\times E)
\end{eqnarray*}
%
Der Stack ist eine Folge von Werten.  In der Maschine sind dies
die Werte der zuletzt ausgewerteten Terme, wobei der zuletzt
ausgewertete Term vorn beziehungsweise "<oben"> steht.  Die Umgebung ist eine
partielle Abbildung von Variablen auf Werte: sie ersetzt die
Substitution in der Reduktionsrelation des $\lambda$-Kalküls.  Anstatt
dass Werte für Variablen eingesetzt werden, merkt sich die Umgebung
einfach, an welche Werte die Variablen gebunden sind.  Erst wenn der
Wert einer Variablen benötigt wird, holt ihn die Maschine aus der
Umgebung.

Der Dump ist eine Liste früherer Zustände der Maschine:
Jeder Zustand ist ein Tupel aus Stack, Umgebung und Code, auch genannt
\textit{Frame}.\index{Frame} Ein Dump speichert den den
Kontext\index{Kontext}, dem wir in Abschnitt~\ref{sec:kontext} auf
Seite~\pageref{sec:kontext} begegnet sind.

Die Menge $W$ schließlich entspricht dem Wertebegriff aus
Definition~\ref{def:wert-angewandt}: Die Basiswerte gehören dazu,
außerdem 3-Tupel aus $(V\times C\times E)$.  Ein solches Tripel,
genannt \textit{Closure}\index{Closure}, repräsentiert den Wert
einer Abstraktion.  Eine Closure besteht aus der Variable einer Abstraktion,
dem Maschinencode ihres Rumpfs und der Umgebung, die notwendig ist, um
die Abstraktion anzuwenden: Die Umgebung wird benötigt, damit die
freien Variablen der Abstraktion entsprechend der lexikalischen
Bindung\index{lexikalische Bindung} ausgewertet werden können.  Dies
ist anders als im Stepper, wo Variablen bei der
Applikation direkt ersetzt werden und damit verschwinden.

Die SECD-Maschine überführt einen Maschinenzustand durch einen
Auswertungsschritt in einen neuen Maschinenzustand.

Bei Umgebungen benutzen wir die Notation $e(v)$: Das steht für den Wert
$w$ des Tupels $(v, w)$ in $e$.

Im Verlauf der Auswertung werden Umgebungen häufig um neue Bindungen
von einer Variable an einen Wert erweitert.  Dazu ist die Notation
$e[v\mapsto w]$ nützlich.  $e[v\mapsto w]$ konstruiert aus einer
Umgebung $e$ eine neue Umgebung, in der die Variable $v$ an den Wert
$w$ gebunden ist.  Hier ist die Definition:
%
\begin{displaymath}
  e[v\mapsto w] \deq (e \setminus \{ (v, w') | (v, w') \in e \}) \cup \{
    (v, w) \}
\end{displaymath}
%
Es wird also zunächst eine eventuell vorhandene alte Bindung entfernt
und dann eine neue hinzugefügt.

\emph{Achtung:} Die Notation $e[v\mapsto w]$ haben wir schonmal im
letzten Kapitel benutzt, nämlich für die Substitution beim
$\lambda$-Kalkül in Definition~\ref{def:substitution} auf
Seite~\pageref{def:substitution}.  In diesem Kontext~-- bei der
SECD-Maschine~-- bedeutet die Notation etwas anderes.  Lass Dich nicht
verwirren!

Um die Maschine zu verstehen, ist es sinnvoll, erst einmal zu
sehen, wie $\lambda$-Terme in SECD-Code umgewandelt werden.  
Ein Term $e$ aus dem angewandten $\lambda$-Kalkül wird mit Hilfe der
Funktion $\llbracket \underline{~}\rrbracket$ in ein Maschinensprache-Programm
$\llbracket e\rrbracket$ übersetzt.\label{page:secd-translation}
%
\begin{eqnarray*}
  \llbracket e \rrbracket &\deq&
  \begin{cases}
    b & \textrm{falls $e = b \in B$}\\
    v & \textrm{falls $e = v \in V$}\\
    \llbracket e_0\rrbracket~\llbracket e_1\rrbracket~\mathtt{ap}
    & \textrm{falls $e = (e_0~e_1)$}\\
    \llbracket e_1\rrbracket~\ldots~\llbracket e_k\rrbracket~\mathtt{prim}_{F^i}
    & \textrm{falls $e = (F~e_1~\ldots~e_i)$}\\
    (v, \llbracket e_0\rrbracket) & \textrm{falls $e = \lambda v.e_0$}
  \end{cases}
\end{eqnarray*}
%
Zum Beispiel bedeutet die Übersetzung
$\llbracket e_0\rrbracket~\llbracket e_1\rrbracket~\mathtt{ap}$ für
einen Term $(e_0~e_1)$, dass $e_0$ und $e_1$ separat übersetzt werden.
Die Instruktionen der beiden Übersetzungen werden aneinandergehängt,
so dass die SECD-Maschine sie später auch hintereinander ausführt,
also erst $e_0$ auswertet, dann $e_1$.  Wie wir sehen werden, wird die
SECD-Maschine die Ergebnisse der Auswertung von $e_0$ und $e_1$ auf
dem Stack plazieren.  Die Instruktion $\mathtt{ap}$, die noch hinten
dazukommt, sorgt dann dafür, dass die SECD-Maschine die Ergebnisse von
$e_0$ (das muss die Funktion sein) und das Ergebnis von $e_1$ vom
Stack holt und das eine auf das andere anwendet.  Entsprechend steht
$\mathtt{ap}$ für "<Applikation ausführen">.  Außerdem steht
$\mathtt{prim}_{F^k}$ für "<Primitiv $F$ ausführen">.

Basiswerte und Variablen werden direkt in Maschinencode übersetzt.
Eine Abstraktion wird übersetzt in ein Tupel aus seiner Variable und
dem Maschinencode für seinen Rumpf.  Alle diese Anweisungen
hinterlassen ihr Ergebnis jeweils auf dem Stack.

Hier ist ein Beispiel für die Übersetzung:
%
\begin{eqnarray*}
  \llbracket \lambda f.\lambda x.\lambda y.f~(+~x~(*~y~2))\rrbracket
  &=&
  (f, \llbracket \lambda x.\lambda y.f~(+~x~(*~y~2))\rrbracket)\\
  &=&
  (f, (x, \llbracket \lambda y.f~(+~x~(*~y 2))\rrbracket))\\
  &=&
  (f, (x, (y, \llbracket f~(+~x~(*~y 2))\rrbracket)))\\
  &=&
  (f, (x, (y, \llbracket f\rrbracket \llbracket (+~x~(*~y
  2))\rrbracket \mathtt{ap})))\\
  &=&
  (f, (x, (y, f \llbracket (+~x~(*~y 2))\rrbracket\mathtt{ap})))\\
  &=&
  (f, (x, (y, f \llbracket x\rrbracket \llbracket (*~y~2)\rrbracket \mathtt{prim}_+~\mathtt{ap})))\\
  &=&
  (f, (x, (y, f~x \llbracket (*~y~2)\rrbracket \mathtt{prim}_+~\mathtt{ap})))\\
  &=&
  (f, (x, (y, f~x \llbracket y\rrbracket \llbracket 2\rrbracket \mathtt{prim}_*~\mathtt{prim}_+~\mathtt{ap})))\\
  &=&
  (f, (x, (y, f~x~y \llbracket 2\rrbracket \mathtt{prim}_*~\mathtt{prim}_+~\mathtt{ap})))\\
  &=&
  (f, (x, (y, f~x~y~2~\mathtt{prim}_*~\mathtt{prim}_+~\mathtt{ap})))\\
\end{eqnarray*}
%
Das Beispiel zeigt deutlich, wie der Rumpf der innersten Abstraktion
in eine Folge von Instruktionen übersetzt wird, die der Reihenfolge
nach der Call-by-Value-Reduktionsstrategie entspricht: erst $f$
auswerten, dann $x$, dann $y$, dann das Primitiv $*$ anwenden, dann
$+$, und schließlich die Applikation durchführen.

\begin{aufgabeinline}
  Übersetze folgende $\lambda$-Terme in die Zwischenrepräsentation
  der SECD-Maschine:
  %
  \begin{enumerate}
  \item \((\lambda \lrm x \lrm y.(+\:\lrm x\:\lrm y))\:(*\:5\:6)\:23\)

  \item \((\lambda \lrm x.(!\:\lrm x))\:(\lambda \lrm x\lrm
    y.(\&\&\:\lrm x\:\lrm y))\:((\lambda \lrm x\lrm y.(>\:\lrm x\:\lrm
    y))\:23~42)\:\mathbf{true}\)
   
  \item \((\lambda \lrm x\lrm y.\:\lrm y\:\lrm x\:\lrm x)\:(\lambda
    \lrm z.\:\lrm z)\:(\lambda \lrm y\lrm z.\:(\lrm y\:\lrm y)\:(\lrm
    y\:\lrm z))\)
  \end{enumerate}
  %
  Dabei steht $!$ für das boolesche \lstinline{not} und $\&\&$ für das
  boolesche \lstinline{and}.
\end{aufgabeinline}
%
Wir definieren nun die SECD-Maschine selbst.  Diese macht immer einen
Schritt auf einmal und überführt einen Zustand $S$, $E$, $C$ und $D$
einen neuen Zustand, und zwar indem die erste Instruktion in $c$
"<abgearbeitet"> wird.  Diese Überführung schreiben wir mit dem Symbol
$\hookrightarrow$, also
$(s, e, c, d) \hookrightarrow (s', e', c', d')$, wenn die
SECD-Maschine den Zustand $(s, e, c, d)$ in den Zustand
$(s', e', c', d')$ überführt.

In der folgenden
Definition von $\hookrightarrow$ sind Bezeichner mit einem Unterstrich
versehen, wenn es sich um Folgen handelt, also zum Beispiel \underline{s} für
einen Stack:
%
\begin{eqnarray}
çü  (\underline{s}, e, b\underline{c}, \underline{d})
  &\hookrightarrow& 
  (b\underline{s}, e, \underline{c}, \underline{d})
  \label{secd:base}
  \\
  (\underline{s}, e, v\underline{c}, \underline{d})
  &\hookrightarrow&
  (e(v)\underline{s}, e, \underline{c}, \underline{d})
  \label{secd:variable}
  \\
  (b_k\ldots b_1 \underline{s}, e, \mathtt{prim}_{F^k}\underline{c}, \underline{d})
  &\hookrightarrow&
  (b\underline{s}, e, \underline{c}, \underline{d})
  \label{secd:prim}
  \\ && \textrm{wobei $F^k\in\Sigma^k$ und $F^k_B(b_1,\ldots,b_k) = b$}\notag
  \\
  (\underline{s}, e, (v, \underline{c'}) \underline{c}, \underline{d})
  &\hookrightarrow&
  ((v, \underline{c'}, e) \underline{s}, e, \underline{c}, \underline{d})
  \label{secd:abstraction}
  \\
  (w (v,\underline{c'}, e') \underline{s}, e, \mathtt{ap}~\underline{c}, \underline{d})
  &\hookrightarrow&
  (\epsilon, e'[v\mapsto w], \underline{c'}, (\underline{s}, e, \underline{c}) \underline{d})
  \label{secd:app}
  \\
  (w, e, \epsilon, (\underline{s'}, e', \underline{c'}) \underline{d})
  &\hookrightarrow&
  (w\underline{s'}, e', \underline{c'}, \underline{d})
  \label{secd:return}
\end{eqnarray}
%
Um einen $\lambda$-Term $e$ in die SECD-Maschine zu "<injizieren">,
wird der Term in eine Folge von Instruktionen $c$ übersetzt~-- die
$C$-Komponente der SECD-Maschine.  Daraus wird ein Anfangszustand
$(\epsilon, \varnothing, c, \epsilon)$ gemacht.

Die Regeln definieren eine Fallunterscheidung nach der ersten
Instruktion der Code"=Komponente des Zustands, beziehungsweise greift die letzte
Regel, wenn der Code leer ist.  Der Reihe nach arbeiten die Regeln wie
folgt:
%
\begin{itemize}
\item Regel~\ref{secd:base} (die
  \textit{Literalregel\index{Literalregel}}) schiebt einen Basiswert
  direkt auf den Stack.
\item Regel~\ref{secd:variable} (die
  \textit{Variablenregel\index{Variablenregel}}) ermittelt den Wert
  einer Variable aus der Umgebung und schiebt diesen auf den Stack.
\item Regel~\ref{secd:prim} ist die
  \textit{Primitivregel\index{Primitivregel}}.  Bei einer primitiven
  Applikation müssen soviele Basiswerte oben auf dem Stack liegen wie
  die Stelligkeit des Primitivs.  Dann ermittelt die Primitivregel das Ergebnis der
  primitiven Applikation und schiebt es oben auf den Stack.
\item Regel~\ref{secd:abstraction} ist die
  \textit{Abstraktionsregel\index{Abstraktionsregel}}: Das Tupel
  $(v,\underline{c'})$ ist bei der Übersetzung aus einer Abstraktion
  entstanden.  Die Regel ergänzt $v$ und $\underline{c'}$ mit
  $e$ zu einer Closure, die auf den Stack geschoben wird.
\item Regel~\ref{secd:app} ist die
  \textit{Applikationsregel\index{Applikationsregel}}: Bei einer
  Applikation müssen oben auf dem Stack ein Wert sowie eine Closure
  liegen.  (Zur Erinnerung: Eine Applikation kann nur ausgewertet
  werden, wenn eine Abstraktion vorliegt.  Abstraktionen werden zu
  Closures ausgewertet.)  In einem solchen Fall "<sichert"> die
  Applikation den aktuellen Zustand auf den Dump, und die Auswertung fährt mit
  einem leeren Stack, der Umgebung aus der Closure~-- erweitert um
  eine Bindung für die Variable~-- und dem Code aus der Closure fort.
\item Regel~\ref{secd:return} ist die
  \textit{Rückkehrregel\index{Rückkehrregel}}: Sie ist anwendbar,
  wenn das Ende des Codes erreicht ist.  Das heißt, dass gerade
  die Auswertung einer Applikation fertig ist.  Auf dem Dump liegt
  aber noch ein gesicherter Zustand, der jetzt "<zurückgeholt"> wird.
\end{itemize}
%
Hier ein Beispiel für den Ablauf der SECD-Maschine für den Term
$(((\lambda x.\lambda y.(+~x~y))~1)~2)$:
% (secd-step*/tex (inject-secd '(((lambda (x) (lambda (y) (+ x y))) 1) 2)))
%
\begin{displaymath}
  \begin{array}{l@{}llll}
&(\epsilon, &\varnothing, &(x, (y, x~y~\mathtt{prim}_+))~1~\mathtt{ap}~2~\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&((x, (y, x~y~\mathtt{prim}_+), \varnothing), &\varnothing, &1~\mathtt{ap}~2~\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&(1~(x, (y, x~y~\mathtt{prim}_+), \varnothing), &\varnothing, &\mathtt{ap}~2~\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&(\epsilon, &\{(x, 1)\}, &(y, x~y~\mathtt{prim}_+), &(\epsilon, \varnothing, 2~\mathtt{ap}))\\
\hookrightarrow{}&((y, x~y~\mathtt{prim}_+, \{(x, 1)\}), &\{(x, 1)\}, &\epsilon, &(\epsilon, \varnothing, 2~\mathtt{ap}))\\
\hookrightarrow{}&((y, x~y~\mathtt{prim}_+, \{(x, 1)\}), &\varnothing, &2~\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&(2~(y, x~y~\mathtt{prim}_+, \{(x, 1)\}), &\varnothing, &\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&(\epsilon, &\{(x, 1), (y, 2)\}, &x~y~\mathtt{prim}_+, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&(1, &\{(x, 1), (y, 2)\}, &y~\mathtt{prim}_+, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&(2~1, &\{(x, 1), (y, 2)\}, &\mathtt{prim}_+, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&(3, &\{(x, 1), (y, 2)\}, &\epsilon, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&(3, &\varnothing, &\epsilon, &\epsilon)
  \end{array}
\end{displaymath}
%
\begin{aufgabeinline}
 Betrachte folgendes SECD-Programm:
 
 \newcommand{\tuple}[2]{\ensuremath{(#1,#2)}}

 \begin{center}
   \tuple{f}{\tuple{x}{\tuple{y}{f\:x\:\texttt{ap}\:y\:\texttt{ap}}}}\:\tuple{a}{\tuple{b}{a\:b\:\texttt{prim}_+}}\:\texttt{ap}\:23\:\texttt{ap}\:42\:\texttt{ap}
 \end{center}
 
 \begin{enumerate}
   \item Übersetze das SECD-Programm "<rückwärts"> in den entsprechenden
   $\mathcal{L}_{\lambda{}A}$-Term.
   \item Werte das SECD-Programm aus und schreibe die einzelnen
     Auswertungsschritte auf!
 \end{enumerate}
\end{aufgabeinline}
%
Die Zustandsübergangsrelation $\hookrightarrow$ ist die Grundlage
für die \textit{Auswertungsfunktion\index{Auswertungsfunktion}} der
SECD-Maschine, die für einen $\lambda$-Term dessen Bedeutung
ausrechnet.  Dies ist scheinbar ganz einfach:
%
\begin{eqnarray*}
  \mathit{eval}_\mathit{SECD} & : & \mathcal{L}_{\lambda{}A} \rightarrow B\\
  \mathit{eval}_\mathit{SECD}(e) &= & x \textrm{ wenn } (\epsilon, \varnothing, \llbracket e\rrbracket, \epsilon)
    \hookrightarrow^* (x, e, \epsilon, \epsilon)
\end{eqnarray*}
%
Diese Definition hat jedoch zwei Haken:
%
\begin{itemize}
\item Die Auswertung von $\lambda$-Termen terminiert nicht immer (wie
  zum Beispiel für den "<Endlos"=Term"> $(\lambda x.(x~x))~(\lambda x.(x~x))$), es kommt
  also nicht immer dazu, dass die Zustandsübergangsrelation bei einem
  Zustand der Form $(\epsilon, \varnothing, \llbracket e\rrbracket,
  \epsilon)$ terminiert.
\item Das $x$ aus dieser Definition ist nicht immer ein Basiswert~--
  es kann auch eine Closure sein.
\end{itemize}
%
Der erste Haken sorgt dafür, dass die Auswertungsfunktion nur eine
"<partiellen Funktion"> ist.  Beim zweiten
Haken, wenn $x$ eine Closure ist, lässt sich mit dem Resultat nicht
viel anfangen: Um die genaue Bedeutung der Closure herauszubekommen,
müsste sie angewendet werden~-- das Programm ist aber schon fertig
gelaufen.  Es ist deshalb nicht sinnvoll, zwischen verschiedenen
Closures zu unterscheiden.  Darum wird für die Zwecke der
Auswertungsfunktion eine Menge $Z$ der \textit{Antworten\index{Antwort}}
definiert, die einen designierten Spezialwert für Closures enthält:
%
\begin{displaymath}
  Z \deq{} B \cup \{ \texttt{function} \}
\end{displaymath}
%
Damit können wir die Evaluationsfunktion wie folgt definieren:
%
\begin{eqnarray*}
  \mathit{eval}_\mathit{SECD} & \in & \mathcal{L}_{\lambda{}A} \times Z\\
  \mathit{eval}_\mathit{SECD}(e) & = &
  \begin{cases}
    b & \textrm{falls } (\epsilon, \varnothing, \llbracket e\rrbracket, \epsilon)
    \hookrightarrow^* (b, e, \epsilon, \epsilon)\\
    \texttt{function} & \textrm{falls } (\epsilon, \varnothing, \llbracket e\rrbracket, \epsilon)
    \hookrightarrow^* ((v, \underline{c}, e'), e, \epsilon, \epsilon)\\
  \end{cases}
\end{eqnarray*}
%
Diese Funktion wollen wir natürlich auch laufen sehen.  Dafür
programmieren wir die mathematischen Definitionen im Rest des Kapitels
nach.

\begin{aufgabeinline}
  Fahre fort mit der Realisierung von binären Verzweigungen:
  \begin{enumerate}
  \item Erweitere die Grammatik für SECD-Instruktionen um eine
    Instruktion für binäre Verzweigungen.  Die muss den Code für die
    beiden Zweige des \lstinline{if}-Ausdrucks enthalten.
  \item Erweitere die Funktion $\llbracket \underline{~}\rrbracket$
    um eine Klausel für \lstinline{if}-Ausdrücke: Sie sollte zunächst
    den Code für die Bedingung liefern, gefolgt von der neuen
    Instruktion.
  \item Erweitere die Definition von $\hookrightarrow$ um die neue
    Instruktion.
  \end{enumerate}
\end{aufgabeinline}

\section{\texttt{Quote} und Symbole}
\label{sec:quote}

\mentioncode{secd/compute.rkt}
%
Um die Definitionen möglichst elegant nachzuprogrammieren, machen wir ab hier
Gebrauch von einer weiteren
Sprachebene\index{Sprachebene!fortgeschritten} in
\drscheme{} machen, nämlich \texttt{Schreibe Dein Programm! -
  fortgeschritten}.  Diese Ebene muss mit dem \drscheme{}-Menü \texttt{Sprache}
unter \texttt{Sprache auswählen} aktiviert sein, damit die
Programme dieses Kapitels funktionieren.

Die entscheidende Änderung gegenüber den früheren Sprachebenen ist
die Art, mit der die REPL Werte ausdruckt.  Bei Zahlen, Zeichenketten
und booleschen Werten bleibt alles beim alten:
%
\begin{lstlisting}
5
|\evalsto| 5
"Mike ist doof"
|\evalsto| "Mike ist doof"
#t
|\evalsto| #t
\end{lstlisting}
%
Bei Listen sieht es allerdings anders aus:
%
\begin{lstlisting}
(list 1 2 3 4 5 6)
|\evalsto| (1 2 3 4 5 6)
\end{lstlisting}
%
Die REPL druckt also eine Liste aus, indem sie zuerst eine öffnende
Klammer ausdruckt, dann die Listenelemente (durch Leerzeichen
getrennt) und dann eine schließende Klammer.
Das funktioniert auch für die leere Liste:
%
\begin{lstlisting}
empty
|\evalsto| ()
\end{lstlisting}
%
Mit der neuen Sprachebene bekommt außerdem der Apostroph, der dem
Literal\index{Literal} für die leere Liste voransteht, eine erweiterte Bedeutung.
Unter anderem kann der Apostroph benutzt werden, um Literale für
Listen zu formulieren:
%
\begin{lstlisting}
'(1 2 3 4 5 6)
|\evalsto| (1 2 3 4 5 6)
'(1 #t "Mike" (2 3) "doof" 4 #f 17)
|\evalsto| (1 #t "Mike" (2 3) "doof" 4 #f 17)
'()
|\evalsto| ()
\end{lstlisting}
%
In der neuen Sprachebene benutzen die Literale und die ausgedruckten
externen Repräsentationen für Listen also die gleiche
Notation\index{Repräsentation}.  Sie unterscheiden sich nur dadurch,
dass beim Literal der Apostroph voransteht.  Der Apostroph funktioniert
auch bei Zahlen, Zeichenketten und booleschen Werten:
%
\begin{lstlisting}
'5
|\evalsto| 5
'"Mike ist doof"
|\evalsto| "Mike ist doof"
'#t
|\evalsto| #t
\end{lstlisting}
%
Der Apostroph am Anfang eines Ausdrucks
kennzeichnet diesen also als Literal.  Der Wert des Literals wird 
genauso ausgedruckt, wie es im Programm steht.  (Abgesehen von
Leerzeichen und Zeilenumbrüchen.)  Der Apostroph heißt auf englisch
"<quote">\index{quote@\lstinline{quote}}, und deshalb ist diese
Literalschreibweise auch unter diesem Namen bekannt.  Bei Zahlen,
Zeichenketten und booleschen Literalen ist auch ohne Quote klar, dass
es sich um Literale handelt.  Das Quote ist darum bei ihnen rein
optional; sie heißen 
\textit{selbstquotierend}\index{selbstquotierend}.

Bei Listen hingegen sind Missverständnisse mit anderen
zusammengesetzten Formen möglich, die ja auch mit einer öffnenden Klammer
beginnen.\footnote{Tatsächlich ist die neue Schreibweise für externe
  Repräsentationen die Standard-Repräsentation in Racket.  Die
  früheren Sprachebenen benutzten die alternative Schreibweise, um die
  Verwirrung zwischen Listenliteralen und zusammengesetzten Formen zu
  vermeiden.} 

Mit der Einführung von Quote kommt noch eine völlig neue Sorte Werte
hinzu: die \textit{Symbole\index{Symbol}}.  Symbole sind Werte ähnlich wie Zeichenketten und
bestehen aus Text.  Sie unterscheiden sich allerdings dadurch, dass sie
als Literal mit Quote statt Anführungszeichen geschrieben und in der REPL ohne
Anführungszeichen ausgedruckt werden:
%
\begin{lstlisting}
'mike
|\evalsto| mike
'doof
|\evalsto| doof
\end{lstlisting}
%
Symbole können wir mit dem Prädikat
\lstinline{symbol?}\indexvariable{symbol} von anderen Werten
unterscheiden:
%
\begin{lstlisting}
(symbol? 'mike)
|\evalsto| #t
(symbol? 5)
|\evalsto| #f
(symbol? "Mike")
|\evalsto| #f
\end{lstlisting}
%
Symbole sind auch der Grund, warum Listen nicht selbstquotierend sind.
Andernfalls wäre
missverständlich, ob  \lstinline{(run-over-dillo d1)} eine Literal für
eine Liste
ergibt (mit den Symbolen \lstinline{run-over-dillo} und \lstinline{d1}
als Elementen) oder den Aufruf der Funktion
\lstinline{run-over-dillo}.  Deswegen ist ein Quote notwendig.

Vergleichen können wir Symbole mit der eingebauten Funktion
\lstinline{equal?}~-- siehe dazu Abbildung~\ref{scheme:equalp}):
\begin{feature}{\texttt{equal?}}{scheme:equalp}
  Die Funktion \texttt{equal?\indexvariable{equal?}} vergleicht beliebige Werte:
  Booleans, Zeichen und Zeichenketten.
  Bei Listen werden die Elemente verglichen und bei Records die Komponenten. 
%
\begin{lstlisting}
(equal? 23 23)
|\evalsto| #t
(equal? #t #f)
|\evalsto| #f
(equal? "Axl" "Slash")
|\evalsto| #f
(equal? "Axl" "Axl")
|\evalsto| #t
(equal? (list "Axl" "Slash") (list "Axl" "Slash"))
|\evalsto| #t
(equal? (list "Axl" "Slash") (list "Axl" "Slash" "Duff"))
|\evalsto| #f
(equal? (make-wallclock-time 12 24) (make-wallclock-time 12 24))
|\evalsto| #t
(equal? (make-wallclock-time 12 24) (make-wallclock-time 12 25))
|\evalsto| #f
(equal? (make-wallclock-time 12 24) (list "Axl" "Slash"))
|\evalsto| #f
\end{lstlisting}
\end{feature}

\begin{lstlisting}
(equal? 'mike 'herb)
|\evalsto| #f
(equal? 'mike 'mike)
|\evalsto| #t
\end{lstlisting}
%
Symbole können nicht aus beliebigem Text bestehen;  
Leerzeichen sind zum Beispiel verboten.  Tatsächlich entsprechen die
Namen der zulässigen Symbole genau den Namen von Variablen:
%
\begin{lstlisting}
'karl-otto
|\evalsto| karl-otto
'mehrwertsteuer
|\evalsto| mehrwertsteuer
'duftmarke
|\evalsto| duftmarke
'lambda
|\evalsto| lambda
'+
|\evalsto| +
'*
|\evalsto| *
\end{lstlisting}
%
Diese Entsprechung wird in diesem Kapitel noch eine entscheidene Rolle
spielen.  Symbole können natürlich auch in Listen und damit auch in
Listenliteralen vorkommen:
%
\begin{lstlisting}
'(karl-otto mehrwertsteuer duftmarke)
|\evalsto| (karl-otto mehrwertsteuer duftmarke)
\end{lstlisting}
%
Mit Hilfe von Symbolen können Werte konstruiert werden, die in der REPL
ausgedruckt wie Ausdrücke aussehen:
%
\begin{lstlisting}
'(+ 1 2)
|\evalsto| (+ 1 2)
'(lambda (n) (+ n 1))
|\evalsto| (lambda (n) (+ n 1))
\end{lstlisting}
%
Auch wenn diese Werte wie Ausdrücke aussehen, sind sie doch ganz
normale Listen: der Wert von \verb|'(+ 1 2)| ist eine Liste mit drei
Elementen: das Symbol \verb|+|, die Zahl \lstinline{1} und die Zahl
\lstinline{2}.  Der Wert von \verb|'(lambda (n) (+ n 1))| ist ebenfalls
eine Liste mit drei Elementen: das Symbol \verb|lambda|, eine Liste
mit einem einzelnen Element, nämlich dem Symbol \lstinline{n}, und einer
weiteren Liste mit drei Elementen: dem Symbol \lstinline{+}, dem Symbol
\lstinline{n} und der Zahl \lstinline{1}.

Quote hat noch eine weitere verwirrende Eigenheit:
%
\begin{lstlisting}
''()
|\evalsto| '()
\end{lstlisting}
%
Dieses Literal bezeichnet nicht die leere Liste (dann würde nur
\lstinline{()} ausgedruckt, ohne Quote), sondern etwas anderes:
%
\begin{lstlisting}
(cons? ''())
|\evalsto| #t
(first ''())
|\evalsto| quote
(rest ''())
|\evalsto| (())
\end{lstlisting}
%
Der Wert des Ausdrucks \verb|''()| ist also eine Liste mit zwei
Elementen: das erste Element ist das Symbol \lstinline{quote} und das
zweite Element ist die leere Liste.  \lstinline{'$t$}
ist selbst also nur syntaktischer Zucker, und zwar für
\lstinline{(quote $t$)}:
%
\begin{lstlisting}
(equal? (quote ()) '())
|\evalsto| #t
(equal? (quote (quote ())) ''())
|\evalsto| #t
\end{lstlisting}
%
Quote erlaubt die Konstruktion von Literalen für viele Werte, aber
nicht für alle.  Ein Wert, für den Quote ein Literal konstruieren kann,
heißt \textit{repräsentierbarer
  Wert\index{repräsentierbarer Wert}}.  Ein repräsentierbarer Wert ist
eins der folgenden:
%
\begin{itemize}
\item eine Zahl
\item ein boolescher Wert
\item eine Zeichenketten
\item ein Symbol
\item eine Liste aus repräsentierbaren Werten
\end{itemize}
%
Um zu demonstrieren, wozu Symbolen und Quote gut sind,
programmieren wir sowas wie einen Taschenrechner.
Der kann den Wert von Ausdrücken wir \lstinline{(+ 23 65)}
ausrechnen.  Wir legen dafür folgende Datendefinition zugrunde:
%
\begin{lstlisting}
; Ein Ausdruck ist eins der folgenden:
; - eine Zahl
; - eine Liste der Form (+ Ausdruck Ausdruck)
; - eine Liste der Form (* Ausdruck Ausdruck)
\end{lstlisting}
%
Es handelt sich entsprechend der Formulierung "<eins der folgenden">
um gemischte Daten.
Um dafür
eine passende Signatur zu definieren, benötigen wir Signaturen
für alle Fälle.  Für den ersten Fall tut es \lstinline{number}.  Für
die beiden anderen ist es nicht ganz so einfach, weil es kein
\lstinline{define-record} gibt, das die Signatur einfach für uns
definiert.  Wir müssen also die Signatur selbst definieren und machen
das mit Hilfe von Prädikaten für die beiden Fälle, die wir selbst schreiben.

Zur Erinnerung: Ein Prädikat\index{Prädikat} ist eine Funktion, die
einen beliebigen Wert akzeptiert, auf eine bestimmte Eigenschaft
testet und entsprechend entweder \lstinline{#t} oder \lstinline{#f}
zurückgibt.  So etwas brauchen wir für die beiden Fälle, die mit
"<eine Liste der Form"> beginnen.  Zunächst die Addition:
%
\indexvariable{addition?}
\begin{lstlisting}
; Ist ein Wert ein Additionsausdruck?
(: addition? (any -> boolean))

(check-expect (addition? '5) #f)
(check-expect (addition? '(+ 1 2)) #t)
(check-expect (addition? '(* 1 2)) #f)

(define addition?
  (lambda (x)
    (and (cons? x)
         (equal? '+ (first x)))))
\end{lstlisting}
%
Beim Prädikat \lstinline{addition?} haben wir nur das nötigste
programmiert, um Additionen von den anderen Fällen zu unterscheiden:
\begin{aufgabeinline}
  In der Datendefinition oben steht "<\texttt{eine Liste der Form (+
    Ausdruck Ausdruck)}">.  Gibt es Eingaben, bei denen
  \lstinline{addition?} als Ergebnis \lstinline{#t} liefert, obwohl es
  sich nicht um Listen genau dieser Form handelt?
\end{aufgabeinline}
%
\begin{feature}{\texttt{predicate}}{feature:predicate}
  Bei einer Signatur der Form
\begin{lstlisting}
(predicate $p$)
\end{lstlisting}
  muss $p$ ein Prädikat, also eine Funktion mit folgender Signatur sein:
\begin{lstlisting}
(any -> boolean)
\end{lstlisting}
  Diese Signatur passt für alle Werte, bei denen das Prädikat
  \lstinline{#t} liefert.
\end{feature}
%
Aus dem Prädikat \lstinline{addition?} können wir eine Signatur
\lstinline{addition} machen mit Hilfe einer
\lstinline{predicate}-Signatur.  Das ist neu; siehe dazu
Abbildung~\ref{feature:predicate}.  Hier ist die Definition von
\lstinline{addition}:
%
\indexvariable{addition}
\begin{lstlisting}
(define addition
  (signature (predicate addition?)))
\end{lstlisting}
%
Entsprechend machen wir das für Multiplikationen:
%
\indexvariable{multiplication?}
\indexvariable{multiplication}
\begin{lstlisting}
; Ist ein Wert ein Multiplikationsausdruck?
(: multiplication? (any -> boolean))

(check-expect (multiplication? '5) #f)
(check-expect (multiplication? '(* 1 2)) #t)
(check-expect (multiplication? '(+ 1 2)) #f)

(define multiplication?
  (lambda (x)
    (and (cons? x)
         (equal? '* (first x)))))
(define multiplication
  (signature (predicate multiplication?)))
\end{lstlisting}
%
Nun haben wir Signaturen für die drei Fälle und können damit eine
Signatur für Ausdrücke definieren:
%
\indexvariable{expression}
\begin{lstlisting}
(define expression
  (signature (mixed number addition multiplication)))
\end{lstlisting}
%
Jetzt können wir den "<Taschenrechner"> programmieren.  Hier sind
Kurzbeschreibung, Signatur und Testfälle:
%
\begin{lstlisting}
; Wert eines Ausdrucks berechnen
(: compute (expression -> number))

(check-expect (compute '23) 23)
(check-expect (compute '(+ 23 42)) 65)
(check-expect (compute '(+ 23 (* 6 7))) 65)
\end{lstlisting}
%
Die Funktionsdefinition geht strikt nach Konstruktionsanleitung.  Hier
die Schablone:
%
\begin{lstlisting}
(define compute
  (lambda (exp)
    (cond
      ((number? exp) ...)
      ((addition? exp) ...)
      ((multiplication? exp) ...))))
\end{lstlisting}
%
Beim ersten Zweig ist \lstinline{exp} schon eine Zahl~-- die muss die
Funktion nur zurückgeben:
%
\begin{lstlisting}
(define compute
  (lambda (exp)
    (cond
      ((number? exp) exp)
      ((addition? exp) ...)
      ((multiplication? exp) ...))))
\end{lstlisting}
%
Beim \lstinline{addition}-Fall ist \lstinline{exp} eine Liste, deren
zweites und drittes Element jeweils wieder ein Ausdruck ist.  Es
handelt sich also um zusammengesetzte Daten, allerdings nicht mit
einem Record definiert.  Die Komponenten extrahieren wir mit
\lstinline{first} und \lstinline{rest}:
%
\begin{lstlisting}
(define compute
  (lambda (exp)
    (cond
      ((number? exp) exp)
      ((addition? exp)
       ... (first (rest exp)) ...
       ... (first (rest (rest exp))) ...)
      ((multiplication? exp) ...)))))
\end{lstlisting}
%
Außerdem haben wir es jeweils mit Selbstbezügen zu tun, also müssen noch
rekursive Aufrufe in die Schablone:
%
\begin{lstlisting}
(define compute
  (lambda (exp)
    (cond
      ((number? exp) exp)
      ((addition? exp)
       ... (compute (first (rest exp))) ...
       ... (compute (first (rest (rest exp)))) ...)
      ((multiplication? exp) ...)))))
\end{lstlisting}
%
Die beiden rekursiven Aufrufe liefern jeweils den Wert der beiden
Operanden der Addition; die muss die Funktion nur noch addieren.  Bei
der Multiplikation läuft es genauso:
%
\indexvariable{compute}
\begin{lstlisting}
(define compute
  (lambda (exp)
    (cond
      ((number? exp) exp)
      ((addition? exp)
       (+ (compute (first (rest exp)))
          (compute (first (rest (rest exp))))))
      ((multiplication? exp)
       (* (compute (first (rest exp)))
          (compute (first (rest (rest exp)))))))))
\end{lstlisting}
% 
Fertig!
%
\begin{aufgabeinline}
  Ändere die Datendefinitionen so, dass Addition und Multiplikation
  jeweils eine beliebige Anzahl von Argumenten akzeptiert, nicht nur
  zwei.  Ändere \lstinline{compute} entsprechend!
\end{aufgabeinline}

\section{Datendefinitionen für den $\lambda$-Kalkül}
\label{sec:datendefinitionen-lambda}

\mentioncode{secd/secd.rkt}
%
Die SECD-Maschine ist ein Modell für die Implementierung des
$\lambda$-Kalküls.  Eine solche Implementierung lässt sich in einfach
bauen~-- dieser Abschnitt zeigt, wie.  Der grobe Fahrplan ergibt sich
dabei aus der Struktur der SECD-Maschine selbst: Nach den
obligatorischen Datendefinitionen übersetzen wir Terme in
Maschinencode.  Dann kommt die Zustandsübergangsfunktion und
schließlich die Auswertungsfunktion an die Reihe.

Die erste Aufgabe ist dabei zunächst, wie immer, die Datenanalyse: Am
Anfang stehen die Terme des angewandten $\lambda$-Kalküls.  Eine
geeignete Repräsentation mit Listen und Symbolen lässt dabei die Terme
in der "<fortgeschrittenen"> Sprachebene genau wie entsprechenden
Programm-Terme aussehen:

\noindent\begin{tabular}{lll}
  \texttt{(+ 1 2)} & steht für & $(+~1~2)$\\
  \texttt{(lambda (x) x)} & steht für & $\lambda \lrm x.\lrm x$\\
  \texttt{((lambda (x) (x x)) (lambda (x) (x x)))} & steht für &
  $(\lambda \lrm x.(\lrm x~\lrm x))~(\lambda \lrm x.(\lrm x~\lrm x))$\\
  etc.
\end{tabular}

Die Datendefinition dafür orientiert sich direkt an
Definition~\ref{def:lambda-angewandt}:
%
\begin{lstlisting}
; Ein Lambda-Term ist eins der folgenden:
; - ein Symbol (für eine Variable)
; - eine zweielementige Liste (für eine reguläre Applikation)
; - eine Liste der Form (lambda (x) e) (für eine Abstraktion)
; - ein Basiswert
; - eine Liste mit einem Primitiv als erstem Element
;      (für eine primitive Applikation)
\end{lstlisting}
%
Hier die dazu passende Signatur-Definition:
%
\indexvariable{term}
\begin{lstlisting}
(define term
  (signature
    (mixed symbol
           application
           abstraction
           primitive-application
           base)))
\end{lstlisting}
%
Die Signaturen für \lstinline{application}, \lstinline{abstraction},
\lstinline{primitive-application} und \lstinline{base} müssen wir noch
definieren, wie bei den Ausdrücken des vorigen Abschnitts.
Da es sich nicht um Record-Typen handelt, müssen wir das
selbst machen, und zwar, indem wir jeweils ein Prädikat definieren.
Hier ist das Prädikat für \lstinline{abstraction}:
%
\indexvariable{abstraction?}
\begin{lstlisting}
; Prädikat für Abstraktionen
(: abstraction? (any -> boolean))
(define abstraction?
  (lambda (term)
    (and (cons? term)
         (equal? 'lambda (first term)))))
\end{lstlisting}
%
Aus diesem Prädikat machen wir eine Signatur mit
\lstinline{predicate}.Hier ist die Definition:
%
\indexvariable{abstraction}
\begin{lstlisting}
(define abstraction (signature (predicate abstraction?)))
\end{lstlisting}
%
%
Entsprechend definieren wir die anderen Signaturen.  Bei
\lstinline{application} müssen wir ein bisschen aufpassen, damit wir
bei den "<normalen"> Applikationen keine Applikationen von Primitiva
erwischen:
%
\indexvariable{application?}
\indexvariable{application}
\begin{lstlisting}
; Prädikat für reguläre Applikationen
(: application? (any -> boolean))
(define application?
  (lambda (term)
    (and (cons? term)
         (not (equal? 'lambda (first term)))
         (not (primitive? (first term))))))

(define application (signature (predicate application?)))
\end{lstlisting}
%
Hier ist die dort benutzte Funktion \lstinline{primitive?} mit den
allernötigsten primitiven Operationen:\label{page:primitivep}
%
\indexvariable{primitive?}
\begin{lstlisting}
; Ein Primitiv ist eins der Symbole +, -, *, /, =

; Prädikat für Primitivum
(: primitive? (any -> boolean))
(define primitive?
  (lambda (term)
    (or (equal? '+ term)
        (equal? '- term)
        (equal? '* term)
        (equal? '/ term)
        (equal? '= term))))
\end{lstlisting}
%
Die Definition von \lstinline{primitive-application} entspricht
\lstinline{application}, nur dass hier nur Primitiva erwünscht sind:
%
\indexvariable{primitive-application?}
\indexvariable{primitive-application }
\begin{lstlisting}
; Prädikat für primitive Applikationen
(: primitive-application? (any -> boolean))
(define primitive-application?
  (lambda (term)
    (and (cons? term)
         (primitive? (first term)))))

(define primitive-application 
  (signature (predicate primitive-application?)))
\end{lstlisting}
%
Es fehlt noch die Definition von \lstinline{base}.  Der Einfachheit
halber beschränken wir uns auf boolesche Werte und Zahlen:\label{page:basiswert}
%
\begin{lstlisting}
; Ein Basiswert ist ein boolescher Wert oder eine Zahl
\end{lstlisting}
%
Auch dafür schreiben wir zunächst ein Prädikat und definieren damit
eine Signatur:
%
\indexvariable{base?}
\indexvariable{base}
\begin{lstlisting}
; Prädikat für Basiswerte
(: base? (any -> boolean))
(define base?
  (lambda (term)
    (or (boolean? term) (number? term))))

(define base (signature (predicate base?)))
\end{lstlisting}

\begin{aufgabeinline}
  Erweitere die Definition von \lstinline{term} um binäre
  Verzweigungen in Form von \lstinline{if}-Ausdrücken.  Schreibe dafür
  zunächst ein Prädikat \lstinline{binary-conditional?} und definiere
  mit Hilfe davon eine Signatur \lstinline{binary-condition}.
  Erweitere \lstinline{term} um \lstinline{binary-conditional}.
\end{aufgabeinline}

\section{Datendefinition für Maschinensprache}
% 
Bevor nun ein die SECD-Maschine einen Term verarbeiten kann, muss
dieser erst in Maschinencode übersetzt werden.  Dabei entsteht aus
Definition~\ref{def:secd-code} direkt Daten- und Signatur-Definitionen
für Instruktionen und Maschinencode:
%
\indexvariable{instruction}
\indexvariable{machine-code}
\begin{lstlisting}
; Eine Instruktion ist eins der folgenden:
; - ein Basiswert
; - eine Variable
; - eine Applikations-Instruktion
; - eine Instruktion für eine primitive Applikation
; - eine Abstraktion
(define instruction
  (signature
    (mixed base
           symbol
           ap
           prim
           abs))

; Eine Maschinencode-Programm ist eine Liste von Instruktionen.
(define machine-code (signature (list-of instruction)))
\end{lstlisting}
%
Basiswerte und Variablen sind wie bei den Termen.
Für \lstinline{ap}, \lstinline{prim} und \lstinline{abs} machen wir
jeweils eigene Datendefinitionen.
Wie schon bei den leeren Listen hat auch die Applikations-Instruktion
keine Eigenschaften:
%
\begin{lstlisting}
; Applikations-Instruktion
(define-record ap
  make-ap ap?)
\end{lstlisting}
%
Die Instruktion für die primitive Applikation \texttt{prim}$_{F^i}$
hat als Eigenschaften den Namen des Operators $F$ und dessen Anzahl
von Argumenten $i$, auch \textit{Stelligkeit}\index{Stelligkeit}.
Stelligkeit heißt auf Englisch "<arity">.  Entsprechend sehen Daten-
und Record-Definition so aus:
%
\begin{lstlisting}
; Eine Instruktion für eine primitive Applikation hat folgende
; Eigenschaften:
; - Operator
; - Stelligkeit
(define-record prim
  make-prim prim?
  (prim-operator symbol)
  (prim-arity natural))
\end{lstlisting}
%
Die Abstraktions-Instruktion der Form (\meta{V}, \meta{C}) hat als
Eigenschaften sichtlich den Parameter und den Code für den Rumpf,
das übersetzen wir direkt in Daten- und Record-Definition:
%
\begin{lstlisting}
; Eine Abstraktions-Instruktion hat folgende Eigenschaften:
; - Parameter (eine Variable)
; - Code für den Rumpf
(define-record abst
  make-abst abs?
  (abst-variable symbol)
  (abst-code machine-code))
\end{lstlisting}
%
\begin{aufgabeinline}
  Erweitere die Definition von \lstinline{instruction} um eine
  Instruktion für binäre Verzweigungen.  Schreibe dazu eine Daten- und
  eine Record-Definition, die zur Erweiterung der Grammatik für
  SECD-Instruktionen passt.  Erweitere \lstinline{instruction} damit.
\end{aufgabeinline}

\section{Ein Compiler für die SECD-Maschine}

Nun, da sowohl Terme als auch der Maschinencode Datendefinitionen
haben, ist es möglich, die Übersetzung vom angewandten
$\lambda$-Kalkül in die Maschinensprache der SECD-Maschine zu
programmieren.  Solch eine Übersetzung heißt \textit{Compiler}.\index{Compiler}

Hier sind Kurzbeschreibung, Signatur und Gerüst des Compilers:
%
\begin{lstlisting}
; Term in Maschinencode übersetzen
(: term->machine-code (term -> machine-code))
(define term->machine-code
  (lambda (term)
    ...))
\end{lstlisting}
%
Hier sind zwei Testfälle:
%
\begin{lstlisting}
(check-expect (term->machine-code '(+ 1 2))
              (list 1 2 (make-prim '+ 2)))
(check-expect (term->machine-code 
                '((lambda (x) (x x)) (lambda (x) (x x))))
              (list (make-abst 'x (list 'x 'x (make-ap)))
                    (make-abst 'x (list 'x 'x (make-ap)))
                    (make-ap)))
\end{lstlisting}
%
Da es sich bei \lstinline{term} um gemischte Daten handelt, muss~-- wie
immer~-- eine Verzweigung den Rumpf der Funktion bilden:
%
\indexvariable{term->machine-code}
\begin{lstlisting}
(define term->machine-code
  (lambda (term)
    (cond
      ((symbol? term) ...)
      ((application? term) ...)
      ((abstraction? term) ...)
      ((base? term) ...)
      ((primitive-application? term) ...))))
\end{lstlisting}
%
Die Implementierung entspricht in den einzelnen Fällen genau der
Übersetzungsfunktion $\llbracket\underline{~}\rrbracket$ in
Abschnitt~\ref{page:secd-translation} auf
Seite~\pageref{page:secd-translation}. Zur Erinnerung sind hier die Fälle für Variablen und
Basiswerte:
\begin{eqnarray*}
    \llbracket e \rrbracket &\deq&
  \begin{cases}
    b & \textrm{falls $e = b \in B$}\\
    v & \textrm{falls $e = v \in V$}\\
  \end{cases}
\end{eqnarray*}
%
Der Code dafür entspricht dem direkt~-- wir müssen nur daran denken,
immer eine Liste zu produzieren, auch wenn nur eine einzelne
Instruktion herauskommt:
%
\begin{lstlisting}
(define term->machine-code
  (lambda (term)
    (cond
      ((symbol? term) (list term))
      ((base? term) (list term))
      ...)))
\end{lstlisting}
%
Bei regulären Applikationen sieht die Übersetzungsfunktion so aus:
%
\begin{eqnarray*}
  \llbracket e \rrbracket &\deq&
  \begin{cases}
    \llbracket e_0\rrbracket~\llbracket e_1\rrbracket~\mathtt{ap}
    & \textrm{falls $e = (e_0~e_1)$}\\
  \end{cases}
\end{eqnarray*}
%
Es werden also Operator und Operand übersetzt, und das ganze zusammen
mit einer \lstinline{ap}-Instruktion zu einer Liste zusammengesetzt:
%
\begin{lstlisting}
(define term->machine-code
  (lambda (term)
    (cond
      ...
      ((application? term)
       (append (term->machine-code (first term))
               (append (term->machine-code (first (rest term)))
                       (list (make-ap)))))
      ...)))
\end{lstlisting}
%
Bei den primitiven Applikationen sieht die Übersetzungsfunktion so
aus:
%
\begin{displaymath}
  \llbracket e \rrbracket \deq
    \llbracket e_1\rrbracket~\ldots~\llbracket e_k\rrbracket~\mathtt{prim}_{F^i}
     \quad\textrm{falls $e = (F~e_1~\ldots~e_i)$}
\end{displaymath}
%
Hier werden erst einmal die Operanden in Maschinencode übersetzt, die
Resultate aneinandergehängt, und schließlich kommt noch eine
\lstinline{prim}-Instruktion ans Ende:
%
\begin{lstlisting}
(define term->machine-code
  (lambda (term)
    (cond
      ...
      ((primitive-application? term)
       (append
        (append-lists
         (map term->machine-code (rest term)))
        (list (make-prim (first term) (length (rest term))))))
      ...)))
\end{lstlisting}
%
Dieses Stück Code benutzt die Hilfsfunktion \lstinline{append-lists}, die
aus einer Liste von Listen eine einzelne Liste macht, indem die
Elemente aneinandergehängt werden~-- das geht mit \lstinline{fold}:
%
\indexvariable{append-lists}
\begin{lstlisting}
; die Elemente einer Liste von Listen aneinanderhängen
(: append-lists ((list-of (list-of %a)) -> (list-of %a)))
(define append-lists
  (lambda (list)
    (fold '() append list)))
\end{lstlisting}
%
Zurück zur Übersetzung: Eine Abstraktion wird direkt in eine
\lstinline{abs}-Instruktion übersetzt, wobei der Rumpf selbst
noch in Maschinencode übersetzt wird:
\begin{displaymath}
  \llbracket e \rrbracket \deq
    (v, \llbracket e_0\rrbracket) \quad \textrm{falls $e = \lambda v.e_0$}
\end{displaymath}
%
\begin{lstlisting}
(define term->machine-code
  (lambda (term)
    (cond
      ...
      ((abstraction? term)
       (list
        (make-abst (first (first (rest term)))
                   (term->machine-code
                    (first (rest (rest term))))))))))
\end{lstlisting}
%
Fertig ist der Compiler!
%
\begin{aufgabeinline}
  Erweitere den Compiler \lstinline{term->machine-code} um
  binäre Verzweigungen.  Vergiss nicht ein paar Tests!
\end{aufgabeinline}

\section{SECD-Code ausführen}
\label{sec:secd-transition}

Eine SECD-Maschine gibt's leider nicht zu kaufen, wir simulieren sie
deshalb mit einem weiteren Programm, einer sogenannten
\textit{virtuellen Maschine}.\index{virtuelle Maschine}

Zunächst sind Datendefinitionen für die vier Bestandteile der
Maschine~-- $S$, $E$, $C$ und $D$ fällig.  Zunächst einmal die Menge
$S$ der Stacks.  Mathematisch hatten wir sie so definiert:
%
\begin{eqnarray*}
    S &\deq& W^\ast
\end{eqnarray*}
%
Entsprechend definieren wir den Stack als eine Liste von Werten:
%
\indexvariable{stack}
\begin{lstlisting}
; Ein Stack ist eine Liste von Werten
(define stack (signature (list-of value)))
\end{lstlisting}
%
Die Definition von Werten \lstinline{value}, entsprechend der
mathematischen Definition für $W$, kommt etwas später an die Reihe.

Umgebungen aus der Menge $E$ sind mathematisch gesehen Mengen aus
Tupeln:
%
\begin{eqnarray*}
  E &\subseteq& V\times W
\end{eqnarray*}
%
Im Code werden Umgebungen dargestellt aus Listen von
\textit{Bindungen\index{Bindung}}, wobei jede Bindung einem Tupel aus
der mathematischen Definition entspricht:
%
\indexvariable{environment}
\begin{lstlisting}
; Eine Umgebung ist eine Liste von Bindungen.
; Dabei gibt es für jede Variable nur eine Bindung.
(define environment (signature (list-of binding)))

; Eine Bindung besteht aus:
; - Variable
; - Wert
(define-record binding
  make-binding binding?
  (binding-variable symbol)
  (binding-value value))
\end{lstlisting}
% 
Die leere Umgebung wird öfter benötigt; wir definieren sie darum schon
vor:
%
\indexvariable{the-empty-environment}
\begin{lstlisting}
; die leere Umgebung
(define the-empty-environment empty)
\end{lstlisting}
%
(Aber \lstinline{empty} ist doch kürzer, könntest Du einwenden.  Ja,
aber dann sehen wir dem \lstinline{empty} nicht an, ob es eine leere
Liste von Instruktionen oder eine Umgebung oder eine ganz andere Liste
ist.)

Zwei Operationen gibt es für eine Umgebung $e$: die Erweiterung um
eine Bindung $e[v\mapsto w]$ und das Nachschauen einer Bindung $e(v)$.
Zunächst die Erweiterung: die Implementierung entspricht genau der
mathematischen Definition.  Hier sind Kurzbeschreibung und Signatur:
% 
\begin{lstlisting}
; eine Umgebung um eine Bindung erweitern
(: extend-environment (environment symbol value -> environment))
\end{lstlisting}
%
Hier sind ein paar Testfälle:
%
\begin{lstlisting}
(check-expect (extend-environment the-empty-environment 'axl 59)
              (list (make-binding 'axl 59)))
(check-expect (extend-environment
               (extend-environment
                the-empty-environment
                'axl 60)
               'slash 57)
              (list (make-binding 'slash 57) (make-binding 'axl 60)))
(check-expect (extend-environment
               (extend-environment
                the-empty-environment
                'axl 59)
               'axl 60)
              (list (make-binding 'axl 60)))
\end{lstlisting}
%
Die Definition entfernt zunächst eine eventuell vorhandene Bindung
für $v$ und fügt eine neue Bindung hinzu:
%
\indexvariable{extend-environment}
\begin{lstlisting}
(define extend-environment
  (lambda (environment variable value)
    (cons (make-binding variable value)
          (remove-environment-binding environment variable))))
\end{lstlisting}
%
Für das Entfernen der alten Bindung ist die Hilfsfunktion
\lstinline{remove-environment-binding} zuständig.  Sie folgt der
Konstruktionsanleitung.  Hier die Schablone:
%
\begin{lstlisting}
; die Bindung für eine Variable aus einer Umgebung entfernen
(: remove-environment-binding (environment symbol -> environment))
(define remove-environment-binding
  (lambda (environment variable)
    (cond
      ((empty? environment) ...)
      ((cons? environment)
       ...
       (first environment)
       (remove-environment-binding (rest environment) variable)
       ...))))))
\end{lstlisting}
%
Da es sich bei \lstinline{(first environment)} um eine Bindung, also
zusammengesetzte Daten handelt, können wir Aufrufe für die Selektoren
in die Schablone aufnehmen:
%
\begin{lstlisting}
(define remove-environment-binding
  (lambda (environment variable)
    (cond
      ((empty? environment) ...)
      ((cons? environment)
       ...
       (first environment)
       (binding-variable (first environment))
       (binding-value (first environment))
       (remove-environment-binding (rest environment) variable)
       ...))))))
\end{lstlisting}
%
Bei der Bindung interessiert uns, ob zur gesuchten Variable gehört.
Entsprechend vervollständigen wir die Schablone:
%
\indexvariable{remove-environment-binding}
\begin{lstlisting}
(define remove-environment-binding
  (lambda (environment variable)
    (cond
      ((empty? environment) empty)
      ((cons? environment)
       (if (equal? variable (binding-variable (first environment)))
           (rest environment)
           (cons (first environment)
                 (remove-environment-binding (rest environment)
                                             variable)))))))
\end{lstlisting} 
%
Auch die zweite Operation, das Nachschauen einer Bindung in der
Umgebung, folgt der Konstruktionsanleitung.  Hier sind
Kurzbeschreibung, Signatur und Testfälle:
%
\begin{lstlisting}
; die Bindung für eine Variable in einer Umgebung finden
(: lookup-environment (environment symbol -> value))

(check-expect
 (lookup-environment (list (make-binding 'slash 57)
                           (make-binding 'axl 60)) 
                     'axl)
 60)
(check-expect
 (lookup-environment (list (make-binding 'slash 57)
                           (make-binding 'axl 60))
                     'slash)
 57)
\end{lstlisting}
%
Hier ist die Schablone:
%
\begin{lstlisting}
(define lookup-environment
  (lambda (environment variable)
    (cond
      ((empty? environment) ...)
      ((cons? environment)
       ...
       (first environment)
       (binding-variable (first environment))
       (binding-value (first environment))
       (lookup-environment (rest environment) variable)
       ...)))))
\end{lstlisting}
%
Wie bei \lstinline{remove-environment-binding} vergleicht die Funktion
die Variable der Bindung mit der gesuchten Variable.  Hier ist die
fertige Funktion:
%
\indexvariable{lookup-environment}
\begin{lstlisting}
(define lookup-environment
  (lambda (environment variable)
    (cond
      ((empty? environment) (violation "unbound variable"))
      ((cons? environment)
       (if (equal? variable (binding-variable (first environment)))
           (binding-value (first environment))
           (lookup-environment (rest environment) variable))))))
\end{lstlisting}
%
%
Damit sind die Operationen auf Umgebungen abgeschlossen.  Als Nächstes
sind Dumps an der Reihe: $D$ ist als Folge von Frames definiert:
%
\begin{eqnarray*}
  D &\deq& (S\times E \times C)^\ast
\end{eqnarray*}
%
\indexvariable{dump}
\begin{lstlisting}
; Ein Dump ist eine Liste von Frames
(define dump (signature (list-of frame)))
\end{lstlisting}
%
Aus dem Frame-Tripeln machen wir eine Daten- und eine Record-Definition:
%
\begin{lstlisting}
; Ein Frame besteht aus:
; - Stack
; - Umgebung
; - Code
(define-record frame
  make-frame frame?
  (frame-stack stack)
  (frame-environment environment)
  (frame-code machine-code))
\end{lstlisting}
%
Schließlich fehlt noch eine Repräsentation für die Menge $W$ der
Werte: Ein Wert ist entweder ein Basiswert oder eine Closure.
Basiswerte wurden bereits in Abschnitt~\ref{page:basiswert} auf
Seite~\pageref{page:basiswert} definiert; es fehlen noch
Closures, also Tupel aus der Menge $V\times C\times E$.  Hier sind die
entsprechenden Definitionen:
%
\indexvariable{value}
\begin{lstlisting}
; Ein SECD-Wert ist ein Basiswert oder eine Closure
(define value (signature (mixed base closure)))

; Eine Closure besteht aus:
; - Variable
; - Code
; - Umgebung
(define-record closure
  make-closure closure?
  (closure-variable symbol)
  (closure-code machine-code)
  (closure-environment environment))
\end{lstlisting}
%
Mit Hilfe dieser Definitionen ist es möglich, eine Daten- und eine
Record-Definition für die Zustände der SECD-Maschine anzugeben, also
die Tupel aus $S\times E\times C\times D$:
%
\begin{lstlisting}
; Ein SECD-Zustand besteht aus:
; - Stack
; - Umgebung
; - Code
; - Dump
(define-record secd
  make-secd secd?
  (secd-stack stack)
  (secd-environment environment)
  (secd-code machine-code)
  (secd-dump dump))
\end{lstlisting}
%
Damit können wir endlich die Zustandsübergangsfunktion schreiben.  Sie
akzeptiert einen SECD-Zustand und liefert auch wieder einen.  Hier
sind Kurzbeschreibung und Signatur:
%
\begin{lstlisting}
; Zustandsübergang berechnen
(: secd-step (secd -> secd))
\end{lstlisting}
%
Testfälle brauch wir auch noch.  Wir machen einen Testfall pro Regel
für $\hookrightarrow$.  Hier ist die erste Regel, für Basiswerte:
%
\begin{displaymath}
  (\underline{s}, e, b\underline{c}, \underline{d})
  \hookrightarrow
  (b\underline{s}, e, \underline{c}, \underline{d})
\end{displaymath}
%
Um es zu testen, legen wir einen SECD-Zustand an, der als Code nur den
Basiswert hat.  Der müsste hinterher auf dem Stack gelandet sein:
%
\begin{lstlisting}
(check-expect
 (secd-step
  (make-secd empty the-empty-environment (list 5) empty))
 (make-secd (list 5) the-empty-environment empty empty))
\end{lstlisting}
%
Hier der Regel für Variablen:
%
\begin{displaymath}
  (\underline{s}, e, v\underline{c}, \underline{d})
  \hookrightarrow
  (e(v)\underline{s}, e, \underline{c}, \underline{d})
\end{displaymath}
%
Falls also der Code mit einer Variable anfängt, muss die SECD-Maschine
sie in der Umgebung nachschauen.  Wir stecken also eine Variable
namens \lstinline{axl} in den Code und legen eine Umgebung mit einer
Bindung für \lstinline{axl} bei.  Der Wert der Bindung muss dann auf
dem Stack landen:
%
\begin{lstlisting}
(check-expect
 (secd-step
  (make-secd empty (list (make-binding 'axl 60)) (list 'axl) empty))
 (make-secd (list 60) (list (make-binding 'axl 60)) empty empty))
\end{lstlisting}
%
Hier die Regel für Primitiva:
%
\begin{eqnarray*}
  (b_k\ldots b_1 \underline{s}, e, \mathtt{prim}_{F^k}\underline{c}, \underline{d})
  &\hookrightarrow&
  (b\underline{s}, e, \underline{c}, \underline{d})
  \\ && \textrm{wobei $F^k\in\Sigma^k$ und $F_B(b_1,\ldots,b_k) = b$}
\end{eqnarray*}
%
Für den Test nehmen wir als Primitivum die Addition.  Damit sie
arbeiten kann, benötigt sie die beiden Summanden auf dem Stack:
%
\begin{lstlisting}
(check-expect
 (secd-step
  (make-secd (list 23 42) the-empty-environment
             (list (make-prim '+ 2))
             empty))
 (make-secd (list 65) the-empty-environment empty empty))
\end{lstlisting}
%
Als nächstes ist die Abstraktionsregel dran:
%
\begin{displaymath}
  (\underline{s}, e, (v, \underline{c'}) \underline{c}, \underline{d})
  \hookrightarrow
  ((v, \underline{c'}, e) \underline{s}, e, \underline{c}, \underline{d})
\end{displaymath}
%
Für den Test bauen wir eine Abstraktion mit Parameter \lstinline{axl}
und freier Variable \lstinline{slash}.  Die Umgebung enthält 
eine Bindung für \lstinline{slash}~-- diese sollte dann in die Closure
eingepackt werden:
%
\begin{lstlisting}
(check-expect
 (secd-step
  (make-secd empty (list (make-binding 'slash 57))
             (list (make-abst 'axl 
                              (list 'axl 'slash (make-prim '+ 2))))
             empty))
 (make-secd (list (make-closure 'axl
                                (list 'axl 'slash (make-prim '+ 2))
                                (list (make-binding 'slash 57))))
            (list (make-binding 'slash 57))
            empty empty))
\end{lstlisting}
%
Schließlich bleibt noch die Applikationsregel:
%
\begin{displaymath}
  (w (v,\underline{c'}, e') \underline{s}, e, \mathtt{ap}~\underline{c}, \underline{d})
  \hookrightarrow
  (\epsilon, e'[v\mapsto w], \underline{c'}, (\underline{s}, e, \underline{c}) \underline{d})
\end{displaymath}
%
Um sie zu testen, legen wir die Closure aus dem vorigen Testfall auf
den Stack, zusammen mit einem Argument.  Danach sollte der Stack leer
sein, die Umgebung sollte aus der Closure übernommen worden sein, im
Code sollte es mit dem Code der Closure weitergehen und der Dump
sollte ein Frame enthalten:
%
\begin{lstlisting}
(check-expect
 (secd-step
  (make-secd (list 60
                   (make-closure 'axl
                                 (list 'axl 'slash (make-prim '+ 2))
                                 (list (make-binding 'slash 57))))
             the-empty-environment
             (list (make-ap)) empty))
 (make-secd empty
            (list (make-binding 'axl 60) (make-binding 'slash 57))
            (list 'axl 'slash (make-prim '+ 2))
            (list (make-frame empty the-empty-environment empty))))
\end{lstlisting}
%
Entsprechend den Regeln der SECD-Maschine muss der Rumpf von
\lstinline{secd-step}
eine Verzeigung zwischen den verschiedenen Fällen bei der
Code-Komponente von \lstinline{state} sein.  Diese folgen den
Konstruktionsanleitungen für Listen und für gemischte Daten.  Es ist
bereits an den Regeln abzulesen, dass alle Regeln Zugriff auf die
Komponenten von \lstinline{state} benötigen.  Für diese werden gleich am
Anfang lokale Variablen angelegt:
%
\indexvariable{secd-step}
\begin{lstlisting}
(define secd-step
  (lambda (state)
    (define stack (secd-stack state))
    (define environment (secd-environment state))
    (define code (secd-code state))
    (define dump (secd-dump state))
    (cond
      ((cons? code)
       (cond
         ((base? (first code)) ...)
         ((symbol? (first code)) ...)
         ((prim? (first code)) ...)
         ((abs? (first code)) ...)
         ((ap? (first code)) ...)))
      ((empty? code) ...))))
\end{lstlisting}
%
In diesem Gerüst werden nun die Regeln direkt abgebildet.  Hier zur
Erinnerung noch einmal die erste Regel für Basiswerte:
%
\begin{displaymath}
  (\underline{s}, e, b\underline{c}, \underline{d})
  \hookrightarrow
  (b\underline{s}, e, \underline{c}, \underline{d})
\end{displaymath}
%
Hier der passende Code dafür:
%
\begin{lstlisting}
(define secd-step
  (lambda (state)
      ...
        (cond
          ((base? (first code))
           (make-secd (cons (first code) stack)
                      environment
                      (rest code)
                      dump))
           ...)
      ...))
\end{lstlisting}
%
Hier die Regel für Variablen:
\begin{displaymath}
  (\underline{s}, e, v\underline{c}, \underline{d})
  \hookrightarrow
  (e(v)\underline{s}, e, \underline{c}, \underline{d})
\end{displaymath}
%
Hier der entsprechende Code:
%
\begin{lstlisting}
(define secd-step
  (lambda (state)
      ...
        (cond
          ((symbol? (first code))
           (make-secd (cons
                        (lookup-environment environment (first code))
                        stack)
                      environment
                      (rest code)
                      dump))
          ...)
      ...))
\end{lstlisting}
%
Die Regel für primitive Applikationen ist etwas aufwendiger:
%
\begin{eqnarray*}
  (b_k\ldots b_1 \underline{s}, e, \mathtt{prim}_{F^k}\underline{c}, \underline{d})
  &\hookrightarrow&
  (b\underline{s}, e, \underline{c}, \underline{d})
  \\ && \textrm{wobei $F^k\in\Sigma^k$ und $F_B(b_1,\ldots,b_k) = b$}
\end{eqnarray*}
%
Für die Implementierung werden Hilfsfunktionen gebraucht, welche die
Argumente vom Stack holen und in der Reihenfolge umdrehen, die
Argumente vom Stack entfernen und schließlich die eigentliche
$\delta$-Transition berechnen:
%
\begin{lstlisting}
(define secd-step
  (lambda (state)
      ...
        (cond
          ...
          ((prim? (first code))
           (make-secd (cons
                       (apply-primitive
                         (prim-operator (first code))
                         (take-reverse (prim-arity (first code)) 
                                       stack))
                       (drop (prim-arity (first code)) stack))
                      environment
                      (rest code)
                      dump))
           ...)
       ...))
\end{lstlisting}
%
Die Funktion \lstinline{drop} ist gerade die in
Aufgabe~\ref{ex:drop} auf Seite~\pageref{ex:drop} geforderte Funktion:
%
\begin{lstlisting}
; die ersten Elemente einer Liste weglassen
(: drop (natural (list-of %a) -> (list-of %a)))
\end{lstlisting}
%
Die \lstinline{take-reverse}-Funktion ist das Pendant zu
\lstinline{drop}, das die ersten $n$ Elemente einer Liste in
umgekehrter Reihenfolge liefert.  Dies machen wir mit einer
endrekursiven Hilfsfunktion.  Aus Abschnitt~\ref{sec:umgedrehte-liste}
auf Seite~\pageref{sec:umgedrehte-liste} wissen wir, dass bei
endrekursiver Konstruktion von Listen gerade immer die Reihenfolge
umgedreht wird:
%
\indexvariable{take-reverse}
\begin{lstlisting}
; die ersten Elemente einer Liste in umgekehrter Reihenfolge berechnen
(: take-reverse (natural (list-of %a) -> (list-of %a)))

(check-expect (take-reverse 2 '(1 2 3 4 5)) '(2 1))
(check-expect (take-reverse 0 '(1 2 3 4 5)) '())
(check-expect (take-reverse 5 '(1 2 3 4 5)) '(5 4 3 2 1))

(define take-reverse
  (lambda (n list0)
    ;; (: loop (natural (list-of a) (list-of a) -> (list-of a)))
    (define accumulate
      (lambda (n list acc)
        (cond
          ((zero? n) acc)
          ((positive? n)
           (accumulate (- n 1) (rest list)
                       (cons (first list) acc))))))
    (accumulate n list0 '())))
\end{lstlisting}
%
\begin{aufgabeinline}
  Programmiere eine andere Version von \lstinline{take-reverse}, indem
  Du zunächst eine endrekursive Funktion \lstinline{take} schreibst,
  welche für eine Zahl $n$ die ersten $n$ Elemente der Liste liefert.
  Schreibe dann \lstinline{take-reverse} als Kombination von
  \lstinline{take} und \lstinline{reverse}.  Was sind die Vor- und
  Nachteile beider Versionen von \lstinline{take-reverse}?
\end{aufgabeinline}
%
Aus einem Primitivum und einer Liste von Argumenten berechnet
\lstinline{apply-primitive} das Resultat der primitiven Applikation.
Dabei handelt es sich bei \lstinline{primitive} um eine
Fallunterscheidung, der Rumpf der Funktion ist also eine entsprechende
Verzweigung.  Für die Signatur von \lstinline{apply-primitive}
benötigen wir noch eine Signatur \lstinline{primitive}, passend zum
Prädikat \lstinline{primitive?} auf Seite~\pageref{page:primitivep}:
%
\indexvariable{primitive}
\indexvariable{apply-primitive}
\begin{lstlisting}
(define primitive (signature (predicate primitive?)))

; Delta-Transition berechnen
(: apply-primitive (primitive (list-of value) -> value))

(check-expect (apply-primitive '+ '(1 2)) 3)
(check-expect (apply-primitive '- '(2 1)) 1)

(define apply-primitive
  (lambda (primitive args)
    (cond
      ((equal? primitive '+)
       (+ (first args) (first (rest args))))
      ((equal? primitive '-)
       (- (first args) (first (rest args))))
      ((equal? primitive '=)
       (= (first args) (first (rest args))))
      ((equal? primitive '*)
       (* (first args) (first (rest args))))
      ((equal? primitive '/)
       (/ (first args) (first (rest args)))))))
\end{lstlisting}
%
Die Regel für Abstraktionen macht aus einer Abstraktion eine Closure:
\begin{displaymath}
  (\underline{s}, e, (v, \underline{c'}) \underline{c}, \underline{d})
  \hookrightarrow
  ((v, \underline{c'}, e) \underline{s}, e, \underline{c}, \underline{d})
\end{displaymath}
%
Der Code macht dies genauso:
%
\indexvariable{secd-step}
\begin{lstlisting}
(define secd-step
  (lambda (state)
      ...
        (cond
          ...
          ((abs? (first code))
           (make-secd (cons
                        (make-closure (abst-variable (first code))
                                      (abst-code (first code))
                                      environment)
                        stack)
                      environment
                      (rest code)
                      dump)))
       ...)))
\end{lstlisting}
%
Hier die Regel für die Applikation:
%
\begin{displaymath}
  (w (v,\underline{c'}, e') \underline{s}, e, \mathtt{ap}~\underline{c}, \underline{d})
  \hookrightarrow
  (\epsilon, e'[v\mapsto w], \underline{c'}, (\underline{s}, e, \underline{c}) \underline{d})
\end{displaymath}
%
Für $e'[v\mapsto w]$ benutzen wir die Funktion
\lstinline{extend-environment}, die wir weiter oben geschrieben haben:
%
\begin{lstlisting}
(define secd-step
  (lambda (state)
      ...
        (cond
          ...
         ((ap? (first code))
          (define closure (first (rest stack)))
          (make-secd empty  
                     (extend-environment
                      (closure-environment closure)
                      (closure-variable closure)
                      (first stack))
                     (closure-code closure)
                     (cons
                      (make-frame (rest (rest stack)) environment (rest code))
                      dump)))
          ...)
      ...))
\end{lstlisting}
%
Schließlich bleibt noch der Code für die Rückgabe eines Wertes von
einer Funktion.  Hier ist die Regel:
%
\begin{displaymath}
  (w, e, \epsilon, (\underline{s'}, e', \underline{c'}) \underline{d})
  \hookrightarrow
  (w\underline{s'}, e', \underline{c'}, \underline{d})
\end{displaymath}
%
Hier ist der Code dazu:
%
\begin{lstlisting}
(define secd-step
  (lambda (state)
      ...
      (cond
        ...
      ((empty? code)
       (define frame (first dump))
       (make-secd
        (cons (first stack)
              (frame-stack frame))
        (frame-environment frame)
        (frame-code frame)
        (rest dump))))
       ...))
\end{lstlisting}
%
Damit die SECD-Maschine in Betrieb genommen werden kann, muss ein Term
$e$ noch in einen Anfangszustand $(\epsilon, \varnothing, \llbracket
e\rrbracket, \epsilon)$ übersetzt werden.  Das erledigt folgende
Hilfsfunktion:
%
\indexvariable{inject-secd}
\begin{lstlisting}
; Aus Term SECD-Anfangszustand machen
(: inject-secd (term -> secd))
(define inject-secd
  (lambda (term)
    (make-secd empty
               the-empty-environment
               (term->machine-code/t term)
               empty)))
\end{lstlisting}
%
Nun können wir die Maschine ausprobieren:
%
\begin{lstlisting}
(secd-step (inject-secd '(+ 1 2)))
|\evalsto| #<record:secd (1) () (2 #<record:prim + 2>) ()>
(secd-step (secd-step (inject-secd '(+ 1 2))))
|\evalsto| #<record:secd (2 1) () (#<record:prim + 2>) ()>
(secd-step (secd-step (secd-step (inject-secd '(+ 1 2)))))
|\evalsto| #<record:secd (3) () () ()>
\end{lstlisting}
%
Es fehlt noch die Auswertungsfunktion $\mathrm{eval}_\mathrm{SECD}$,
die eine Hilfsfunktion benötigt, um den reflexiv-transitiven Abschluss des
Zustandsübergangs $\hookrightarrow^*$ zu berechnen:
%
\indexvariable{secd-step*}
\begin{lstlisting}
; bis zum Ende Zustandsübergänge berechnen
(: secd-step* (secd -> secd))
(define secd-step*
  (lambda (state)
    (if (and (empty? (secd-code state))
             (empty? (secd-dump state)))
        state
        (secd-step* (secd-step state)))))
\end{lstlisting}
%
Die Auswertungsfunktion orientiert sich direkt an der mathematischen
Definition:
%
\indexvariable{eval-secd}
\begin{lstlisting}
; Evaluationsfunktion zur SECD-Maschine berechnen
(: eval-secd (term -> (mixed value (enum 'function))))

(check-expect (eval-secd '(+ 1 2)) 3)
(check-expect (eval-secd '(((lambda (x) (lambda (y) (+ x y))) 1) 2))
              3)

(define eval-secd
  (lambda (term)
    (define value (first
                   (secd-stack
                    (secd-step* 
                     (inject-secd term)))))
    (if (base? value)
        value
        'function)))
\end{lstlisting}
%
Damit läuft die SECD-Maschine:
%
\begin{lstlisting}
(eval-secd '(((lambda (x) (lambda (y) (+ x y))) 1) 2))
|\evalsto| 3
\end{lstlisting}
%
Fertig!
%
\begin{aufgabeinline}
  Erweitere die Definition von \lstinline{secd-step} um die 
  Instruktion für binäre Verzweigungen.
\end{aufgabeinline}

\section{Die endrekursive SECD-Maschine}

Die SECD-Maschine hat einen Schönheitsfehler: Bei endkursiven
Applikationen sollte sie eigentlich, wie in Lehrsprachen-Programmen, keinerlei
zusätzlichen Platz verbrauchen, da kein Kontext anfällt.  Folgende
Beispielauswertung für den Term $(\lambda x.x~x)~(\lambda x.x~x)$
zeigt aber, dass der Dump mit fortschreitender Auswertung immer
größer wird:
%
% (secd-step*/tex (inject-secd '((lambda (x) (x x)) (lambda (x) (x x)))))
\begin{displaymath}\tiny
  \begin{array}{l@{}l@{}l@{}l@{}l}
&(\epsilon, &\varnothing, &(x, x~x~\mathtt{ap})\\ &&& (x, x~x~\mathtt{ap}) \\ &&&\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&((x, x~x~\mathtt{ap}, \varnothing), &\varnothing, &(x, x~x~\mathtt{ap})~\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&((x, x~x~\mathtt{ap}, \varnothing)~(x, x~x~\mathtt{ap}, \varnothing), &\varnothing, &\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&(\epsilon, &\{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, &x~x~\mathtt{ap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{ap}, \varnothing), &\{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, &x~\mathtt{ap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{ap}, \varnothing)~(x, x~x~\mathtt{ap}, \varnothing), &\{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, &\mathtt{ap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&(\epsilon, &\{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, &x~x~\mathtt{ap}, &(\epsilon, \{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, \epsilon)~(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{ap}, \varnothing), &\{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, &x~\mathtt{ap}, &(\epsilon, \{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, \epsilon)~(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{ap}, \varnothing)~(x, x~x~\mathtt{ap}, \varnothing), &\{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, &\mathtt{ap}, &(\epsilon, \{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, \epsilon)~(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&(\epsilon, &\{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, &x~x~\mathtt{ap}, &(\epsilon, \{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, \epsilon)~(\epsilon, \{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, \epsilon)~(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{ap}, \varnothing), &\{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, &x~\mathtt{ap}, &(\epsilon, \{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, \epsilon)~(\epsilon, \{(x, (x, x~x~\mathtt{ap}, \varnothing))\}, \epsilon)~(\epsilon, \varnothing, \epsilon))
\\
& \ldots
  \end{array}
\end{displaymath}
%
Dieses Manko können wir zum Glück reparieren: Die
SECD-Maschine muss endrekursive und "<normale"> Applikationen
unterschiedlich behandeln.  Dazu wird eine neue Instruktion namens
$\mathtt{tailap}$ eingeführt, die wie $\mathtt{ap}$ eine Applikation
durchführt, aber eine endrekursive Applikation signalisiert:
%
\begin{eqnarray*}
  I &\deq& \ldots\\
  &&\cup \{ \mathtt{tailap} \}
\end{eqnarray*}
%
Als Nächstes muss die Übersetzungsfunktion von Termen in Maschinencode
geändert werden:  Applikationen, die Kontext um sich herum haben,
sollen mit $\mathtt{ap}$ übersetzt werden, solche ohne Kontext mit
$\mathtt{tailap}$.  Da der Applikation allein der Kontext nicht
anzusehen ist, sondern nur dem Term "<drumherum">, wird die
Übersetzungsfunktion $\llbracket \underline{~} \rrbracket$ in zwei
Teile aufgespalten: für einen Term $e$ wird die Auswertungsfunktion $\llbracket\underline{~}\rrbracket$ immer dann benutzt, wenn um $e$ Kontext steht.  Eine
weitere Funktion $\llbracket \underline{~} \rrbracket'$ wird immer
dann aufgerufen, wenn \emph{kein} Kontext drumherum steht.

Kontext entsteht seinerseits immer durch Funktionsapplikationen.  Bei
der Auswertung eines Terms $(e_0~e_1)$ muss \emph{nach} $e_0$ noch
$e_1$ ausgewertet werden, und nach Auswertung von $e_1$ muss noch die
Applikation durchgeführt werden.  Sowohl $e_0$ als auch $e_1$ stehen
in Kontext.  Ähnlich ist es bei den Argumenten von primitiven
Applikationen.

Auf der anderen Seite schneiden Abstraktionen für ihren Rumpf den
Kontext erst einmal ab: Der Rumpf einer Abstraktion kommt schließlich bei der
Auswertung der Abstraktion noch gar nicht zum Zug.  Ob er Kontext hat
oder nicht, entscheidet sich erst bei der Applikation.
Dementsprechend schalten Applikationen und Abstraktionen zwischen den
beiden Funktionen $\llbracket \underline{~} \rrbracket$ und
$\llbracket \underline{~} \rrbracket'$ hin und her:
%
\begin{eqnarray*}
  \llbracket e \rrbracket &\deq&
  \begin{cases}
    b & \textrm{falls $e = b \in B$}\\
    v & \textrm{falls $e = v \in V$}\\
    \llbracket e_0\rrbracket~\llbracket e_1\rrbracket~\mathtt{ap}
    & \textrm{falls $e = (e_0~e_1)$}\\
    \llbracket e_1\rrbracket~\ldots~\llbracket e_k\rrbracket~\mathtt{prim}_{F^k}
    & \textrm{falls $e = (F~e_1~\ldots~e_k)$}\\
    (v, \llbracket e_0\rrbracket') & \textrm{falls $e = \lambda v.e_0$}
  \end{cases}\\[1ex]
  \llbracket e \rrbracket' &\deq&
  \begin{cases}
    b & \textrm{falls $e = b \in B$}\\
    v & \textrm{falls $e = v \in V$}\\
    \llbracket e_0\rrbracket~\llbracket e_1\rrbracket~\mathtt{tailap}
    & \textrm{falls $e = (e_0~e_1)$}\\
    \llbracket e_1\rrbracket~\ldots~\llbracket e_k\rrbracket~\mathtt{prim}_{F^k}
    & \textrm{falls $e = (F~e_1~\ldots~e_k)$}\\
    (v, \llbracket e_0\rrbracket') & \textrm{falls $e = \lambda v.e_0$}
  \end{cases}
\end{eqnarray*}
%
Jetzt brauchen wir
noch eine Zustandsübergangsregel her, die $\mathtt{tailap}$
verarbeitet.  Diese ergibt sich direkt aus den Regeln für
$\mathtt{ap}$ und die Rückgabe eines Wertes:  $\mathtt{tailap}$
funktioniert so, wie $\mathtt{ap}$ direkt gefolgt von der
Rückgaberegel.  Hier sind die beiden Regeln noch einmal zur Erinnerung:
%
\begin{eqnarray*}
   (w (v,\underline{c'}, e') \underline{s}, e, \mathtt{ap}~\underline{c}, \underline{d})
  &\hookrightarrow&
  (\epsilon, e'[v\mapsto w], \underline{c'}, (\underline{s}, e, \underline{c}) \underline{d})
  \\
  (w, e, \epsilon, (\underline{s'}, e', \underline{c'}) \underline{d})
  &\hookrightarrow&
  (w\underline{s'}, e', \underline{c'}, \underline{d})
\end{eqnarray*}
%
Da die erste Regel ein neues Dump-Frame erzeugt und die zweite ein
Dump-Frame "<vernichtet">, entfällt diese Arbeit in der Regel für
$\mathtt{tailap}$:
%
\begin{eqnarray*}
  (w (v,\underline{c'}, e') \underline{s}, e, \mathtt{tailap}~\underline{c}, \underline{d})
  &\hookrightarrow&
  (\underline{s}, e'[v \mapsto w], \underline{c'}, \underline{d})
\end{eqnarray*}
%
Damit läuft das Beispiel zwar immer noch endlos, aber immerhin, ohne
immer mehr Platz zu verbrauchen:
%
\begin{displaymath}\scriptsize
  \begin{array}{l@{}llll}
 \hookrightarrow{}&(\epsilon, &\varnothing, &(x, x~x~\mathtt{tailap})~(x, x~x~\mathtt{tailap})~\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&((x, x~x~\mathtt{tailap}, \varnothing), &\varnothing, &(x, x~x~\mathtt{tailap})~\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&((x, x~x~\mathtt{tailap}, \varnothing)~(x, x~x~\mathtt{tailap}, \varnothing), &\varnothing, &\mathtt{ap}, &\epsilon)\\
\hookrightarrow{}&(\epsilon, &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &x~x~\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{tailap}, \varnothing), &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &x~\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{tailap}, \varnothing)~(x, x~x~\mathtt{tailap}, \varnothing), &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&(\epsilon, &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &x~x~\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{tailap}, \varnothing), &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &x~\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{tailap}, \varnothing)~(x, x~x~\mathtt{tailap}, \varnothing), &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&(\epsilon, &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &x~x~\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{tailap}, \varnothing), &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &x~\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{tailap}, \varnothing)~(x, x~x~\mathtt{tailap}, \varnothing), &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&(\epsilon, &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &x~x~\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))\\
\hookrightarrow{}&((x, x~x~\mathtt{tailap}, \varnothing), &\{(x, (x, x~x~\mathtt{tailap}, \varnothing))\}, &x~\mathtt{tailap}, &(\epsilon, \varnothing, \epsilon))
 \end{array}
\end{displaymath}
Die Implementierung der endrekursiven SECD-Maschine ist Gegenstand von
Übungsaufgabe~\ref{aufgabe:secd-endekursiv-implementieren}.

\section*{Übungsaufgaben}


\begin{aufgabe}\label{aufgabe:secd-endekursiv-implementieren}
  Erweitere die Implementierung der SECD-Maschine um korrekte
  Behandlung der Endrekursion!  Erweitere dazu zunächst die
  Datendefinition für Maschinencode. Implementiere dann die
  Übersetzung von $\lambda$-Termen für die endrekursive SECD-Maschine.
  Erweitere schließlich die Zustandsübergangsfunktion um einen
  Fall für die $\mathtt{tailap}$-Instruktion.
\end{aufgabe}

\begin{aufgabe}\label{aufgabe:prim-arity}
  Erweitere die SECD-Maschine um Primitiva anderer Stelligkeiten,
  zum Beispiel \lstinline{abs} oder \lstinline{odd?}.
\end{aufgabe}

\begin{aufgabe}
  Erweitere den angewandten $\lambda$-Kalkül um Abstraktionen und
  Applikationen mit mehr als einem Parameter.  Erweitere die
  SECD-Maschine und ihre Implementierung entsprechend.
\end{aufgabe}

\begin{aufgabe}
  Zeige in der um Endrekursion erweiterten
  SECD-Maschine, dass \lstinline{tailap} immer am Ende steht, also
  tatsächlich keinen Kontext besitzt.
\end{aufgabe}

\begin{aufgabe}
  Die um Endrekursion erweiterte SECD-Maschine führt eine neue
  Maschinencode"=Instruktion \lstinline{tailap} ein.  Dies ist aber nicht
  unbedingt nötig, weil man die endrekursiven
  \lstinline{ap}-Instruktionen auch daran erkennen kann, dass sie am
  Ende vom Code stehen.

  Formuliere die Zustandsübergangsregeln der
  SECD-Maschine mit Endrekursion so um, dass die Funktionalität, also
  insbesondere die richtige Behandlung endrekursiver Applikationen, so
  dass sie auch mit dem Ergebnis des normalen Compilers funktioniert,
  der keine \lstinline{tailap}-Instruktion generiert.
  \end{aufgabe}

\begin{aufgabe}
  Anstatt Umgebungen durch Listen von Bindungen zu repräsentieren, ist
  es auch möglich, Funktionen zu verwenden, so dass
  \lstinline{lookup-environment} folgendermaßen aussieht:
\indexvariable{lookup-environment}
\begin{lstlisting}
(define lookup-environment
  (lambda (environment variable)
    (environment variable)))
\end{lstlisting}
  Ergänze eine passende Definition für
  \lstinline{extend-environment}.
\end{aufgabe}

\begin{aufgabe}
  Auf den ersten Blick erscheint es etwas aufwendig, jedesmal bei der
  Auswertung einer Abstraktion die gesamte Umgebung in die Closure
  einzupacken.  Was würde sich ändern, wenn dieser Schritt weggelassen
  würde, Closures also nur Variable und Maschinencode für den Rumpf
  enthalten würden?  Formuliere die entsprechenden Regeln für die
  SECD-Maschine und ändere Sie die Implementierung entsprechend.
  Funktioniert die SECD-Maschine nach der Änderung noch korrekt?
\end{aufgabe}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "i1"
%%% End: 

